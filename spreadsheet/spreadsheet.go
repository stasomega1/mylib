//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet

import (
	_cb "archive/zip"
	_de "errors"
	_ade "fmt"
	_g "github.com/unidoc/unioffice"
	_dc "github.com/unidoc/unioffice/chart"
	_gb "github.com/unidoc/unioffice/color"
	_bfd "github.com/unidoc/unioffice/common"
	_bf "github.com/unidoc/unioffice/common/license"
	_b "github.com/unidoc/unioffice/common/tempstorage"
	_cf "github.com/unidoc/unioffice/measurement"
	_dgf "github.com/unidoc/unioffice/schema/soo/dml"
	_ef "github.com/unidoc/unioffice/schema/soo/dml/chart"
	_ea "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing"
	_gbg "github.com/unidoc/unioffice/schema/soo/pkg/relationships"
	_ba "github.com/unidoc/unioffice/schema/soo/sml"
	_gdd "github.com/unidoc/unioffice/spreadsheet/format"
	_cgd "github.com/unidoc/unioffice/spreadsheet/formula"
	_dg "github.com/unidoc/unioffice/spreadsheet/reference"
	_cfa "github.com/unidoc/unioffice/spreadsheet/update"
	_da "github.com/unidoc/unioffice/vmldrawing"
	_e "github.com/unidoc/unioffice/zippkg"
	_gd "image"
	_ad "image/jpeg"
	_c "io"
	_ge "log"
	_ce "math"
	_gg "math/big"
	_af "os"
	_fb "path/filepath"
	_ff "regexp"
	_f "sort"
	_cg "strconv"
	_d "strings"
	_ag "time"
)

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_edda Drawing) AddImage(img _bfd.ImageRef, at AnchorType) Anchor {
	_afgg := 0
	for _edff, _ceed := range _edda._dea.Images {
		if _ceed == img {
			_afgg = _edff + 1
			break
		}
	}
	var _efb string
	for _dbg, _deea := range _edda._dea._cbgc {
		if _deea == _edda._bacd {
			_aege := _ade.Sprintf("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", _afgg, img.Format())
			_eegf := _edda._dea._dbagc[_dbg].AddRelationship(_aege, _g.ImageType)
			_efb = _eegf.ID()
			break
		}
	}
	var _gdgf Anchor
	var _gadd *_ea.CT_Picture
	switch at {
	case AnchorTypeAbsolute:
		_ggbg := _dgcf()
		_edda._bacd.EG_Anchor = append(_edda._bacd.EG_Anchor, &_ea.EG_Anchor{AbsoluteAnchor: _ggbg})
		_ggbg.Choice = &_ea.EG_ObjectChoicesChoice{}
		_ggbg.Choice.Pic = _ea.NewCT_Picture()
		_gadd = _ggbg.Choice.Pic
		_gdgf = AbsoluteAnchor{_ggbg}
	case AnchorTypeOneCell:
		_eebe := _ddf()
		_edda._bacd.EG_Anchor = append(_edda._bacd.EG_Anchor, &_ea.EG_Anchor{OneCellAnchor: _eebe})
		_eebe.Choice = &_ea.EG_ObjectChoicesChoice{}
		_eebe.Choice.Pic = _ea.NewCT_Picture()
		_gadd = _eebe.Choice.Pic
		_gdgf = OneCellAnchor{_eebe}
	case AnchorTypeTwoCell:
		_adfb := _aebf()
		_edda._bacd.EG_Anchor = append(_edda._bacd.EG_Anchor, &_ea.EG_Anchor{TwoCellAnchor: _adfb})
		_adfb.Choice = &_ea.EG_ObjectChoicesChoice{}
		_adfb.Choice.Pic = _ea.NewCT_Picture()
		_gadd = _adfb.Choice.Pic
		_gdgf = TwoCellAnchor{_adfb}
	}
	_gadd.NvPicPr.CNvPr.IdAttr = uint32(len(_edda._bacd.EG_Anchor))
	_gadd.NvPicPr.CNvPr.NameAttr = "\u0049\u006d\u0061g\u0065"
	_gadd.BlipFill.Blip = _dgf.NewCT_Blip()
	_gadd.BlipFill.Blip.EmbedAttr = _g.String(_efb)
	_gadd.BlipFill.Stretch = _dgf.NewCT_StretchInfoProperties()
	_gadd.SpPr = _dgf.NewCT_ShapeProperties()
	_gadd.SpPr.Xfrm = _dgf.NewCT_Transform2D()
	_gadd.SpPr.Xfrm.Off = _dgf.NewCT_Point2D()
	_gadd.SpPr.Xfrm.Off.XAttr.ST_CoordinateUnqualified = _g.Int64(0)
	_gadd.SpPr.Xfrm.Off.YAttr.ST_CoordinateUnqualified = _g.Int64(0)
	_gadd.SpPr.Xfrm.Ext = _dgf.NewCT_PositiveSize2D()
	_gadd.SpPr.Xfrm.Ext.CxAttr = int64(float64(img.Size().X*_cf.Pixel72) / _cf.EMU)
	_gadd.SpPr.Xfrm.Ext.CyAttr = int64(float64(img.Size().Y*_cf.Pixel72) / _cf.EMU)
	_gadd.SpPr.PrstGeom = _dgf.NewCT_PresetGeometry2D()
	_gadd.SpPr.PrstGeom.PrstAttr = _dgf.ST_ShapeTypeRect
	_gadd.SpPr.Ln = _dgf.NewCT_LineProperties()
	_gadd.SpPr.Ln.NoFill = _dgf.NewCT_NoFillProperties()
	return _gdgf
}

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_ddcc Cell) SetCachedFormulaResult(s string) { _ddcc._eeg.V = &s }

// X returns the inner wrapped XML type.
func (_ceeb Font) X() *_ba.CT_Font { return _ceeb._gcc }
func (_fcc RichTextRun) ensureRpr() {
	if _fcc._fgfg.RPr == nil {
		_fcc._fgfg.RPr = _ba.NewCT_RPrElt()
	}
}

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct {
	_dea  *Workbook
	_bacd *_ea.WsDr
}

func (_adb Cell) clearValue() {
	_adb._eeg.F = nil
	_adb._eeg.Is = nil
	_adb._eeg.V = nil
	_adb._eeg.TAttr = _ba.ST_CellTypeUnset
}
func (_gcgb PatternFill) X() *_ba.CT_PatternFill { return _gcgb._fefe }

// IsSheetLocked returns whether the sheet is locked.
func (_gbaf SheetProtection) IsSheetLocked() bool {
	return _gbaf._baca.SheetAttr != nil && *_gbaf._baca.SheetAttr
}

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_gee Cell) Reference() string {
	if _gee._eeg.RAttr != nil {
		return *_gee._eeg.RAttr
	}
	return ""
}

// Comment is a single comment within a sheet.
type Comment struct {
	_gcbe *Workbook
	_fdd  *_ba.CT_Comment
	_aaf  *_ba.Comments
}

// LockObject controls the locking of the sheet objects.
func (_abfg SheetProtection) LockObject(b bool) {
	if !b {
		_abfg._baca.ObjectsAttr = nil
	} else {
		_abfg._baca.ObjectsAttr = _g.Bool(true)
	}
}
func (_bdfb *Sheet) removeColumnFromMergedCells(_eede uint32) error {
	if _bdfb._edeb.MergeCells == nil || _bdfb._edeb.MergeCells.MergeCell == nil {
		return nil
	}
	_bdeb := []*_ba.CT_MergeCell{}
	for _, _ceg := range _bdfb.MergedCells() {
		_eada := _feae(_ceg.Reference(), _eede, true)
		if _eada != "" {
			_ceg.SetReference(_eada)
			_bdeb = append(_bdeb, _ceg.X())
		}
	}
	_bdfb._edeb.MergeCells.MergeCell = _bdeb
	return nil
}

// X returns the inner wrapped XML type.
func (_dgcd IconScale) X() *_ba.CT_IconSet { return _dgcd._dacb }

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_cfeg Comparer) LessRows(column string, lhs, rhs Row) bool {
	var _dcac, _bcfc Cell
	for _, _cde := range lhs.Cells() {
		_affd, _ := _dg.ParseCellReference(_cde.Reference())
		if _affd.Column == column {
			_dcac = _cde
			break
		}
	}
	for _, _cae := range rhs.Cells() {
		_aeca, _ := _dg.ParseCellReference(_cae.Reference())
		if _aeca.Column == column {
			_bcfc = _cae
			break
		}
	}
	return _cfeg.LessCells(_dcac, _bcfc)
}

// Column returns the cell column
func (_eec Cell) Column() (string, error) {
	_cff, _dgb := _dg.ParseCellReference(_eec.Reference())
	if _dgb != nil {
		return "", _dgb
	}
	return _cff.Column, nil
}

// HasNumberFormat returns true if the cell style has a number format applied.
func (_abg CellStyle) HasNumberFormat() bool {
	return _abg._daa.NumFmtIdAttr != nil && _abg._daa.ApplyNumberFormatAttr != nil && *_abg._daa.ApplyNumberFormatAttr
}

// SetBold causes the text to be displayed in bold.
func (_dbac RichTextRun) SetBold(b bool) {
	_dbac.ensureRpr()
	_dbac._fgfg.RPr.B = _ba.NewCT_BooleanProperty()
	_dbac._fgfg.RPr.B.ValAttr = _g.Bool(b)
}

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_eeae StyleSheet) Fills() Fills { return Fills{_eeae._gfde.Fills} }

// X returns the inner wrapped XML type.
func (_bgd DataBarScale) X() *_ba.CT_DataBar { return _bgd._abb }

// ClearProtection removes any protections applied to teh sheet.
func (_edffc *Sheet) ClearProtection() { _edffc._edeb.SheetProtection = nil }

// BottomRight is a no-op.
func (_beg OneCellAnchor) BottomRight() CellMarker { return CellMarker{} }

// Type returns the type of anchor
func (_aga AbsoluteAnchor) Type() AnchorType { return AnchorTypeAbsolute }

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_beda Row) AddNamedCell(col string) Cell {
	_becb := _ba.NewCT_Cell()
	_becb.RAttr = _g.Stringf("\u0025\u0073\u0025\u0064", col, _beda.RowNumber())
	_fceb := -1
	_ace := _dg.ColumnToIndex(col)
	for _eeeg, _fabc := range _beda._agbf.C {
		_dcgd, _bcbbc := _dg.ParseCellReference(*_fabc.RAttr)
		if _bcbbc != nil {
			return Cell{}
		}
		if _ace < _dcgd.ColumnIdx {
			_fceb = _eeeg
			break
		}
	}
	if _fceb == -1 {
		_beda._agbf.C = append(_beda._agbf.C, _becb)
	} else {
		_beda._agbf.C = append(_beda._agbf.C[:_fceb], append([]*_ba.CT_Cell{_becb}, _beda._agbf.C[_fceb:]...)...)
	}
	return Cell{_beda._bdaf, _beda._edfa, _beda._agbf, _becb}
}

// Name returns the name of the table
func (_dbcb Table) Name() string {
	if _dbcb._eega.NameAttr != nil {
		return *_dbcb._eega.NameAttr
	}
	return ""
}

// SetWidth controls the width of a column.
func (_cbg Column) SetWidth(w _cf.Distance) {
	_cbg._eaac.WidthAttr = _g.Float64(float64(w / _cf.Character))
}

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct {
	_ggec *Workbook
	_cgg  *_ba.CT_NumFmt
}

// CellStyle is a formatting style for a cell.  CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct {
	_fga *Workbook
	_daa *_ba.CT_Xf
	_ebe *_ba.CT_CellXfs
}

// GetValueAsNumber retrieves the cell's value as a number
func (_bcf Cell) GetValueAsNumber() (float64, error) {
	if _bcf._eeg.V == nil && _bcf._eeg.Is == nil {
		return 0, nil
	}
	if _bcf._eeg.TAttr == _ba.ST_CellTypeS || !_gdd.IsNumber(*_bcf._eeg.V) {
		return _ce.NaN(), _de.New("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065")
	}
	return _cg.ParseFloat(*_bcf._eeg.V, 64)
}

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_cfaa Cell) SetNumberWithStyle(v float64, f StandardFormat) {
	_cfaa.SetNumber(v)
	_cfaa.SetStyle(_cfaa._agg.StyleSheet.GetOrCreateStandardNumberFormat(f))
}

var _afge *_ff.Regexp = _ff.MustCompile("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024")

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_defb Cell) SetStyleIndex(idx uint32) { _defb._eeg.SAttr = _g.Uint32(idx) }

// AddMergedCells merges cells within a sheet.
func (_gcge *Sheet) AddMergedCells(fromRef, toRef string) MergedCell {
	if _gcge._edeb.MergeCells == nil {
		_gcge._edeb.MergeCells = _ba.NewCT_MergeCells()
	}
	_fec := _ba.NewCT_MergeCell()
	_fec.RefAttr = _ade.Sprintf("\u0025\u0073\u003a%\u0073", fromRef, toRef)
	_gcge._edeb.MergeCells.MergeCell = append(_gcge._edeb.MergeCells.MergeCell, _fec)
	_gcge._edeb.MergeCells.CountAttr = _g.Uint32(uint32(len(_gcge._edeb.MergeCells.MergeCell)))
	return MergedCell{_gcge._ebee, _gcge, _fec}
}
func (_gagab *Workbook) createCustomProperties() {
	_gagab.CustomProperties = _bfd.NewCustomProperties()
	_gagab.addCustomRelationships()
}

// SetHeight sets the row height in points.
func (_bbeb Row) SetHeight(d _cf.Distance) {
	_bbeb._agbf.HtAttr = _g.Float64(float64(d))
	_bbeb._agbf.CustomHeightAttr = _g.Bool(true)
}

// Row is a row within a spreadsheet.
type Row struct {
	_bdaf *Workbook
	_edfa *Sheet
	_agbf *_ba.CT_Row
}

// SetShowValue controls if the cell value is displayed.
func (_ffedg DataBarScale) SetShowValue(b bool) { _ffedg._abb.ShowValueAttr = _g.Bool(b) }

// IsWindowLocked returns whether the workbook windows are locked.
func (_bffd WorkbookProtection) IsWindowLocked() bool {
	return _bffd._aba.LockWindowsAttr != nil && *_bffd._aba.LockWindowsAttr
}

// AddBorder creates a new empty border that can be applied to a cell style.
func (_daacf StyleSheet) AddBorder() Border {
	_aaabg := _ba.NewCT_Border()
	_daacf._gfde.Borders.Border = append(_daacf._gfde.Borders.Border, _aaabg)
	_daacf._gfde.Borders.CountAttr = _g.Uint32(uint32(len(_daacf._gfde.Borders.Border)))
	return Border{_aaabg, _daacf._gfde.Borders}
}
func _feb(_efda bool) int {
	if _efda {
		return 1
	}
	return 0
}

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{ _dddf *_ba.CT_DataValidation }

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_gaed PatternFill) SetFgColor(c _gb.Color) {
	_gaed._fefe.FgColor = _ba.NewCT_Color()
	_gaed._fefe.FgColor.RgbAttr = c.AsRGBAString()
}
func (_cdg DataValidation) clear() {
	_cdg._daec.Formula1 = _g.String("\u0030")
	_cdg._daec.Formula2 = _g.String("\u0030")
}

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_gcgg NumberFormat) ID() uint32 { return _gcgg._cgg.NumFmtIdAttr }

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_dff CellStyle) NumberFormat() uint32 {
	if _dff._daa.NumFmtIdAttr == nil {
		return 0
	}
	return *_dff._daa.NumFmtIdAttr
}

// RowOffset returns the offset from the row cell.
func (_fgd CellMarker) RowOffset() _cf.Distance {
	if _fgd._ccb.RowOff.ST_CoordinateUnqualified == nil {
		return 0
	}
	return _cf.Distance(float64(*_fgd._ccb.RowOff.ST_CoordinateUnqualified) * _cf.EMU)
}

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_debe Drawing) AddChart(at AnchorType) (_dc.Chart, Anchor) {
	_ccdf := _ef.NewChartSpace()
	_debe._dea._bgfa = append(_debe._dea._bgfa, _ccdf)
	_fcbdg := _g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.ChartContentType, len(_debe._dea._bgfa))
	_debe._dea.ContentTypes.AddOverride(_fcbdg, _g.ChartContentType)
	var _aab string
	for _fee, _eddf := range _debe._dea._cbgc {
		if _eddf == _debe._bacd {
			_fcaf := _g.RelativeFilename(_g.DocTypeSpreadsheet, _g.DrawingType, _g.ChartType, len(_debe._dea._bgfa))
			_bgdc := _debe._dea._dbagc[_fee].AddRelationship(_fcaf, _g.ChartType)
			_aab = _bgdc.ID()
			break
		}
	}
	var _dade Anchor
	var _fdcc *_ea.CT_GraphicalObjectFrame
	switch at {
	case AnchorTypeAbsolute:
		_cgec := _dgcf()
		_debe._bacd.EG_Anchor = append(_debe._bacd.EG_Anchor, &_ea.EG_Anchor{AbsoluteAnchor: _cgec})
		_cgec.Choice = &_ea.EG_ObjectChoicesChoice{}
		_cgec.Choice.GraphicFrame = _ea.NewCT_GraphicalObjectFrame()
		_fdcc = _cgec.Choice.GraphicFrame
		_dade = AbsoluteAnchor{_cgec}
	case AnchorTypeOneCell:
		_bdbc := _ddf()
		_debe._bacd.EG_Anchor = append(_debe._bacd.EG_Anchor, &_ea.EG_Anchor{OneCellAnchor: _bdbc})
		_bdbc.Choice = &_ea.EG_ObjectChoicesChoice{}
		_bdbc.Choice.GraphicFrame = _ea.NewCT_GraphicalObjectFrame()
		_fdcc = _bdbc.Choice.GraphicFrame
		_dade = OneCellAnchor{_bdbc}
	case AnchorTypeTwoCell:
		_cbgb := _aebf()
		_debe._bacd.EG_Anchor = append(_debe._bacd.EG_Anchor, &_ea.EG_Anchor{TwoCellAnchor: _cbgb})
		_cbgb.Choice = &_ea.EG_ObjectChoicesChoice{}
		_cbgb.Choice.GraphicFrame = _ea.NewCT_GraphicalObjectFrame()
		_fdcc = _cbgb.Choice.GraphicFrame
		_dade = TwoCellAnchor{_cbgb}
	}
	_fdcc.NvGraphicFramePr = _ea.NewCT_GraphicalObjectFrameNonVisual()
	_fdcc.NvGraphicFramePr.CNvPr.IdAttr = uint32(len(_debe._bacd.EG_Anchor))
	_fdcc.NvGraphicFramePr.CNvPr.NameAttr = "\u0043\u0068\u0061r\u0074"
	_fdcc.Graphic = _dgf.NewGraphic()
	_fdcc.Graphic.GraphicData.UriAttr = "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074"
	_cbgf := _ef.NewChart()
	_cbgf.IdAttr = _aab
	_fdcc.Graphic.GraphicData.Any = []_g.Any{_cbgf}
	_dgga := _dc.MakeChart(_ccdf)
	_dgga.Properties().SetSolidFill(_gb.White)
	_dgga.SetDisplayBlanksAs(_ef.ST_DispBlanksAsGap)
	return _dgga, _dade
}

// X returns the inner wrapped XML type.
func (_dbcc MergedCell) X() *_ba.CT_MergeCell { return _dbcc._ddgc }

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{ Order SortOrder }

// SetType sets the type of the rule.
func (_efcc ConditionalFormattingRule) SetType(t _ba.ST_CfType) { _efcc._bcca.TypeAttr = t }

// SheetCount returns the number of sheets in the workbook.
func (_bbfb Workbook) SheetCount() int { return len(_bbfb._fgc) }

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{ _dgec *_ba.CT_ColorScale }

// SetFont applies a font to a cell style.  The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_ccfb CellStyle) SetFont(f Font) {
	_ccfb._daa.FontIdAttr = _g.Uint32(f.Index())
	_ccfb._daa.ApplyFontAttr = _g.Bool(true)
}

type Fills struct{ _caabg *_ba.CT_Fills }

// HasFormula returns true if the cell contains formula.
func (_cad *evalContext) HasFormula(cellRef string) bool {
	return _cad._abgg.Cell(cellRef).HasFormula()
}

// SetWidth sets the width of the anchored object.
func (_ga AbsoluteAnchor) SetWidth(w _cf.Distance) { _ga._deb.Ext.CxAttr = int64(w / _cf.EMU) }

// SetRow set the row of the cell marker.
func (_debb CellMarker) SetRow(row int32) { _debb._ccb.Row = row }

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gdeg *Sheet) RecalculateFormulas() {
	_dedd := _cgd.NewEvaluator()
	_fcbac := _gdeg.FormulaContext()
	for _, _dace := range _gdeg.Rows() {
		for _, _gdaa := range _dace.Cells() {
			if _gdaa.X().F != nil {
				_eeff := _gdaa.X().F.Content
				if _gdaa.X().F.TAttr == _ba.ST_CellFormulaTypeShared && len(_eeff) == 0 {
					continue
				}
				_efgc := _dedd.Eval(_fcbac, _eeff).AsString()
				if _efgc.Type == _cgd.ResultTypeError {
					_g.Log("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073", _eeff, _efgc.ErrorMessage)
					_gdaa.X().V = nil
				} else {
					if _efgc.Type == _cgd.ResultTypeNumber {
						_gdaa.X().TAttr = _ba.ST_CellTypeN
					} else {
						_gdaa.X().TAttr = _ba.ST_CellTypeInlineStr
					}
					_gdaa.X().V = _g.String(_efgc.Value())
					if _gdaa.X().F.TAttr == _ba.ST_CellFormulaTypeArray {
						if _efgc.Type == _cgd.ResultTypeArray {
							_gdeg.setArray(_gdaa.Reference(), _efgc)
						} else if _efgc.Type == _cgd.ResultTypeList {
							_gdeg.setList(_gdaa.Reference(), _efgc)
						}
					} else if _gdaa.X().F.TAttr == _ba.ST_CellFormulaTypeShared && _gdaa.X().F.RefAttr != nil {
						_bfbf, _fdcf, _edbge := _dg.ParseRangeReference(*_gdaa.X().F.RefAttr)
						if _edbge != nil {
							_ge.Printf("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073", _edbge)
							continue
						}
						_gdeg.setShared(_gdaa.Reference(), _bfbf, _fdcf, _eeff)
					}
				}
			}
		}
	}
}
func (_aad ConditionalFormattingRule) InitializeDefaults() {
	_aad.SetType(_ba.ST_CfTypeCellIs)
	_aad.SetOperator(_ba.ST_ConditionalFormattingOperatorGreaterThan)
	_aad.SetPriority(1)
}

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_fcfc *Workbook) AddDrawing() Drawing {
	_badg := _ea.NewWsDr()
	_fcfc._cbgc = append(_fcfc._cbgc, _badg)
	_bfcb := _g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.DrawingType, len(_fcfc._cbgc))
	_fcfc.ContentTypes.AddOverride(_bfcb, _g.DrawingContentType)
	_fcfc._dbagc = append(_fcfc._dbagc, _bfd.NewRelationships())
	return Drawing{_fcfc, _badg}
}

// AnchorType is the type of anchor.
type AnchorType byte

// Comments returns the comments for a sheet.
func (_cbge *Sheet) Comments() Comments {
	for _cbdb, _bcba := range _cbge._ebee._fgc {
		if _bcba == _cbge._edeb {
			if _cbge._ebee._eabg[_cbdb] == nil {
				_cbge._ebee._eabg[_cbdb] = _ba.NewComments()
				_cbge._ebee._gcga[_cbdb].AddAutoRelationship(_g.DocTypeSpreadsheet, _g.WorksheetType, _cbdb+1, _g.CommentsType)
				_cbge._ebee.ContentTypes.AddOverride(_g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.CommentsType, _cbdb+1), _g.CommentsContentType)
			}
			if len(_cbge._ebee._effd) == 0 {
				_cbge._ebee._effd = append(_cbge._ebee._effd, _da.NewCommentDrawing())
				_bfdc := _cbge._ebee._gcga[_cbdb].AddAutoRelationship(_g.DocTypeSpreadsheet, _g.WorksheetType, 1, _g.VMLDrawingType)
				if _cbge._edeb.LegacyDrawing == nil {
					_cbge._edeb.LegacyDrawing = _ba.NewCT_LegacyDrawing()
				}
				_cbge._edeb.LegacyDrawing.IdAttr = _bfdc.ID()
			}
			return Comments{_cbge._ebee, _cbge._ebee._eabg[_cbdb]}
		}
	}
	_g.Log("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t")
	return Comments{}
}
func (_fcf Border) SetRight(style _ba.ST_BorderStyle, c _gb.Color) {
	if _fcf._cba.Right == nil {
		_fcf._cba.Right = _ba.NewCT_BorderPr()
	}
	_fcf._cba.Right.Color = _ba.NewCT_Color()
	_fcf._cba.Right.Color.RgbAttr = c.AsRGBAString()
	_fcf._cba.Right.StyleAttr = style
}

type ConditionalFormattingRule struct{ _bcca *_ba.CT_CfRule }

const _gdga = "_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065"

func (_effg Sheet) validateRowCellNumbers() error {
	_dceb := map[uint32]struct{}{}
	for _, _egff := range _effg._edeb.SheetData.Row {
		if _egff.RAttr != nil {
			if _, _eacg := _dceb[*_egff.RAttr]; _eacg {
				return _ade.Errorf("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064", _effg.Name(), *_egff.RAttr)
			}
			_dceb[*_egff.RAttr] = struct{}{}
		}
		_badb := map[string]struct{}{}
		for _, _aadc := range _egff.C {
			if _aadc.RAttr == nil {
				continue
			}
			if _, _ced := _badb[*_aadc.RAttr]; _ced {
				return _ade.Errorf("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073", _effg.Name(), *_aadc.RAttr)
			}
			_badb[*_aadc.RAttr] = struct{}{}
		}
	}
	return nil
}
func NewPatternFill(fills *_ba.CT_Fills) PatternFill {
	_ddfa := _ba.NewCT_Fill()
	_ddfa.PatternFill = _ba.NewCT_PatternFill()
	return PatternFill{_ddfa.PatternFill, _ddfa}
}

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_accc *evalContext) LastRow(col string) int {
	_dbag := _accc._abgg
	_cbd := int(_dg.ColumnToIndex(col))
	_daca := 1
	for _, _cgbg := range _dbag._edeb.SheetData.Row {
		if _cgbg.RAttr != nil {
			_gacc := Row{_dbag._ebee, _dbag, _cgbg}
			_adbf := len(_gacc.Cells())
			if _adbf > _cbd {
				_daca = int(_gacc.RowNumber())
			}
		}
	}
	return _daca
}

// IsDBCS returns if a workbook's default language is among DBCS.
func (_ccfd *evalContext) IsDBCS() bool {
	_dgbe := _ccfd._abgg._ebee.CoreProperties.X().Language
	if _dgbe == nil {
		return false
	}
	_efeb := string(_dgbe.Data)
	for _, _fbea := range _cgcc {
		if _efeb == _fbea {
			return true
		}
	}
	return false
}

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_eaeb StyleSheet) GetOrCreateStandardNumberFormat(f StandardFormat) CellStyle {
	for _, _edba := range _eaeb.CellStyles() {
		if _edba.HasNumberFormat() && _edba.NumberFormat() == uint32(f) {
			return _edba
		}
	}
	_gdac := _eaeb.AddCellStyle()
	_gdac.SetNumberFormatStandard(f)
	return _gdac
}

// Tables returns a slice of all defined tables in the workbook.
func (_abcec *Workbook) Tables() []Table {
	if _abcec._eedb == nil {
		return nil
	}
	_ebfe := []Table{}
	for _, _adgc := range _abcec._eedb {
		_ebfe = append(_ebfe, Table{_adgc})
	}
	return _ebfe
}

// StyleSheet is a document style sheet.
type StyleSheet struct {
	_aced *Workbook
	_gfde *_ba.StyleSheet
}

// Reference returns the region of cells that are merged.
func (_agaf MergedCell) Reference() string { return _agaf._ddgc.RefAttr }

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_cffb Cell) GetCachedFormulaResult() string {
	if _cffb._eeg.V != nil {
		return *_cffb._eeg.V
	}
	return ""
}

// SetHeightCells is a no-op.
func (_dgc AbsoluteAnchor) SetHeightCells(int32) {}
func (_afae *Sheet) setShared(_badbf string, _cfcd, _ccab _dg.CellReference, _cged string) {
	_ffgd := _afae.FormulaContext()
	_fcee := _cgd.NewEvaluator()
	for _bfagd := _cfcd.RowIdx; _bfagd <= _ccab.RowIdx; _bfagd++ {
		for _bccc := _cfcd.ColumnIdx; _bccc <= _ccab.ColumnIdx; _bccc++ {
			_gacbf := _bfagd - _cfcd.RowIdx
			_feba := _bccc - _cfcd.ColumnIdx
			_ffgd.SetOffset(_feba, _gacbf)
			_abgga := _fcee.Eval(_ffgd, _cged)
			_gfb := _ade.Sprintf("\u0025\u0073\u0025\u0064", _dg.IndexToColumn(_bccc), _bfagd)
			_edfg := _afae.Cell(_gfb)
			if _abgga.Type == _cgd.ResultTypeNumber {
				_edfg.X().TAttr = _ba.ST_CellTypeN
			} else {
				_edfg.X().TAttr = _ba.ST_CellTypeInlineStr
			}
			_edfg.X().V = _g.String(_abgga.Value())
		}
	}
	_ = _fcee
	_ = _ffgd
}
func _ddf() *_ea.CT_OneCellAnchor { _ada := _ea.NewCT_OneCellAnchor(); return _ada }

// GetFormat sets the number format code.
func (_gfcd NumberFormat) GetFormat() string { return _gfcd._cgg.FormatCodeAttr }

// X returns the inner wrapped XML type.
func (_babe NumberFormat) X() *_ba.CT_NumFmt { return _babe._cgg }

// X returns the inner wrapped XML type.
func (_bag Cell) X() *_ba.CT_Cell { return _bag._eeg }

// X returns the inner wrapped XML type.
func (_cfef SheetProtection) X() *_ba.CT_SheetProtection { return _cfef._baca }
func _aebf() *_ea.CT_TwoCellAnchor {
	_gdba := _ea.NewCT_TwoCellAnchor()
	_gdba.EditAsAttr = _ea.ST_EditAsOneCell
	_gdba.From.Col = 5
	_gdba.From.Row = 0
	_gdba.From.ColOff.ST_CoordinateUnqualified = _g.Int64(0)
	_gdba.From.RowOff.ST_CoordinateUnqualified = _g.Int64(0)
	_gdba.To.Col = 10
	_gdba.To.Row = 20
	_gdba.To.ColOff.ST_CoordinateUnqualified = _g.Int64(0)
	_gdba.To.RowOff.ST_CoordinateUnqualified = _g.Int64(0)
	return _gdba
}

type PatternFill struct {
	_fefe *_ba.CT_PatternFill
	_eac  *_ba.CT_Fill
}

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_abfc *Sheet) SetFrozen(firstRow, firstCol bool) {
	_abfc._edeb.SheetViews = nil
	_egdb := _abfc.AddView()
	_egdb.SetState(_ba.ST_PaneStateFrozen)
	switch {
	case firstRow && firstCol:
		_egdb.SetYSplit(1)
		_egdb.SetXSplit(1)
		_egdb.SetTopLeft("\u0042\u0032")
	case firstRow:
		_egdb.SetYSplit(1)
		_egdb.SetTopLeft("\u0041\u0032")
	case firstCol:
		_egdb.SetXSplit(1)
		_egdb.SetTopLeft("\u0042\u0031")
	}
}

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_ac Cell) GetFormattedValue() string {
	_efd := _ac.getFormat()
	switch _ac._eeg.TAttr {
	case _ba.ST_CellTypeB:
		_cda, _ := _ac.GetValueAsBool()
		if _cda {
			return "\u0054\u0052\u0055\u0045"
		}
		return "\u0046\u0041\u004cS\u0045"
	case _ba.ST_CellTypeN:
		_dgfc, _ := _ac.GetValueAsNumber()
		return _gdd.Number(_dgfc, _efd)
	case _ba.ST_CellTypeE:
		if _ac._eeg.V != nil {
			return *_ac._eeg.V
		}
		return ""
	case _ba.ST_CellTypeS, _ba.ST_CellTypeInlineStr:
		return _gdd.String(_ac.GetString(), _efd)
	case _ba.ST_CellTypeStr:
		_bg := _ac.GetString()
		if _gdd.IsNumber(_bg) {
			_bfe, _ := _cg.ParseFloat(_bg, 64)
			return _gdd.Number(_bfe, _efd)
		}
		return _gdd.String(_bg, _efd)
	case _ba.ST_CellTypeUnset:
		fallthrough
	default:
		_ae, _ := _ac.GetRawValue()
		if len(_ae) == 0 {
			return ""
		}
		_bagdg, _fbg := _ac.GetValueAsNumber()
		if _fbg == nil {
			return _gdd.Number(_bagdg, _efd)
		}
		return _gdd.String(_ae, _efd)
	}
}

var _cgcc []string = []string{"\u007a\u0068\u002dH\u004b", "\u007a\u0068\u002dM\u004f", "\u007a\u0068\u002dC\u004e", "\u007a\u0068\u002dS\u0047", "\u007a\u0068\u002dT\u0057", "\u006a\u0061\u002dJ\u0050", "\u006b\u006f\u002dK\u0052"}

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_cfcc SheetView) SetZoom(pct uint32) { _cfcc._adgd.ZoomScaleAttr = &pct }

// SetHidden marks the defined name as hidden.
func (_eff DefinedName) SetLocalSheetID(id uint32) { _eff._dcd.LocalSheetIdAttr = _g.Uint32(id) }
func (_bgf *evalContext) Sheet(name string) _cgd.Context {
	for _, _gbc := range _bgf._abgg._ebee.Sheets() {
		if _gbc.Name() == name {
			return _gbc.FormulaContext()
		}
	}
	return _cgd.InvalidReferenceContext
}

// GetFormat returns a cell data format.
func (_edf *evalContext) GetFormat(cellRef string) string {
	return _edf._abgg.Cell(cellRef).getFormat()
}

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings() SharedStrings {
	return SharedStrings{_faeg: _ba.NewSst(), _ceae: make(map[string]int)}
}

// Protection allows control over the workbook protections.
func (_abeg *Workbook) Protection() WorkbookProtection {
	if _abeg._badbd.WorkbookProtection == nil {
		_abeg._badbd.WorkbookProtection = _ba.NewCT_WorkbookProtection()
	}
	return WorkbookProtection{_abeg._badbd.WorkbookProtection}
}

// Type returns the type of the rule
func (_fge ConditionalFormattingRule) Type() _ba.ST_CfType { return _fge._bcca.TypeAttr }

// SetAllowBlank controls if blank values are accepted.
func (_fbdg DataValidation) SetAllowBlank(b bool) {
	if !b {
		_fbdg._daec.AllowBlankAttr = nil
	} else {
		_fbdg._daec.AllowBlankAttr = _g.Bool(true)
	}
}

// SetInlineString adds a string inline instead of in the shared strings table.
func (_aa Cell) SetInlineString(s string) {
	_aa.clearValue()
	_aa._eeg.Is = _ba.NewCT_Rst()
	_aa._eeg.Is.T = _g.String(s)
	_aa._eeg.TAttr = _ba.ST_CellTypeInlineStr
}

type DifferentialStyle struct {
	_geff *_ba.CT_Dxf
	_gbdg *Workbook
	_fba  *_ba.CT_Dxfs
}

// SetHeightAuto sets the row height to be automatically determined.
func (_dbcce Row) SetHeightAuto() { _dbcce._agbf.HtAttr = nil; _dbcce._agbf.CustomHeightAttr = nil }

// ClearFont clears any font configuration from the cell style.
func (_gda CellStyle) ClearFont() { _gda._daa.FontIdAttr = nil; _gda._daa.ApplyFontAttr = nil }

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_ccfg Comparer) LessCells(lhs, rhs Cell) bool {
	if _ccfg.Order == SortOrderDescending {
		lhs, rhs = rhs, lhs
	}
	if lhs.X() == nil {
		if rhs.X() == nil {
			return false
		}
		return true
	}
	if rhs.X() == nil {
		return false
	}
	_dgd, _ged := lhs.getRawSortValue()
	_aag, _befgd := rhs.getRawSortValue()
	switch {
	case _ged && _befgd:
		_aea, _ := _cg.ParseFloat(_dgd, 64)
		_gfg, _ := _cg.ParseFloat(_aag, 64)
		return _aea < _gfg
	case _ged:
		return true
	case _befgd:
		return false
	}
	_dgd = lhs.GetFormattedValue()
	_aag = rhs.GetFormattedValue()
	return _dgd < _aag
}
func (_gebc *Sheet) getAllCellsInFormulaArrays(_dgef bool) (map[string]bool, error) {
	_cgafd := _cgd.NewEvaluator()
	_gdbf := _gebc.FormulaContext()
	_aee := map[string]bool{}
	for _, _dgeb := range _gebc.Rows() {
		for _, _fcfg := range _dgeb.Cells() {
			if _fcfg.X().F != nil {
				_dcbb := _fcfg.X().F.Content
				if _fcfg.X().F.TAttr == _ba.ST_CellFormulaTypeArray {
					_daaba := _cgafd.Eval(_gdbf, _dcbb).AsString()
					if _daaba.Type == _cgd.ResultTypeError {
						_g.Log("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073", _dcbb, _daaba.ErrorMessage)
						_fcfg.X().V = nil
					}
					if _daaba.Type == _cgd.ResultTypeArray {
						_gdde, _gfgb := _dg.ParseCellReference(_fcfg.Reference())
						if _gfgb != nil {
							return map[string]bool{}, _gfgb
						}
						if (_dgef && len(_daaba.ValueArray) == 1) || (!_dgef && len(_daaba.ValueArray[0]) == 1) {
							continue
						}
						for _ceda, _dfdc := range _daaba.ValueArray {
							_cedg := _gdde.RowIdx + uint32(_ceda)
							for _eea := range _dfdc {
								_gdfc := _dg.IndexToColumn(_gdde.ColumnIdx + uint32(_eea))
								_aee[_ade.Sprintf("\u0025\u0073\u0025\u0064", _gdfc, _cedg)] = true
							}
						}
					} else if _daaba.Type == _cgd.ResultTypeList {
						_bfda, _cafg := _dg.ParseCellReference(_fcfg.Reference())
						if _cafg != nil {
							return map[string]bool{}, _cafg
						}
						if _dgef || len(_daaba.ValueList) == 1 {
							continue
						}
						_dfgg := _bfda.RowIdx
						for _ebb := range _daaba.ValueList {
							_ccda := _dg.IndexToColumn(_bfda.ColumnIdx + uint32(_ebb))
							_aee[_ade.Sprintf("\u0025\u0073\u0025\u0064", _ccda, _dfgg)] = true
						}
					}
				}
			}
		}
	}
	return _aee, nil
}

// SetHeight sets the height of the anchored object.
func (_dee AbsoluteAnchor) SetHeight(h _cf.Distance) { _dee._deb.Ext.CyAttr = int64(h / _cf.EMU) }

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_cace SheetView) SetState(st _ba.ST_PaneState) {
	_cace.ensurePane()
	_cace._adgd.Pane.StateAttr = st
}

type evalContext struct {
	_abgg       *Sheet
	_efe, _ecad uint32
	_egcb       map[string]struct{}
}

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_ffbg TwoCellAnchor) TopLeft() CellMarker { return CellMarker{_ffbg._afgbc.From} }

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct {
	_gcc *_ba.CT_Font
	_abc *_ba.StyleSheet
}

// IsNumber returns true if the cell is a number type cell.
func (_dbc Cell) IsNumber() bool {
	switch _dbc._eeg.TAttr {
	case _ba.ST_CellTypeN:
		return true
	case _ba.ST_CellTypeS, _ba.ST_CellTypeB:
		return false
	}
	return _dbc._eeg.V != nil && _gdd.IsNumber(*_dbc._eeg.V)
}

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_bba *Sheet) RemoveMergedCell(mc MergedCell) {
	for _aegee, _fadf := range _bba._edeb.MergeCells.MergeCell {
		if _fadf == mc.X() {
			copy(_bba._edeb.MergeCells.MergeCell[_aegee:], _bba._edeb.MergeCells.MergeCell[_aegee+1:])
			_bba._edeb.MergeCells.MergeCell[len(_bba._edeb.MergeCells.MergeCell)-1] = nil
			_bba._edeb.MergeCells.MergeCell = _bba._edeb.MergeCells.MergeCell[:len(_bba._edeb.MergeCells.MergeCell)-1]
		}
	}
}

// SetPasswordHash sets the password hash to the input.
func (_eeba SheetProtection) SetPasswordHash(pwHash string) {
	_eeba._baca.PasswordAttr = _g.String(pwHash)
}

// SetPassword sets the password hash to a hash of the input password.
func (_cbbce WorkbookProtection) SetPassword(pw string) { _cbbce.SetPasswordHash(PasswordHash(pw)) }
func (_eeec Row) renumberAs(_fabd uint32) {
	_eeec._agbf.RAttr = _g.Uint32(_fabd)
	for _, _deg := range _eeec.Cells() {
		_cffd, _gaeb := _dg.ParseCellReference(_deg.Reference())
		if _gaeb == nil {
			_gaad := _ade.Sprintf("\u0025\u0073\u0025\u0064", _cffd.Column, _fabd)
			_deg._eeg.RAttr = _g.String(_gaad)
		}
	}
}

// X returns the inner wrapped XML type.
func (_dga Border) X() *_ba.CT_Border { return _dga._cba }

// IsSheetLocked returns whether the sheet objects are locked.
func (_egdeb SheetProtection) IsObjectLocked() bool {
	return _egdeb._baca.ObjectsAttr != nil && *_egdeb._baca.ObjectsAttr
}

var _gefd = [...]uint8{0, 18, 37}

func (_decg *Workbook) addCustomRelationships() {
	_decg.ContentTypes.AddOverride("/\u0064o\u0063\u0050\u0072\u006f\u0070\u0073\u002f\u0063u\u0073\u0074\u006f\u006d.x\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069\u0063a\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065n\u0078\u006d\u006c\u0066\u006fr\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0063\u0075\u0073\u0074\u006f\u006d\u002d\u0070r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073+\u0078\u006d\u006c")
	_decg.Rels.AddRelationship("\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c", _g.CustomPropertiesType)
}

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_cfbg *Workbook) SetActiveSheet(s Sheet) {
	for _cddb, _efaf := range _cfbg._fgc {
		if s._edeb == _efaf {
			_cfbg.SetActiveSheetIndex(uint32(_cddb))
		}
	}
}

// SetItalic causes the text to be displayed in italic.
func (_abba RichTextRun) SetItalic(b bool) {
	_abba.ensureRpr()
	_abba._fgfg.RPr.I = _ba.NewCT_BooleanProperty()
	_abba._fgfg.RPr.I.ValAttr = _g.Bool(b)
}

// LockSheet controls the locking of the sheet.
func (_gfed SheetProtection) LockSheet(b bool) {
	if !b {
		_gfed._baca.SheetAttr = nil
	} else {
		_gfed._baca.SheetAttr = _g.Bool(true)
	}
}

// ClearNumberFormat removes any number formatting from the style.
func (_bbg CellStyle) ClearNumberFormat() {
	_bbg._daa.NumFmtIdAttr = nil
	_bbg._daa.ApplyNumberFormatAttr = nil
}

// SetPassword sets the password hash to a hash of the input password.
func (_dcfa SheetProtection) SetPassword(pw string) { _dcfa.SetPasswordHash(PasswordHash(pw)) }

// Name returns the sheet name
func (_cffg Sheet) Name() string { return _cffg._ggeg.NameAttr }
func (_cd Border) SetBottom(style _ba.ST_BorderStyle, c _gb.Color) {
	if _cd._cba.Bottom == nil {
		_cd._cba.Bottom = _ba.NewCT_BorderPr()
	}
	_cd._cba.Bottom.Color = _ba.NewCT_Color()
	_cd._cba.Bottom.Color.RgbAttr = c.AsRGBAString()
	_cd._cba.Bottom.StyleAttr = style
}
func (_dce ConditionalFormattingRule) clear() {
	_dce._bcca.OperatorAttr = _ba.ST_ConditionalFormattingOperatorUnset
	_dce._bcca.ColorScale = nil
	_dce._bcca.IconSet = nil
	_dce._bcca.Formula = nil
}

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_gbbc *Workbook) AddImage(i _bfd.Image) (_bfd.ImageRef, error) {
	_bfbbg := _bfd.MakeImageRef(i, &_gbbc.DocBase, _gbbc._fcad)
	if i.Data == nil && i.Path == "" {
		return _bfbbg, _de.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _bfbbg, _de.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _bfbbg, _de.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	if i.Path != "" {
		_fgegb := _b.Add(i.Path)
		if _fgegb != nil {
			return _bfbbg, _fgegb
		}
	}
	_gbbc.Images = append(_gbbc.Images, _bfbbg)
	return _bfbbg, nil
}

// GetLocked returns true if the cell is locked.
func (_bgg *evalContext) GetLocked(cellRef string) bool { return _bgg._abgg.Cell(cellRef).getLocked() }

var ErrorNotFound = _de.New("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed")

// AddView adds a sheet view.
func (_fbb *Sheet) AddView() SheetView {
	if _fbb._edeb.SheetViews == nil {
		_fbb._edeb.SheetViews = _ba.NewCT_SheetViews()
	}
	_acf := _ba.NewCT_SheetView()
	_fbb._edeb.SheetViews.SheetView = append(_fbb._edeb.SheetViews.SheetView, _acf)
	return SheetView{_acf}
}

// X returns the inner wrapped XML type.
func (_dgaf *Workbook) X() *_ba.Workbook { return _dgaf._badbd }

// SetConditionValue sets the condition value to be used for style applicaton.
func (_dfgf ConditionalFormattingRule) SetConditionValue(v string) { _dfgf._bcca.Formula = []string{v} }

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_gffe *Workbook) AddDefinedName(name, ref string) DefinedName {
	if _gffe._badbd.DefinedNames == nil {
		_gffe._badbd.DefinedNames = _ba.NewCT_DefinedNames()
	}
	_bdba := _ba.NewCT_DefinedName()
	_bdba.Content = ref
	_bdba.NameAttr = name
	_gffe._badbd.DefinedNames.DefinedName = append(_gffe._badbd.DefinedNames.DefinedName, _bdba)
	return DefinedName{_bdba}
}
func _dgcf() *_ea.CT_AbsoluteAnchor { _agd := _ea.NewCT_AbsoluteAnchor(); return _agd }

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_beca *Sheet) SetAutoFilter(rangeRef string) {
	rangeRef = _d.Replace(rangeRef, "\u0024", "", -1)
	_beca._edeb.AutoFilter = _ba.NewCT_AutoFilter()
	_beca._edeb.AutoFilter.RefAttr = _g.String(rangeRef)
	_dfbg := "\u0027" + _beca.Name() + "\u0027\u0021"
	var _fbf DefinedName
	for _, _gbbf := range _beca._ebee.DefinedNames() {
		if _gbbf.Name() == _gdga {
			if _d.HasPrefix(_gbbf.Content(), _dfbg) {
				_fbf = _gbbf
				_fbf.SetContent(_beca.RangeReference(rangeRef))
				break
			}
		}
	}
	if _fbf.X() == nil {
		_fbf = _beca._ebee.AddDefinedName(_gdga, _beca.RangeReference(rangeRef))
	}
	for _bdee, _faegd := range _beca._ebee._fgc {
		if _faegd == _beca._edeb {
			_fbf.SetLocalSheetID(uint32(_bdee))
		}
	}
}

// Type returns the type of anchor
func (_dbe OneCellAnchor) Type() AnchorType { return AnchorTypeOneCell }

// SetWidth is a no-op.
func (_faegb TwoCellAnchor) SetWidth(w _cf.Distance) {}

// X returns the inner wrapped XML type.
func (_bcg Column) X() *_ba.CT_Col { return _bcg._eaac }

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_dfgb *Workbook) Save(w _c.Writer) error {
	if !_bf.GetLicenseKey().IsLicensed() && !_ebcd {
		_ade.Println("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065")
		_ade.Println("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return _de.New("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064")
	}
	_effge := _cb.NewWriter(w)
	defer _effge.Close()
	_defbc := _g.DocTypeSpreadsheet
	if _dgca := _e.MarshalXML(_effge, _g.BaseRelsFilename, _dfgb.Rels.X()); _dgca != nil {
		return _dgca
	}
	if _dfed := _e.MarshalXMLByType(_effge, _defbc, _g.ExtendedPropertiesType, _dfgb.AppProperties.X()); _dfed != nil {
		return _dfed
	}
	if _affb := _e.MarshalXMLByType(_effge, _defbc, _g.CorePropertiesType, _dfgb.CoreProperties.X()); _affb != nil {
		return _affb
	}
	_eeee := _g.AbsoluteFilename(_defbc, _g.OfficeDocumentType, 0)
	if _abdg := _e.MarshalXML(_effge, _eeee, _dfgb._badbd); _abdg != nil {
		return _abdg
	}
	if _ffaag := _e.MarshalXML(_effge, _e.RelationsPathFor(_eeee), _dfgb._fcad.X()); _ffaag != nil {
		return _ffaag
	}
	if _fbcgd := _e.MarshalXMLByType(_effge, _defbc, _g.StylesType, _dfgb.StyleSheet.X()); _fbcgd != nil {
		return _fbcgd
	}
	for _dbeg, _affg := range _dfgb._bbf {
		if _cffgd := _e.MarshalXMLByTypeIndex(_effge, _defbc, _g.ThemeType, _dbeg+1, _affg); _cffgd != nil {
			return _cffgd
		}
	}
	for _gbgaf, _gdbdc := range _dfgb._fgc {
		_gdbdc.Dimension.RefAttr = Sheet{_dfgb, nil, _gdbdc}.Extents()
		_abe := _g.AbsoluteFilename(_defbc, _g.WorksheetType, _gbgaf+1)
		_e.MarshalXML(_effge, _abe, _gdbdc)
		_e.MarshalXML(_effge, _e.RelationsPathFor(_abe), _dfgb._gcga[_gbgaf].X())
	}
	if _dgdd := _e.MarshalXMLByType(_effge, _defbc, _g.SharedStringsType, _dfgb.SharedStrings.X()); _dgdd != nil {
		return _dgdd
	}
	if _dfgb.CustomProperties.X() != nil {
		if _eaee := _e.MarshalXMLByType(_effge, _defbc, _g.CustomPropertiesType, _dfgb.CustomProperties.X()); _eaee != nil {
			return _eaee
		}
	}
	if _dfgb.Thumbnail != nil {
		_cbfe := _g.AbsoluteFilename(_defbc, _g.ThumbnailType, 0)
		_cegd, _gagag := _effge.Create(_cbfe)
		if _gagag != nil {
			return _gagag
		}
		if _aabg := _ad.Encode(_cegd, _dfgb.Thumbnail, nil); _aabg != nil {
			return _aabg
		}
	}
	for _bced, _cdcc := range _dfgb._bgfa {
		_eabba := _g.AbsoluteFilename(_defbc, _g.ChartType, _bced+1)
		_e.MarshalXML(_effge, _eabba, _cdcc)
	}
	for _ebf, _eag := range _dfgb._eedb {
		_bebe := _g.AbsoluteFilename(_defbc, _g.TableType, _ebf+1)
		_e.MarshalXML(_effge, _bebe, _eag)
	}
	for _bbaa, _dcff := range _dfgb._cbgc {
		_gadcg := _g.AbsoluteFilename(_defbc, _g.DrawingType, _bbaa+1)
		_e.MarshalXML(_effge, _gadcg, _dcff)
		if !_dfgb._dbagc[_bbaa].IsEmpty() {
			_e.MarshalXML(_effge, _e.RelationsPathFor(_gadcg), _dfgb._dbagc[_bbaa].X())
		}
	}
	for _debd, _cbcb := range _dfgb._effd {
		_e.MarshalXML(_effge, _g.AbsoluteFilename(_defbc, _g.VMLDrawingType, _debd+1), _cbcb)
	}
	for _ecd, _cebg := range _dfgb.Images {
		if _efec := _bfd.AddImageToZip(_effge, _cebg, _ecd+1, _g.DocTypeSpreadsheet); _efec != nil {
			return _efec
		}
	}
	if _gdbe := _e.MarshalXML(_effge, _g.ContentTypesFilename, _dfgb.ContentTypes.X()); _gdbe != nil {
		return _gdbe
	}
	for _bfac, _afcb := range _dfgb._eabg {
		if _afcb == nil {
			continue
		}
		_e.MarshalXML(_effge, _g.AbsoluteFilename(_defbc, _g.CommentsType, _bfac+1), _afcb)
	}
	if _efcg := _dfgb.WriteExtraFiles(_effge); _efcg != nil {
		return _efcg
	}
	return _effge.Close()
}

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte

const (
	AnchorTypeAbsolute AnchorType = iota
	AnchorTypeOneCell
	AnchorTypeTwoCell
)

func (_agbb Font) SetBold(b bool) {
	if b {
		_agbb._gcc.B = []*_ba.CT_BooleanProperty{{}}
	} else {
		_agbb._gcc.B = nil
	}
}

// TopLeft returns the top-left corner of the anchored object.
func (_efcd OneCellAnchor) TopLeft() CellMarker { return CellMarker{_efcd._agc.From} }

// Index returns the index of the differential style.
func (_fcgf DifferentialStyle) Index() uint32 {
	for _ccad, _eef := range _fcgf._fba.Dxf {
		if _fcgf._geff == _eef {
			return uint32(_ccad)
		}
	}
	return 0
}

// X returns the inner wrapped XML type.
func (_fgbf DefinedName) X() *_ba.CT_DefinedName { return _fgbf._dcd }
func (_fgbd Font) SetName(name string)           { _fgbd._gcc.Name = []*_ba.CT_FontName{{ValAttr: name}} }

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_gge Cell) SetTime(d _ag.Time) {
	_gge.clearValue()
	d = _ca(d)
	_fad := _gge._agg.Epoch()
	if d.Before(_fad) {
		_g.Log("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064")
		return
	}
	_adfa := d.Sub(_fad)
	_be := new(_gg.Float)
	_bb := new(_gg.Float)
	_bb.SetPrec(128)
	_bb.SetUint64(uint64(_adfa))
	_gdg := new(_gg.Float)
	_gdg.SetUint64(24 * 60 * 60 * 1e9)
	_be.Quo(_bb, _gdg)
	_gge._eeg.V = _g.String(_be.Text('g', 20))
}
func (_fefd PatternFill) ClearBgColor() { _fefd._fefe.BgColor = nil }

const (
	_eedef = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034"
	_faag  = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065"
	_gbga  = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030"
	_dddb  = "\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039"
)

// SetFormat sets the number format code.
func (_dfa NumberFormat) SetFormat(f string) { _dfa._cgg.FormatCodeAttr = f }

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{ _afgbc *_ea.CT_TwoCellAnchor }

// Name returns the name of the defined name.
func (_eae DefinedName) Name() string { return _eae._dcd.NameAttr }

// SetNumber sets the cell type to number, and the value to the given number
func (_ddc Cell) SetNumber(v float64) {
	_ddc.clearValue()
	if _ce.IsNaN(v) || _ce.IsInf(v, 0) {
		_ddc._eeg.TAttr = _ba.ST_CellTypeE
		_ddc._eeg.V = _g.String("\u0023\u004e\u0055M\u0021")
		return
	}
	_ddc._eeg.TAttr = _ba.ST_CellTypeN
	_ddc._eeg.V = _g.String(_cg.FormatFloat(v, 'f', -1, 64))
}

// Operator returns the operator for the rule
func (_egdf ConditionalFormattingRule) Operator() _ba.ST_ConditionalFormattingOperator {
	return _egdf._bcca.OperatorAttr
}

// DefinedName is a named range, formula, etc.
type DefinedName struct{ _dcd *_ba.CT_DefinedName }

func (_cgbd DataValidationCompare) SetValue2(v string) { _cgbd._bgdf.Formula2 = &v }

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{ _eaac *_ba.CT_Col }

// New constructs a new workbook.
func New() *Workbook {
	_defd := &Workbook{}
	_defd._badbd = _ba.NewWorkbook()
	_defd.AppProperties = _bfd.NewAppProperties()
	_defd.CoreProperties = _bfd.NewCoreProperties()
	_defd.StyleSheet = NewStyleSheet(_defd)
	_defd.Rels = _bfd.NewRelationships()
	_defd._fcad = _bfd.NewRelationships()
	_defd.Rels.AddRelationship(_g.RelativeFilename(_g.DocTypeSpreadsheet, "", _g.ExtendedPropertiesType, 0), _g.ExtendedPropertiesType)
	_defd.Rels.AddRelationship(_g.RelativeFilename(_g.DocTypeSpreadsheet, "", _g.CorePropertiesType, 0), _g.CorePropertiesType)
	_defd.Rels.AddRelationship(_g.RelativeFilename(_g.DocTypeSpreadsheet, "", _g.OfficeDocumentType, 0), _g.OfficeDocumentType)
	_defd._fcad.AddRelationship(_g.RelativeFilename(_g.DocTypeSpreadsheet, _g.OfficeDocumentType, _g.StylesType, 0), _g.StylesType)
	_defd.ContentTypes = _bfd.NewContentTypes()
	_defd.ContentTypes.AddDefault("\u0076\u006d\u006c", _g.VMLDrawingContentType)
	_defd.ContentTypes.AddOverride(_g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.OfficeDocumentType, 0), "\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c")
	_defd.ContentTypes.AddOverride(_g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.StylesType, 0), _g.SMLStyleSheetContentType)
	_defd.SharedStrings = NewSharedStrings()
	_defd.ContentTypes.AddOverride(_g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.SharedStringsType, 0), _g.SharedStringsContentType)
	_defd._fcad.AddRelationship(_g.RelativeFilename(_g.DocTypeSpreadsheet, _g.OfficeDocumentType, _g.SharedStringsType, 0), _g.SharedStringsType)
	return _defd
}

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_agag *Sheet) AddHyperlink(url string) _bfd.Hyperlink {
	for _bgcb, _cabg := range _agag._ebee._fgc {
		if _cabg == _agag._edeb {
			return _agag._ebee._gcga[_bgcb].AddHyperlink(url)
		}
	}
	return _bfd.Hyperlink{}
}
func _cbbcd(_bgb string) bool {
	_bgb = _d.Replace(_bgb, "\u0024", "", -1)
	if _fcfa := _afge.FindStringSubmatch(_d.ToLower(_bgb)); len(_fcfa) > 2 {
		_eed := _fcfa[1]
		_bggb, _fea := _cg.Atoi(_fcfa[2])
		if _fea != nil {
			return false
		}
		return _bggb <= 1048576 && _eed <= "\u007a\u007a"
	}
	return false
}

// SetLocked sets cell locked or not.
func (_adde *evalContext) SetLocked(cellRef string, locked bool) {
	_adde._abgg.Cell(cellRef).setLocked(locked)
}
func (_cbbd Font) SetSize(size float64) { _cbbd._gcc.Sz = []*_ba.CT_FontSize{{ValAttr: size}} }

// SetWrapped configures the cell to wrap text.
func (_bdg CellStyle) SetWrapped(b bool) {
	if _bdg._daa.Alignment == nil {
		_bdg._daa.Alignment = _ba.NewCT_CellAlignment()
	}
	if !b {
		_bdg._daa.Alignment.WrapTextAttr = nil
	} else {
		_bdg._daa.Alignment.WrapTextAttr = _g.Bool(true)
		_bdg._daa.ApplyAlignmentAttr = _g.Bool(true)
	}
}
func (_efed *Sheet) setList(_ggecc string, _dbfea _cgd.Result) error {
	_gfgf, _agbfb := _dg.ParseCellReference(_ggecc)
	if _agbfb != nil {
		return _agbfb
	}
	_cffdc := _efed.Row(_gfgf.RowIdx)
	for _bceb, _gfef := range _dbfea.ValueList {
		_acec := _cffdc.Cell(_dg.IndexToColumn(_gfgf.ColumnIdx + uint32(_bceb)))
		if _gfef.Type != _cgd.ResultTypeEmpty {
			if _gfef.IsBoolean {
				_acec.SetBool(_gfef.ValueNumber != 0)
			} else {
				_acec.SetCachedFormulaResult(_gfef.String())
			}
		}
	}
	return nil
}

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface {

	// BottomRight returns the CellMaker for the bottom right corner of the
	// anchor.
	BottomRight() CellMarker

	// TopLeft returns the CellMaker for the top left corner of the anchor.
	TopLeft() CellMarker

	// MoveTo repositions the anchor without changing the objects size.
	MoveTo(_cbe, _cbf int32)

	// SetWidth sets the width of the anchored object. It is not compatible with
	// SetWidthCells.
	SetWidth(_bcc _cf.Distance)

	// SetWidthCells sets the height the anchored object by moving the right
	// hand side. It is not compatible with SetWidth.
	SetWidthCells(_gea int32)

	// SetHeight sets the height of the anchored object. It is not compatible
	// with SetHeightCells.
	SetHeight(_aff _cf.Distance)

	// SetHeightCells sets the height the anchored object by moving the bottom.
	// It is not compatible with SetHeight.
	SetHeightCells(_db int32)

	// SetColOffset sets the column offset of the top-left anchor.
	SetColOffset(_afb _cf.Distance)

	// SetRowOffset sets the row offset of the top-left anchor.
	SetRowOffset(_gdb _cf.Distance)

	// Type returns the type of anchor
	Type() AnchorType
}

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_egbe *Workbook) ClearCachedFormulaResults() {
	for _, _ggac := range _egbe.Sheets() {
		_ggac.ClearCachedFormulaResults()
	}
}

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte

// AddFormatValue adds a format value (databars require two).
func (_afga DataBarScale) AddFormatValue(t _ba.ST_CfvoType, val string) {
	_fade := _ba.NewCT_Cfvo()
	_fade.TypeAttr = t
	_fade.ValAttr = _g.String(val)
	_afga._abb.Cfvo = append(_afga._abb.Cfvo, _fade)
}

// X returns the inner wrapped XML type.
func (_fgf ColorScale) X() *_ba.CT_ColorScale { return _fgf._dgec }

// ClearAutoFilter removes the autofilters from the sheet.
func (_gga *Sheet) ClearAutoFilter() {
	_gga._edeb.AutoFilter = nil
	_bcbe := "\u0027" + _gga.Name() + "\u0027\u0021"
	for _, _cdce := range _gga._ebee.DefinedNames() {
		if _cdce.Name() == _gdga {
			if _d.HasPrefix(_cdce.Content(), _bcbe) {
				_gga._ebee.RemoveDefinedName(_cdce)
				break
			}
		}
	}
}

// SetHeightCells is a no-op.
func (_bed OneCellAnchor) SetHeightCells(int32) {}

// SetWidthCells is a no-op.
func (_gccc OneCellAnchor) SetWidthCells(int32) {}

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_decd TwoCellAnchor) SetHeightCells(h int32) {
	_decd.SetHeight(0)
	_fggd := _decd.TopLeft()
	_ebbe := _decd.BottomRight()
	_ebbe.SetRow(_fggd.Row() + h)
}

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gcda *Workbook) RecalculateFormulas() {
	for _, _bfcbe := range _gcda.Sheets() {
		_bfcbe.RecalculateFormulas()
	}
}
func (_gcgd CellStyle) Index() uint32 {
	for _cag, _cbc := range _gcgd._ebe.Xf {
		if _gcgd._daa == _cbc {
			return uint32(_cag)
		}
	}
	return 0
}

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_eggc ConditionalFormattingRule) SetDataBar() DataBarScale {
	_eggc.clear()
	_eggc.SetType(_ba.ST_CfTypeDataBar)
	_eggc._bcca.DataBar = _ba.NewCT_DataBar()
	_cbad := DataBarScale{_eggc._bcca.DataBar}
	_cbad.SetShowValue(true)
	_cbad.SetMinLength(10)
	_cbad.SetMaxLength(90)
	return _cbad
}

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_ed Cell) SetFormulaShared(formula string, rows, cols uint32) error {
	_ed.clearValue()
	_ed._eeg.TAttr = _ba.ST_CellTypeStr
	_ed._eeg.F = _ba.NewCT_CellFormula()
	_ed._eeg.F.TAttr = _ba.ST_CellFormulaTypeShared
	_ed._eeg.F.Content = formula
	_cdc, _gac := _dg.ParseCellReference(_ed.Reference())
	if _gac != nil {
		return _gac
	}
	_bd := uint32(0)
	for _, _gef := range _ed._afe.Rows() {
		for _, _bdd := range _gef._agbf.C {
			if _bdd.F != nil && _bdd.F.SiAttr != nil && *_bdd.F.SiAttr >= _bd {
				_bd = *_bdd.F.SiAttr
			}
		}
	}
	_bd++
	_aded := _ade.Sprintf("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d", _cdc.Column, _cdc.RowIdx, _dg.IndexToColumn(_cdc.ColumnIdx+cols), _cdc.RowIdx+rows)
	_ed._eeg.F.RefAttr = _g.String(_aded)
	_ed._eeg.F.SiAttr = _g.Uint32(_bd)
	_bfc := Sheet{_ed._agg, _ed._afe._ggeg, _ed._afe._edeb}
	for _dcb := _cdc.RowIdx; _dcb <= _cdc.RowIdx+rows; _dcb++ {
		for _bfae := _cdc.ColumnIdx; _bfae <= _cdc.ColumnIdx+cols; _bfae++ {
			if _dcb == _cdc.RowIdx && _bfae == _cdc.ColumnIdx {
				continue
			}
			_adgg := _ade.Sprintf("\u0025\u0073\u0025\u0064", _dg.IndexToColumn(_bfae), _dcb)
			_bfc.Cell(_adgg).Clear()
			_bfc.Cell(_adgg).X().F = _ba.NewCT_CellFormula()
			_bfc.Cell(_adgg).X().F.TAttr = _ba.ST_CellFormulaTypeShared
			_bfc.Cell(_adgg).X().F.SiAttr = _g.Uint32(_bd)
		}
	}
	return nil
}
func (_eda *Sheet) removeColumnFromNamedRanges(_cbfc uint32) error {
	for _, _bdebe := range _eda._ebee.DefinedNames() {
		_eabb := _bdebe.Name()
		_fcd := _bdebe.Content()
		_fgag := _d.Split(_fcd, "\u0021")
		if len(_fgag) != 2 {
			return _de.New("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a" + _fcd)
		}
		_fcac := _fgag[0]
		if _eda.Name() == _fcac {
			_gcgdc := _eda._ebee.RemoveDefinedName(_bdebe)
			if _gcgdc != nil {
				return _gcgdc
			}
			_dacf := _feae(_fgag[1], _cbfc, true)
			if _dacf != "" {
				_abge := _fcac + "\u0021" + _dacf
				_eda._ebee.AddDefinedName(_eabb, _abge)
			}
		}
	}
	_agdc := 0
	if _eda._edeb.TableParts != nil && _eda._edeb.TableParts.TablePart != nil {
		_agdc = len(_eda._edeb.TableParts.TablePart)
	}
	if _agdc != 0 {
		_fabaa := 0
		for _, _gbee := range _eda._ebee.Sheets() {
			if _gbee.Name() == _eda.Name() {
				break
			} else {
				if _gbee._edeb.TableParts != nil && _gbee._edeb.TableParts.TablePart != nil {
					_fabaa += len(_gbee._edeb.TableParts.TablePart)
				}
			}
		}
		_ffad := _eda._ebee._eedb[_fabaa : _fabaa+_agdc]
		for _cef, _gbbg := range _ffad {
			_caea := _gbbg
			_caea.RefAttr = _feae(_caea.RefAttr, _cbfc, false)
			_eda._ebee._eedb[_fabaa+_cef] = _caea
		}
	}
	return nil
}
func (_febab *Workbook) ensureSharedStringsRelationships() {
	_ffdd := false
	for _, _cfce := range _febab.ContentTypes.X().Override {
		if _cfce.ContentTypeAttr == _g.SharedStringsContentType {
			_ffdd = true
			break
		}
	}
	if !_ffdd {
		_febab.ContentTypes.AddOverride(_dgfad, _g.SharedStringsContentType)
	}
	_aead := false
	for _, _fcfaa := range _febab._fcad.Relationships() {
		if _fcfaa.X().TargetAttr == _bccb {
			_aead = true
			break
		}
	}
	if !_aead {
		_febab._fcad.AddRelationship(_bccb, _g.SharedStringsType)
	}
}

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_gegg ConditionalFormattingRule) SetColorScale() ColorScale {
	_gegg.clear()
	_gegg.SetType(_ba.ST_CfTypeColorScale)
	_gegg._bcca.ColorScale = _ba.NewCT_ColorScale()
	return ColorScale{_gegg._bcca.ColorScale}
}

// SetReference sets the regin of cells that the merged cell applies to.
func (_dbba MergedCell) SetReference(ref string) { _dbba._ddgc.RefAttr = ref }

// X returns the inner wrapped XML type.
func (_caaf ConditionalFormatting) X() *_ba.CT_ConditionalFormatting { return _caaf._fde }

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_eabf StyleSheet) AddDifferentialStyle() DifferentialStyle {
	if _eabf._gfde.Dxfs == nil {
		_eabf._gfde.Dxfs = _ba.NewCT_Dxfs()
	}
	_gbcc := _ba.NewCT_Dxf()
	_eabf._gfde.Dxfs.Dxf = append(_eabf._gfde.Dxfs.Dxf, _gbcc)
	_eabf._gfde.Dxfs.CountAttr = _g.Uint32(uint32(len(_eabf._gfde.Dxfs.Dxf)))
	return DifferentialStyle{_gbcc, _eabf._aced, _eabf._gfde.Dxfs}
}

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_dfg Cell) SetDate(d _ag.Time) {
	_dfg.clearValue()
	d = _ca(d)
	_dge := _dfg._agg.Epoch()
	if d.Before(_dge) {
		_g.Log("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064")
		return
	}
	_edg := d.Sub(_dge)
	_aae := new(_gg.Float)
	_cc := new(_gg.Float)
	_cc.SetPrec(128)
	_cc.SetUint64(uint64(_edg))
	_afg := new(_gg.Float)
	_afg.SetUint64(24 * 60 * 60 * 1e9)
	_aae.Quo(_cc, _afg)
	_bef, _ := _aae.Uint64()
	_dfg._eeg.V = _g.Stringf("\u0025\u0064", _bef)
}

// SetDateWithStyle sets a date with the default date style applied.
func (_adfg Cell) SetDateWithStyle(d _ag.Time) {
	_adfg.SetDate(d)
	for _, _gfa := range _adfg._agg.StyleSheet.CellStyles() {
		if _gfa.HasNumberFormat() && _gfa.NumberFormat() == uint32(StandardFormatDate) {
			_adfg.SetStyle(_gfa)
			return
		}
	}
	_edd := _adfg._agg.StyleSheet.AddCellStyle()
	_edd.SetNumberFormatStandard(StandardFormatDate)
	_adfg.SetStyle(_edd)
}

const (
	DVCompareTypeWholeNumber = DVCompareType(_ba.ST_DataValidationTypeWhole)
	DVCompareTypeDecimal     = DVCompareType(_ba.ST_DataValidationTypeDecimal)
	DVCompareTypeDate        = DVCompareType(_ba.ST_DataValidationTypeDate)
	DVCompareTypeTime        = DVCompareType(_ba.ST_DataValidationTypeTime)
	DVompareTypeTextLength   = DVCompareType(_ba.ST_DataValidationTypeTextLength)
)

// SetOperator sets the operator for the rule.
func (_cbfg ConditionalFormattingRule) SetOperator(t _ba.ST_ConditionalFormattingOperator) {
	_cbfg._bcca.OperatorAttr = t
}

// Author returns the author of the comment
func (_bbc Comment) Author() string {
	if _bbc._fdd.AuthorIdAttr < uint32(len(_bbc._aaf.Authors.Author)) {
		return _bbc._aaf.Authors.Author[_bbc._fdd.AuthorIdAttr]
	}
	return ""
}

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_cfgc Cell) SetStyle(cs CellStyle) { _cfgc.SetStyleIndex(cs.Index()) }

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{ _agc *_ea.CT_OneCellAnchor }

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_eaa Cell) SetFormulaArray(s string) {
	_eaa.clearValue()
	_eaa._eeg.TAttr = _ba.ST_CellTypeStr
	_eaa._eeg.F = _ba.NewCT_CellFormula()
	_eaa._eeg.F.TAttr = _ba.ST_CellFormulaTypeArray
	_eaa._eeg.F.Content = s
}
func (_dffc SortOrder) String() string {
	if _dffc >= SortOrder(len(_gefd)-1) {
		return _ade.Sprintf("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029", _dffc)
	}
	return _dcbg[_gefd[_dffc]:_gefd[_dffc+1]]
}
func (_bfa Border) SetDiagonal(style _ba.ST_BorderStyle, c _gb.Color, up, down bool) {
	if _bfa._cba.Diagonal == nil {
		_bfa._cba.Diagonal = _ba.NewCT_BorderPr()
	}
	_bfa._cba.Diagonal.Color = _ba.NewCT_Color()
	_bfa._cba.Diagonal.Color.RgbAttr = c.AsRGBAString()
	_bfa._cba.Diagonal.StyleAttr = style
	if up {
		_bfa._cba.DiagonalUpAttr = _g.Bool(true)
	}
	if down {
		_bfa._cba.DiagonalDownAttr = _g.Bool(true)
	}
}

// AddCell adds a cell to a spreadsheet.
func (_bfdea Row) AddCell() Cell {
	_bdafc := uint32(len(_bfdea._agbf.C))
	var _febf *string
	if _bdafc > 0 {
		_bfeb := _g.Stringf("\u0025\u0073\u0025\u0064", _dg.IndexToColumn(_bdafc-1), _bfdea.RowNumber())
		if _bfdea._agbf.C[_bdafc-1].RAttr != nil && *_bfdea._agbf.C[_bdafc-1].RAttr == *_bfeb {
			_febf = _g.Stringf("\u0025\u0073\u0025\u0064", _dg.IndexToColumn(_bdafc), _bfdea.RowNumber())
		}
	}
	_ecb := _ba.NewCT_Cell()
	_bfdea._agbf.C = append(_bfdea._agbf.C, _ecb)
	if _febf == nil {
		_dggf := uint32(0)
		for _, _ccaf := range _bfdea._agbf.C {
			if _ccaf.RAttr != nil {
				_agdf, _ := _dg.ParseCellReference(*_ccaf.RAttr)
				if _agdf.ColumnIdx >= _dggf {
					_dggf = _agdf.ColumnIdx + 1
				}
			}
		}
		_febf = _g.Stringf("\u0025\u0073\u0025\u0064", _dg.IndexToColumn(_dggf), _bfdea.RowNumber())
	}
	_ecb.RAttr = _febf
	return Cell{_bfdea._bdaf, _bfdea._edfa, _bfdea._agbf, _ecb}
}

// Open opens and reads a workbook from a file (.xlsx).
func Open(filename string) (*Workbook, error) {
	_gfd, _fgdg := _af.Open(filename)
	if _fgdg != nil {
		return nil, _ade.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _fgdg)
	}
	defer _gfd.Close()
	_cfgf, _fgdg := _af.Stat(filename)
	if _fgdg != nil {
		return nil, _ade.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _fgdg)
	}
	_gadda, _fgdg := Read(_gfd, _cfgf.Size())
	if _fgdg != nil {
		return nil, _fgdg
	}
	_gdca, _ := _fb.Abs(_fb.Dir(filename))
	_gadda._gff = _fb.Join(_gdca, filename)
	return _gadda, nil
}

// X returns the inner wrapped XML type.
func (_afaf RichText) X() *_ba.CT_Rst { return _afaf._aef }

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_dfee *Sheet) SetDrawing(d Drawing) {
	var _dfdd _bfd.Relationships
	for _eggd, _ccgg := range _dfee._ebee._fgc {
		if _ccgg == _dfee._edeb {
			_dfdd = _dfee._ebee._gcga[_eggd]
			break
		}
	}
	var _ffab string
	for _dfb, _bebg := range d._dea._cbgc {
		if _bebg == d._bacd {
			_dfbb := _dfdd.AddAutoRelationship(_g.DocTypeSpreadsheet, _g.WorksheetType, _dfb+1, _g.DrawingType)
			_ffab = _dfbb.ID()
			break
		}
	}
	_dfee._edeb.Drawing = _ba.NewCT_Drawing()
	_dfee._edeb.Drawing.IdAttr = _ffab
}

// Reference returns the table reference (the cells within the table)
func (_gebb Table) Reference() string { return _gebb._eega.RefAttr }
func (_cdea *Sheet) addNumberedRowFast(_dbfee uint32) Row {
	_cfec := _ba.NewCT_Row()
	_cfec.RAttr = _g.Uint32(_dbfee)
	_cdea._edeb.SheetData.Row = append(_cdea._edeb.SheetData.Row, _cfec)
	return Row{_cdea._ebee, _cdea, _cfec}
}

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_cgdb Cell) SetFormulaRaw(s string) {
	_cgdb.clearValue()
	_cgdb._eeg.TAttr = _ba.ST_CellTypeStr
	_cgdb._eeg.F = _ba.NewCT_CellFormula()
	_cgdb._eeg.F.Content = s
}

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_egf Comment) SetCellReference(cellRef string) { _egf._fdd.RefAttr = cellRef }
func (_baac *evalContext) Cell(ref string, ev _cgd.Evaluator) _cgd.Result {
	if !_cbbcd(ref) {
		return _cgd.MakeErrorResultType(_cgd.ErrorTypeName, "")
	}
	_dfgc := _baac._abgg.Name() + "\u0021" + ref
	if _eeb, _aebb := ev.GetFromCache(_dfgc); _aebb {
		return _eeb
	}
	_ccbe, _cffbf := _dg.ParseCellReference(ref)
	if _cffbf != nil {
		return _cgd.MakeErrorResult(_ade.Sprintf("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", ref, _cffbf))
	}
	if _baac._efe != 0 && !_ccbe.AbsoluteColumn {
		_ccbe.ColumnIdx += _baac._efe
		_ccbe.Column = _dg.IndexToColumn(_ccbe.ColumnIdx)
	}
	if _baac._ecad != 0 && !_ccbe.AbsoluteRow {
		_ccbe.RowIdx += _baac._ecad
	}
	_eee := _baac._abgg.Cell(_ccbe.String())
	if _eee.HasFormula() {
		if _, _fbe := _baac._egcb[ref]; _fbe {
			return _cgd.MakeErrorResult("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020" + ref)
		}
		_baac._egcb[ref] = struct{}{}
		_acdba := ev.Eval(_baac, _eee.GetFormula())
		delete(_baac._egcb, ref)
		ev.SetCache(_dfgc, _acdba)
		return _acdba
	}
	if _eee.IsEmpty() {
		_bfg := _cgd.MakeEmptyResult()
		ev.SetCache(_dfgc, _bfg)
		return _bfg
	} else if _eee.IsNumber() {
		_ffed, _ := _eee.GetValueAsNumber()
		_bfaf := _cgd.MakeNumberResult(_ffed)
		ev.SetCache(_dfgc, _bfaf)
		return _bfaf
	} else if _eee.IsBool() {
		_cfc, _ := _eee.GetValueAsBool()
		_dcf := _cgd.MakeBoolResult(_cfc)
		ev.SetCache(_dfgc, _dcf)
		return _dcf
	}
	_ddcg, _ := _eee.GetRawValue()
	if _eee.IsError() {
		_bccf := _cgd.MakeErrorResult("")
		_bccf.ValueString = _ddcg
		ev.SetCache(_dfgc, _bccf)
		return _bccf
	}
	_fdef := _cgd.MakeStringResult(_ddcg)
	ev.SetCache(_dfgc, _fdef)
	return _fdef
}

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_gca *Sheet) RemoveColumn(column string) error {
	_caeb, _cdga := _gca.getAllCellsInFormulaArraysForColumn()
	if _cdga != nil {
		return _cdga
	}
	_daeg := _dg.ColumnToIndex(column)
	for _, _cfd := range _gca.Rows() {
		_gcfc := _ade.Sprintf("\u0025\u0073\u0025\u0064", column, *_cfd.X().RAttr)
		if _, _bbce := _caeb[_gcfc]; _bbce {
			return nil
		}
	}
	for _, _cfff := range _gca.Rows() {
		_fggc := _cfff._agbf.C
		for _eddd, _bagg := range _fggc {
			_bccg, _geb := _dg.ParseCellReference(*_bagg.RAttr)
			if _geb != nil {
				return _geb
			}
			if _bccg.ColumnIdx == _daeg {
				_cfff._agbf.C = append(_fggc[:_eddd], _gca.slideCellsLeft(_fggc[_eddd+1:])...)
				break
			} else if _bccg.ColumnIdx > _daeg {
				_cfff._agbf.C = append(_fggc[:_eddd], _gca.slideCellsLeft(_fggc[_eddd:])...)
				break
			}
		}
	}
	_cdga = _gca.updateAfterRemove(_daeg, _cfa.UpdateActionRemoveColumn)
	if _cdga != nil {
		return _cdga
	}
	_cdga = _gca.removeColumnFromNamedRanges(_daeg)
	if _cdga != nil {
		return _cdga
	}
	_cdga = _gca.removeColumnFromMergedCells(_daeg)
	if _cdga != nil {
		return _cdga
	}
	for _, _afgd := range _gca._ebee.Sheets() {
		_afgd.RecalculateFormulas()
	}
	return nil
}

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_gede StyleSheet) AddCellStyle() CellStyle {
	_bafbg := _ba.NewCT_Xf()
	_gede._gfde.CellXfs.Xf = append(_gede._gfde.CellXfs.Xf, _bafbg)
	_gede._gfde.CellXfs.CountAttr = _g.Uint32(uint32(len(_gede._gfde.CellXfs.Xf)))
	return CellStyle{_gede._aced, _bafbg, _gede._gfde.CellXfs}
}

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_ecaa *Workbook) GetSheet(name string) (Sheet, error) {
	for _, _cbde := range _ecaa.Sheets() {
		if _cbde.Name() == name {
			return _cbde, nil
		}
	}
	return Sheet{}, ErrorNotFound
}

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_daac *Sheet) AddConditionalFormatting(cellRanges []string) ConditionalFormatting {
	_aebbd := _ba.NewCT_ConditionalFormatting()
	_daac._edeb.ConditionalFormatting = append(_daac._edeb.ConditionalFormatting, _aebbd)
	_gba := make(_ba.ST_Sqref, 0, 0)
	_aebbd.SqrefAttr = &_gba
	for _, _eabe := range cellRanges {
		*_aebbd.SqrefAttr = append(*_aebbd.SqrefAttr, _eabe)
	}
	return ConditionalFormatting{_aebbd}
}

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_aedf *Workbook) RemoveSheetByName(name string) error {
	_afgf := -1
	for _cdfgf, _cegc := range _aedf.Sheets() {
		if name == _cegc.Name() {
			_afgf = _cdfgf
			break
		}
	}
	if _afgf == -1 {
		return ErrorNotFound
	}
	return _aedf.RemoveSheet(_afgf)
}

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_baad Sheet) Validate() error {
	_bfbb := []func() error{_baad.validateRowCellNumbers, _baad.validateMergedCells, _baad.validateSheetNames}
	for _, _fdbaae := range _bfbb {
		if _edec := _fdbaae(); _edec != nil {
			return _edec
		}
	}
	if _edecf := _baad._edeb.Validate(); _edecf != nil {
		return _edecf
	}
	return _baad._edeb.Validate()
}

// SetHyperlink sets a hyperlink on a cell.
func (_gadc Cell) SetHyperlink(hl _bfd.Hyperlink) {
	_ec := _gadc._afe._edeb
	if _ec.Hyperlinks == nil {
		_ec.Hyperlinks = _ba.NewCT_Hyperlinks()
	}
	_dac := _bfd.Relationship(hl)
	_bab := _ba.NewCT_Hyperlink()
	_bab.RefAttr = _gadc.Reference()
	_bab.IdAttr = _g.String(_dac.ID())
	_ec.Hyperlinks.Hyperlink = append(_ec.Hyperlinks.Hyperlink, _bab)
}

const _fd = "\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300"

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_gdbd Cell) GetString() string {
	switch _gdbd._eeg.TAttr {
	case _ba.ST_CellTypeInlineStr:
		if _gdbd._eeg.Is != nil && _gdbd._eeg.Is.T != nil {
			return *_gdbd._eeg.Is.T
		}
		if _gdbd._eeg.V != nil {
			return *_gdbd._eeg.V
		}
	case _ba.ST_CellTypeS:
		if _gdbd._eeg.V == nil {
			return ""
		}
		_bgc, _dfga := _cg.Atoi(*_gdbd._eeg.V)
		if _dfga != nil {
			return ""
		}
		_aec, _dfga := _gdbd._agg.SharedStrings.GetString(_bgc)
		if _dfga != nil {
			return ""
		}
		return _aec
	}
	if _gdbd._eeg.V == nil {
		return ""
	}
	return *_gdbd._eeg.V
}

var _ebcd = false

// SetColOffset sets the column offset of the top-left anchor.
func (_fce OneCellAnchor) SetColOffset(m _cf.Distance) { _fce.TopLeft().SetColOffset(m) }

// X returns the inner wrapped XML type.
func (_adag RichTextRun) X() *_ba.CT_RElt { return _adag._fgfg }

// Priority returns the rule priority
func (_bdb ConditionalFormattingRule) Priority() int32 { return _bdb._bcca.PriorityAttr }

// PasswordHash returns the hash of the workbook password.
func (_gdegg SheetProtection) PasswordHash() string {
	if _gdegg._baca.PasswordAttr == nil {
		return ""
	}
	return *_gdegg._baca.PasswordAttr
}

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_cgda Cell) GetValueAsTime() (_ag.Time, error) {
	if _cgda._eeg.TAttr != _ba.ST_CellTypeUnset {
		return _ag.Time{}, _de.New("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t")
	}
	if _cgda._eeg.V == nil {
		return _ag.Time{}, _de.New("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065")
	}
	_fcb, _, _adbd := _gg.ParseFloat(*_cgda._eeg.V, 10, 128, _gg.ToNearestEven)
	if _adbd != nil {
		return _ag.Time{}, _adbd
	}
	_cgc := new(_gg.Float)
	_cgc.SetUint64(uint64(24 * _ag.Hour))
	_fcb.Mul(_fcb, _cgc)
	_ggf, _ := _fcb.Uint64()
	_cdf := _cgda._agg.Epoch().Add(_ag.Duration(_ggf))
	return _adf(_cdf), nil
}

// SetTopLeft sets the top left visible cell after the split.
func (_ccdc SheetView) SetTopLeft(cellRef string) {
	_ccdc.ensurePane()
	_ccdc._adgd.Pane.TopLeftCellAttr = &cellRef
}

// SetCol set the column of the cell marker.
func (_ece CellMarker) SetCol(col int32) { _ece._ccb.Col = col }

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_dacbb Row) Cell(col string) Cell {
	_bdc := _ade.Sprintf("\u0025\u0073\u0025\u0064", col, _dacbb.RowNumber())
	for _, _ffa := range _dacbb._agbf.C {
		if _ffa.RAttr != nil && *_ffa.RAttr == _bdc {
			return Cell{_dacbb._bdaf, _dacbb._edfa, _dacbb._agbf, _ffa}
		}
	}
	return _dacbb.AddNamedCell(col)
}
func (_gbb Cell) getLabelPrefix() string {
	if _gbb._eeg.SAttr == nil {
		return ""
	}
	_df := *_gbb._eeg.SAttr
	_dbd := _gbb._agg.StyleSheet.GetCellStyle(_df)
	switch _dbd._daa.Alignment.HorizontalAttr {
	case _ba.ST_HorizontalAlignmentLeft:
		return "\u0027"
	case _ba.ST_HorizontalAlignmentRight:
		return "\u0022"
	case _ba.ST_HorizontalAlignmentCenter:
		return "\u005e"
	case _ba.ST_HorizontalAlignmentFill:
		return "\u005c"
	default:
		return ""
	}
}

// SetMinLength sets the minimum bar length in percent.
func (_efef DataBarScale) SetMinLength(l uint32) { _efef._abb.MinLengthAttr = _g.Uint32(l) }

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_dfd IconScale) AddFormatValue(t _ba.ST_CfvoType, val string) {
	_egfb := _ba.NewCT_Cfvo()
	_egfb.TypeAttr = t
	_egfb.ValAttr = _g.String(val)
	_dfd._dacb.Cfvo = append(_dfd._dacb.Cfvo, _egfb)
}

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_afcda *Workbook) CopySheet(ind int, copiedSheetName string) (Sheet, error) {
	if _afcda.SheetCount() <= ind {
		return Sheet{}, ErrorNotFound
	}
	var _aegc _bfd.Relationship
	for _, _cfegb := range _afcda._fcad.Relationships() {
		if _cfegb.ID() == _afcda._badbd.Sheets.Sheet[ind].IdAttr {
			var _feace bool
			if _aegc, _feace = _afcda._fcad.CopyRelationship(_cfegb.ID()); !_feace {
				return Sheet{}, ErrorNotFound
			}
			break
		}
	}
	_afcda.ContentTypes.CopyOverride(_g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.WorksheetContentType, ind+1), _g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.WorksheetContentType, len(_afcda.ContentTypes.X().Override)))
	_ebeg := *_afcda._fgc[ind]
	_afcda._fgc = append(_afcda._fgc, &_ebeg)
	var _eaeg uint32 = 0
	for _, _daegc := range _afcda._badbd.Sheets.Sheet {
		if _daegc.SheetIdAttr > _eaeg {
			_eaeg = _daegc.SheetIdAttr
		}
	}
	_eaeg++
	_acbdf := *_afcda._badbd.Sheets.Sheet[ind]
	_acbdf.IdAttr = _aegc.ID()
	_acbdf.NameAttr = copiedSheetName
	_acbdf.SheetIdAttr = _eaeg
	_afcda._badbd.Sheets.Sheet = append(_afcda._badbd.Sheets.Sheet, &_acbdf)
	_acgb := _bfd.NewRelationshipsCopy(_afcda._gcga[ind])
	_afcda._gcga = append(_afcda._gcga, _acgb)
	_geda := _afcda._eabg[ind]
	if _geda == nil {
		_afcda._eabg = append(_afcda._eabg, nil)
	} else {
		_gbcd := *_geda
		_afcda._eabg = append(_afcda._eabg, &_gbcd)
	}
	_ddgb := Sheet{_afcda, &_acbdf, &_ebeg}
	return _ddgb, nil
}

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{ _abb *_ba.CT_DataBar }

// Protection controls the protection on an individual sheet.
func (_eeeb *Sheet) Protection() SheetProtection {
	if _eeeb._edeb.SheetProtection == nil {
		_eeeb._edeb.SheetProtection = _ba.NewCT_SheetProtection()
	}
	return SheetProtection{_eeeb._edeb.SheetProtection}
}

// IsBool returns true if the cell boolean value.
func (_cagd *evalContext) IsBool(cellRef string) bool { return _cagd._abgg.Cell(cellRef).IsBool() }

const (
	SortOrderAscending SortOrder = iota
	SortOrderDescending
)

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_gbge *Sheet) InsertRow(rowNum int) Row {
	_dbafd := uint32(rowNum)
	for _, _bce := range _gbge.Rows() {
		if _bce._agbf.RAttr != nil && *_bce._agbf.RAttr >= _dbafd {
			*_bce._agbf.RAttr++
			for _, _aegea := range _bce.Cells() {
				_fdbaa, _abf := _dg.ParseCellReference(_aegea.Reference())
				if _abf != nil {
					continue
				}
				_fdbaa.RowIdx++
				_aegea._eeg.RAttr = _g.String(_fdbaa.String())
			}
		}
	}
	for _, _feg := range _gbge.MergedCells() {
		_bfaff, _fddb, _abd := _dg.ParseRangeReference(_feg.Reference())
		if _abd != nil {
			continue
		}
		if int(_bfaff.RowIdx) >= rowNum {
			_bfaff.RowIdx++
		}
		if int(_fddb.RowIdx) >= rowNum {
			_fddb.RowIdx++
		}
		_bge := _ade.Sprintf("\u0025\u0073\u003a%\u0073", _bfaff, _fddb)
		_feg.SetReference(_bge)
	}
	return _gbge.AddNumberedRow(_dbafd)
}

// X returns the inner wrapped XML type.
func (_baba Sheet) X() *_ba.Worksheet { return _baba._edeb }

// SetHidden controls the visibility of a column.
func (_fcbf Column) SetHidden(b bool) {
	if !b {
		_fcbf._eaac.HiddenAttr = nil
	} else {
		_fcbf._eaac.HiddenAttr = _g.Bool(true)
	}
}
func (_cded Sheet) validateSheetNames() error {
	if len(_cded.Name()) > 31 {
		return _ade.Errorf("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331", _cded.Name(), len(_cded.Name()))
	}
	return nil
}

// X returns the inner XML entity for a stylesheet.
func (_adbfa StyleSheet) X() *_ba.StyleSheet { return _adbfa._gfde }
func (_ffdf *Workbook) onNewRelationship(_aaabc *_e.DecodeMap, _bddfb, _defa string, _efedd []*_cb.File, _eaege *_gbg.Relationship, _efgd _e.Target) error {
	_bcccc := _g.DocTypeSpreadsheet
	switch _defa {
	case _g.OfficeDocumentType:
		_ffdf._badbd = _ba.NewWorkbook()
		_aaabc.AddTarget(_bddfb, _ffdf._badbd, _defa, 0)
		_ffdf._fcad = _bfd.NewRelationships()
		_aaabc.AddTarget(_e.RelationsPathFor(_bddfb), _ffdf._fcad.X(), _defa, 0)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, 0)
	case _g.CorePropertiesType:
		_aaabc.AddTarget(_bddfb, _ffdf.CoreProperties.X(), _defa, 0)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, 0)
	case _g.CustomPropertiesType:
		_aaabc.AddTarget(_bddfb, _ffdf.CustomProperties.X(), _defa, 0)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, 0)
	case _g.ExtendedPropertiesType:
		_aaabc.AddTarget(_bddfb, _ffdf.AppProperties.X(), _defa, 0)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, 0)
	case _g.WorksheetType:
		_adge := _ba.NewWorksheet()
		_gfgd := uint32(len(_ffdf._fgc))
		_ffdf._fgc = append(_ffdf._fgc, _adge)
		_aaabc.AddTarget(_bddfb, _adge, _defa, _gfgd)
		_dgddg := _bfd.NewRelationships()
		_aaabc.AddTarget(_e.RelationsPathFor(_bddfb), _dgddg.X(), _defa, 0)
		_ffdf._gcga = append(_ffdf._gcga, _dgddg)
		_ffdf._eabg = append(_ffdf._eabg, nil)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, len(_ffdf._fgc))
	case _g.StylesType:
		_ffdf.StyleSheet = NewStyleSheet(_ffdf)
		_aaabc.AddTarget(_bddfb, _ffdf.StyleSheet.X(), _defa, 0)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, 0)
	case _g.ThemeType:
		_gaae := _dgf.NewTheme()
		_ffdf._bbf = append(_ffdf._bbf, _gaae)
		_aaabc.AddTarget(_bddfb, _gaae, _defa, 0)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, len(_ffdf._bbf))
	case _g.SharedStringsType:
		_ffdf.SharedStrings = NewSharedStrings()
		_aaabc.AddTarget(_bddfb, _ffdf.SharedStrings.X(), _defa, 0)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, 0)
	case _g.ThumbnailType:
		for _cgae, _geadd := range _efedd {
			if _geadd == nil {
				continue
			}
			if _geadd.Name == _bddfb {
				_aegd, _cdgaa := _geadd.Open()
				if _cdgaa != nil {
					return _ade.Errorf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073", _cdgaa)
				}
				_ffdf.Thumbnail, _, _cdgaa = _gd.Decode(_aegd)
				_aegd.Close()
				if _cdgaa != nil {
					return _ade.Errorf("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073", _cdgaa)
				}
				_efedd[_cgae] = nil
			}
		}
	case _g.ImageType:
		for _cdfd, _fecd := range _efedd {
			if _fecd == nil {
				continue
			}
			if _fecd.Name == _bddfb {
				_affa, _gcae := _e.ExtractToDiskTmp(_fecd, _ffdf.TmpPath)
				if _gcae != nil {
					return _gcae
				}
				_aefe, _gcae := _bfd.ImageFromStorage(_affa)
				if _gcae != nil {
					return _gcae
				}
				_cbeb := _bfd.MakeImageRef(_aefe, &_ffdf.DocBase, _ffdf._fcad)
				_ffdf.Images = append(_ffdf.Images, _cbeb)
				_efedd[_cdfd] = nil
			}
		}
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, len(_ffdf.Images))
	case _g.DrawingType:
		_bfeg := _ea.NewWsDr()
		_gecg := uint32(len(_ffdf._cbgc))
		_aaabc.AddTarget(_bddfb, _bfeg, _defa, _gecg)
		_ffdf._cbgc = append(_ffdf._cbgc, _bfeg)
		_fabf := _bfd.NewRelationships()
		_aaabc.AddTarget(_e.RelationsPathFor(_bddfb), _fabf.X(), _defa, _gecg)
		_ffdf._dbagc = append(_ffdf._dbagc, _fabf)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, len(_ffdf._cbgc))
	case _g.VMLDrawingType:
		_bfaa := _da.NewContainer()
		_fcca := uint32(len(_ffdf._effd))
		_aaabc.AddTarget(_bddfb, _bfaa, _defa, _fcca)
		_ffdf._effd = append(_ffdf._effd, _bfaa)
	case _g.CommentsType:
		_ffdf._eabg[_efgd.Index] = _ba.NewComments()
		_aaabc.AddTarget(_bddfb, _ffdf._eabg[_efgd.Index], _defa, _efgd.Index)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, len(_ffdf._eabg))
	case _g.ChartType:
		_ecbf := _ef.NewChartSpace()
		_cgfd := uint32(len(_ffdf._bgfa))
		_aaabc.AddTarget(_bddfb, _ecbf, _defa, _cgfd)
		_ffdf._bgfa = append(_ffdf._bgfa, _ecbf)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, len(_ffdf._bgfa))
	case _g.TableType:
		_aggb := _ba.NewTable()
		_ccbb := uint32(len(_ffdf._eedb))
		_aaabc.AddTarget(_bddfb, _aggb, _defa, _ccbb)
		_ffdf._eedb = append(_ffdf._eedb, _aggb)
		_eaege.TargetAttr = _g.RelativeFilename(_bcccc, _efgd.Typ, _defa, len(_ffdf._eedb))
	default:
		_g.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073", _bddfb, _defa)
	}
	return nil
}

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_cbgfa *Sheet) ClearSheetViews() { _cbgfa._edeb.SheetViews = nil }

type Table struct{ _eega *_ba.Table }

// MoveTo is a no-op.
func (_cbb AbsoluteAnchor) MoveTo(x, y int32) {}
func (_dbaf Cell) GetRawValue() (string, error) {
	switch _dbaf._eeg.TAttr {
	case _ba.ST_CellTypeInlineStr:
		if _dbaf._eeg.Is == nil || _dbaf._eeg.Is.T == nil {
			return "", nil
		}
		return *_dbaf._eeg.Is.T, nil
	case _ba.ST_CellTypeS:
		if _dbaf._eeg.V == nil {
			return "", nil
		}
		_acc, _gcg := _cg.Atoi(*_dbaf._eeg.V)
		if _gcg != nil {
			return "", _gcg
		}
		return _dbaf._agg.SharedStrings.GetString(_acc)
	case _ba.ST_CellTypeStr:
		if _dbaf._eeg.F != nil {
			return _dbaf._eeg.F.Content, nil
		}
	}
	if _dbaf._eeg.V == nil {
		return "", nil
	}
	return *_dbaf._eeg.V, nil
}

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_agae *evalContext) GetLabelPrefix(cellRef string) string {
	return _agae._abgg.Cell(cellRef).getLabelPrefix()
}

// GetEpoch returns a workbook's time epoch.
func (_fdefc *evalContext) GetEpoch() _ag.Time { return _fdefc._abgg._ebee.Epoch() }

// SetRowOffset sets the row offset of the top-left anchor.
func (_gcd OneCellAnchor) SetRowOffset(m _cf.Distance) { _gcd.TopLeft().SetRowOffset(m) }

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{ _bgdf *_ba.CT_DataValidation }

// SetRowOffset sets the row offset of the two cell anchor
func (_ddaf TwoCellAnchor) SetRowOffset(m _cf.Distance) {
	_bcbad := m - _ddaf.TopLeft().RowOffset()
	_ddaf.TopLeft().SetRowOffset(m)
	_ddaf.BottomRight().SetRowOffset(_ddaf.BottomRight().RowOffset() + _bcbad)
}

// Clear clears the cell's value and type.
func (_cea Cell) Clear() { _cea.clearValue(); _cea._eeg.TAttr = _ba.ST_CellTypeUnset }

type WorkbookProtection struct{ _aba *_ba.CT_WorkbookProtection }

// Index returns the index of the border for use with a cell style.
func (_ee Border) Index() uint32 {
	for _dba, _fe := range _ee._dae.Border {
		if _fe == _ee._cba {
			return uint32(_dba)
		}
	}
	return 0
}
func (_fgdc Sheet) ExtentsIndex() (string, uint32, string, uint32) {
	var _gaga, _egbf, _cgbe, _facc uint32 = 1, 1, 0, 0
	for _, _ege := range _fgdc.Rows() {
		if _ege.RowNumber() < _gaga {
			_gaga = _ege.RowNumber()
		} else if _ege.RowNumber() > _egbf {
			_egbf = _ege.RowNumber()
		}
		for _, _aaga := range _ege.Cells() {
			_aece, _geea := _dg.ParseCellReference(_aaga.Reference())
			if _geea == nil {
				if _aece.ColumnIdx < _cgbe {
					_cgbe = _aece.ColumnIdx
				} else if _aece.ColumnIdx > _facc {
					_facc = _aece.ColumnIdx
				}
			}
		}
	}
	return _dg.IndexToColumn(_cgbe), _gaga, _dg.IndexToColumn(_facc), _egbf
}
func (_geeaa *Sheet) setArray(_bacg string, _eadg _cgd.Result) error {
	_dbde, _afcd := _dg.ParseCellReference(_bacg)
	if _afcd != nil {
		return _afcd
	}
	for _acgebd, _cdfg := range _eadg.ValueArray {
		_effe := _geeaa.Row(_dbde.RowIdx + uint32(_acgebd))
		for _bcab, _bedc := range _cdfg {
			_ddfg := _effe.Cell(_dg.IndexToColumn(_dbde.ColumnIdx + uint32(_bcab)))
			if _bedc.Type != _cgd.ResultTypeEmpty {
				if _bedc.IsBoolean {
					_ddfg.SetBool(_bedc.ValueNumber != 0)
				} else {
					_ddfg.SetCachedFormulaResult(_bedc.String())
				}
			}
		}
	}
	return nil
}
func CreateDefaultNumberFormat(id StandardFormat) NumberFormat {
	_fgea := NumberFormat{_cgg: _ba.NewCT_NumFmt()}
	_fgea._cgg.NumFmtIdAttr = uint32(id)
	_fgea._cgg.FormatCodeAttr = "\u0047e\u006e\u0065\u0072\u0061\u006c"
	switch id {
	case StandardFormat0:
		_fgea._cgg.FormatCodeAttr = "\u0047e\u006e\u0065\u0072\u0061\u006c"
	case StandardFormat1:
		_fgea._cgg.FormatCodeAttr = "\u0030"
	case StandardFormat2:
		_fgea._cgg.FormatCodeAttr = "\u0030\u002e\u0030\u0030"
	case StandardFormat3:
		_fgea._cgg.FormatCodeAttr = "\u0023\u002c\u0023#\u0030"
	case StandardFormat4:
		_fgea._cgg.FormatCodeAttr = "\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030"
	case StandardFormat9:
		_fgea._cgg.FormatCodeAttr = "\u0030\u0025"
	case StandardFormat10:
		_fgea._cgg.FormatCodeAttr = "\u0030\u002e\u00300\u0025"
	case StandardFormat11:
		_fgea._cgg.FormatCodeAttr = "\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030"
	case StandardFormat12:
		_fgea._cgg.FormatCodeAttr = "\u0023\u0020\u003f/\u003f"
	case StandardFormat13:
		_fgea._cgg.FormatCodeAttr = "\u0023 \u003f\u003f\u002f\u003f\u003f"
	case StandardFormat14:
		_fgea._cgg.FormatCodeAttr = "\u006d\u002f\u0064\u002f\u0079\u0079"
	case StandardFormat15:
		_fgea._cgg.FormatCodeAttr = "\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079"
	case StandardFormat16:
		_fgea._cgg.FormatCodeAttr = "\u0064\u002d\u006dm\u006d"
	case StandardFormat17:
		_fgea._cgg.FormatCodeAttr = "\u006d\u006d\u006d\u002d\u0079\u0079"
	case StandardFormat18:
		_fgea._cgg.FormatCodeAttr = "\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d"
	case StandardFormat19:
		_fgea._cgg.FormatCodeAttr = "\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d"
	case StandardFormat20:
		_fgea._cgg.FormatCodeAttr = "\u0068\u003a\u006d\u006d"
	case StandardFormat21:
		_fgea._cgg.FormatCodeAttr = "\u0068:\u006d\u006d\u003a\u0073\u0073"
	case StandardFormat22:
		_fgea._cgg.FormatCodeAttr = "m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d"
	case StandardFormat37:
		_fgea._cgg.FormatCodeAttr = "\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029"
	case StandardFormat38:
		_fgea._cgg.FormatCodeAttr = "\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029"
	case StandardFormat39:
		_fgea._cgg.FormatCodeAttr = "\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029"
	case StandardFormat40:
		_fgea._cgg.FormatCodeAttr = "\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029"
	case StandardFormat45:
		_fgea._cgg.FormatCodeAttr = "\u006d\u006d\u003as\u0073"
	case StandardFormat46:
		_fgea._cgg.FormatCodeAttr = "\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s"
	case StandardFormat47:
		_fgea._cgg.FormatCodeAttr = "\u006dm\u003a\u0073\u0073\u002e\u0030"
	case StandardFormat48:
		_fgea._cgg.FormatCodeAttr = "\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030"
	case StandardFormat49:
		_fgea._cgg.FormatCodeAttr = "\u0040"
	}
	return _fgea
}

// SetColOffset sets the column offset of the two cell anchor.
func (_cdbe TwoCellAnchor) SetColOffset(m _cf.Distance) {
	_geeg := m - _cdbe.TopLeft().ColOffset()
	_cdbe.TopLeft().SetColOffset(m)
	_cdbe.BottomRight().SetColOffset(_cdbe.BottomRight().ColOffset() + _geeg)
}

// SetRotation configures the cell to be rotated.
func (_efg CellStyle) SetRotation(deg uint8) {
	if _efg._daa.Alignment == nil {
		_efg._daa.Alignment = _ba.NewCT_CellAlignment()
	}
	_efg._daa.ApplyAlignmentAttr = _g.Bool(true)
	_efg._daa.Alignment.TextRotationAttr = _g.Uint8(deg)
}

// SetSize sets the text size for a rich text run.
func (_aebbg RichTextRun) SetSize(m _cf.Distance) {
	_aebbg.ensureRpr()
	_aebbg._fgfg.RPr.Sz = _ba.NewCT_FontSize()
	_aebbg._fgfg.RPr.Sz.ValAttr = float64(m / _cf.Point)
}

// Read reads a workbook from an io.Reader(.xlsx).
func Read(r _c.ReaderAt, size int64) (*Workbook, error) {
	_gcf := New()
	_gefe, _fgga := _b.TempDir("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078")
	if _fgga != nil {
		return nil, _fgga
	}
	_gcf.TmpPath = _gefe
	_dgfg, _fgga := _cb.NewReader(r, size)
	if _fgga != nil {
		return nil, _ade.Errorf("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073", _fgga)
	}
	_aafd := []*_cb.File{}
	_aafd = append(_aafd, _dgfg.File...)
	_gbgd := false
	for _, _aaef := range _aafd {
		if _aaef.FileHeader.Name == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
			_gbgd = true
			break
		}
	}
	if _gbgd {
		_gcf.createCustomProperties()
	}
	_fda := _e.DecodeMap{}
	_fda.SetOnNewRelationshipFunc(_gcf.onNewRelationship)
	_fda.AddTarget(_g.ContentTypesFilename, _gcf.ContentTypes.X(), "", 0)
	_fda.AddTarget(_g.BaseRelsFilename, _gcf.Rels.X(), "", 0)
	if _bbe := _fda.Decode(_aafd); _bbe != nil {
		return nil, _bbe
	}
	for _, _agbd := range _aafd {
		if _agbd == nil {
			continue
		}
		if _gada := _gcf.AddExtraFileFromZip(_agbd); _gada != nil {
			return nil, _gada
		}
	}
	if _gbgd {
		_dde := false
		for _, _dbfe := range _gcf.Rels.X().Relationship {
			if _dbfe.TargetAttr == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
				_dde = true
				break
			}
		}
		if !_dde {
			_gcf.addCustomRelationships()
		}
	}
	return _gcf, nil
}
func (_dfe Fill) SetPatternFill() PatternFill {
	_dfe._dbf.GradientFill = nil
	_dfe._dbf.PatternFill = _ba.NewCT_PatternFill()
	_dfe._dbf.PatternFill.PatternTypeAttr = _ba.ST_PatternTypeSolid
	return PatternFill{_dfe._dbf.PatternFill, _dfe._dbf}
}
func (_ffc Border) SetLeft(style _ba.ST_BorderStyle, c _gb.Color) {
	if _ffc._cba.Left == nil {
		_ffc._cba.Left = _ba.NewCT_BorderPr()
	}
	_ffc._cba.Left.Color = _ba.NewCT_Color()
	_ffc._cba.Left.Color.RgbAttr = c.AsRGBAString()
	_ffc._cba.Left.StyleAttr = style
}

// IsEmpty checks if the cell style contains nothing.
func (_fcg CellStyle) IsEmpty() bool {
	return _fcg._fga == nil || _fcg._daa == nil || _fcg._ebe == nil || _fcg._ebe.Xf == nil
}

// GetFormula returns the formula for a cell.
func (_fcbd Cell) GetFormula() string {
	if _fcbd._eeg.F != nil {
		return _fcbd._eeg.F.Content
	}
	return ""
}

// SetBorder applies a border to a cell style.  The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_caf CellStyle) SetBorder(b Border) {
	_caf._daa.BorderIdAttr = _g.Uint32(b.Index())
	_caf._daa.ApplyBorderAttr = _g.Bool(true)
}

// RemoveDefinedName removes an existing defined name.
func (_gbce *Workbook) RemoveDefinedName(dn DefinedName) error {
	if dn.X() == nil {
		return _de.New("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065")
	}
	for _gdcc, _afafb := range _gbce._badbd.DefinedNames.DefinedName {
		if _afafb == dn.X() {
			copy(_gbce._badbd.DefinedNames.DefinedName[_gdcc:], _gbce._badbd.DefinedNames.DefinedName[_gdcc+1:])
			_gbce._badbd.DefinedNames.DefinedName[len(_gbce._badbd.DefinedNames.DefinedName)-1] = nil
			_gbce._badbd.DefinedNames.DefinedName = _gbce._badbd.DefinedNames.DefinedName[:len(_gbce._badbd.DefinedNames.DefinedName)-1]
			return nil
		}
	}
	return _de.New("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064")
}

// SetPriority sets the rule priority
func (_ccfgd ConditionalFormattingRule) SetPriority(p int32) { _ccfgd._bcca.PriorityAttr = p }

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{ _fgfg *_ba.CT_RElt }

// AddRule adds and returns a new rule that can be configured.
func (_addd ConditionalFormatting) AddRule() ConditionalFormattingRule {
	_bea := _ba.NewCT_CfRule()
	_addd._fde.CfRule = append(_addd._fde.CfRule, _bea)
	_cee := ConditionalFormattingRule{_bea}
	_cee.InitializeDefaults()
	_cee.SetPriority(int32(len(_addd._fde.CfRule) + 1))
	return _cee
}

// Row returns the row of the cell marker.
func (_bac CellMarker) Row() int32 { return _bac._ccb.Row }

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{ _fde *_ba.CT_ConditionalFormatting }

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_cfbd Sheet) Extents() string {
	_beaf, _ggc, _ccggg, _dfff := _cfbd.ExtentsIndex()
	return _ade.Sprintf("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d", _beaf, _ggc, _ccggg, _dfff)
}

var (
	_dcfb  = [...]uint8{0, 21, 46, 61, 76, 91}
	_aage  = [...]uint8{0, 21, 37, 53, 69, 85, 103, 119, 135, 151, 167, 185, 201, 217, 239}
	_gebcd = [...]uint8{0, 16, 32, 48, 64}
	_dgbc  = [...]uint8{0, 16, 32, 48, 64, 80}
)

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_deae *Sheet) Row(rowNum uint32) Row {
	for _, _badc := range _deae._edeb.SheetData.Row {
		if _badc.RAttr != nil && *_badc.RAttr == rowNum {
			return Row{_deae._ebee, _deae, _badc}
		}
	}
	return _deae.AddNumberedRow(rowNum)
}
func _adf(_gad _ag.Time) _ag.Time {
	_gad = _gad.UTC()
	return _ag.Date(_gad.Year(), _gad.Month(), _gad.Day(), _gad.Hour(), _gad.Minute(), _gad.Second(), _gad.Nanosecond(), _ag.Local)
}

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_dffe CellStyle) SetVerticalAlignment(a _ba.ST_VerticalAlignment) {
	if _dffe._daa.Alignment == nil {
		_dffe._daa.Alignment = _ba.NewCT_CellAlignment()
	}
	_dffe._daa.ApplyAlignmentAttr = _g.Bool(true)
	_dffe._daa.Alignment.VerticalAttr = a
}
func (_bfbe Sheet) validateMergedCells() error {
	_fcgc := map[uint64]struct{}{}
	for _, _afca := range _bfbe.MergedCells() {
		_dgff, _fac, _gacd := _dg.ParseRangeReference(_afca.Reference())
		if _gacd != nil {
			return _ade.Errorf("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073", _bfbe.Name(), _afca.Reference())
		}
		for _acbe := _dgff.RowIdx; _acbe <= _fac.RowIdx; _acbe++ {
			for _cfb := _dgff.ColumnIdx; _cfb <= _fac.ColumnIdx; _cfb++ {
				_fcbb := uint64(_acbe)<<32 | uint64(_cfb)
				if _, _ecea := _fcgc[_fcbb]; _ecea {
					return _ade.Errorf("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065", _bfbe.Name())
				}
				_fcgc[_fcbb] = struct{}{}
			}
		}
	}
	return nil
}
func (_fa Cell) getFormat() string {
	if _fa._eeg.SAttr == nil {
		return "\u0047e\u006e\u0065\u0072\u0061\u006c"
	}
	_gbe := *_fa._eeg.SAttr
	_gec := _fa._agg.StyleSheet.GetCellStyle(_gbe)
	_geg := _fa._agg.StyleSheet.GetNumberFormat(_gec.NumberFormat())
	return _geg.GetFormat()
}
func (_bcbb Font) SetColor(c _gb.Color) {
	_edb := _ba.NewCT_Color()
	_aafe := "\u0066\u0066" + *c.AsRGBString()
	_edb.RgbAttr = &_aafe
	_bcbb._gcc.Color = []*_ba.CT_Color{_edb}
}

// ClearFill clears any fill configuration from the cell style.
func (_afa CellStyle) ClearFill() { _afa._daa.FillIdAttr = nil; _afa._daa.ApplyFillAttr = nil }

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_babc *Sheet) Column(idx uint32) Column {
	for _, _bbec := range _babc._edeb.Cols {
		for _, _bbbb := range _bbec.Col {
			if idx >= _bbbb.MinAttr && idx <= _bbbb.MaxAttr {
				return Column{_bbbb}
			}
		}
	}
	var _gaddb *_ba.CT_Cols
	if len(_babc._edeb.Cols) == 0 {
		_gaddb = _ba.NewCT_Cols()
		_babc._edeb.Cols = append(_babc._edeb.Cols, _gaddb)
	} else {
		_gaddb = _babc._edeb.Cols[0]
	}
	_dcad := _ba.NewCT_Col()
	_dcad.MinAttr = idx
	_dcad.MaxAttr = idx
	_gaddb.Col = append(_gaddb.Col, _dcad)
	return Column{_dcad}
}

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_gdda *Sheet) Cell(cellRef string) Cell {
	_gedg, _fdba := _dg.ParseCellReference(cellRef)
	if _fdba != nil {
		_g.Log("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073", _fdba)
		return _gdda.AddRow().AddCell()
	}
	return _gdda.Row(_gedg.RowIdx).Cell(_gedg.Column)
}

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_gde Row) Cells() []Cell {
	_dfag := []Cell{}
	_gcgde := -1
	for _, _dec := range _gde._agbf.C {
		if _dec.RAttr == nil {
			_g.Log("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e")
			continue
		}
		_fcbdb, _gegd := _dg.ParseCellReference(*_dec.RAttr)
		if _gegd != nil {
			_g.Log("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020" + *_dec.RAttr + ",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e")
			continue
		}
		_eba := int(_fcbdb.ColumnIdx)
		if _eba-_gcgde > 1 {
			for _fgbc := _gcgde + 1; _fgbc < _eba; _fgbc++ {
				_dfag = append(_dfag, _gde.Cell(_dg.IndexToColumn(uint32(_fgbc))))
			}
		}
		_gcgde = _eba
		_dfag = append(_dfag, Cell{_gde._bdaf, _gde._edfa, _gde._agbf, _dec})
	}
	return _dfag
}

// Comments returns the list of comments for this sheet
func (_dfc Comments) Comments() []Comment {
	_deegc := []Comment{}
	for _, _cfe := range _dfc._caa.CommentList.Comment {
		_deegc = append(_deegc, Comment{_dfc._efc, _cfe, _dfc._caa})
	}
	return _deegc
}
func (_dbedg Sheet) IsValid() bool { return _dbedg._edeb != nil }

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash(s string) string {
	_ebce := uint16(0)
	if len(s) > 0 {
		for _fdbb := len(s) - 1; _fdbb >= 0; _fdbb-- {
			_cfgcb := s[_fdbb]
			_ebce = ((_ebce >> 14) & 0x01) | ((_ebce << 1) & 0x7fff)
			_ebce ^= uint16(_cfgcb)
		}
		_ebce = ((_ebce >> 14) & 0x01) | ((_ebce << 1) & 0x7fff)
		_ebce ^= uint16(len(s))
		_ebce ^= (0x8000 | ('N' << 8) | 'K')
	}
	return _ade.Sprintf("\u0025\u0030\u0034\u0058", uint64(_ebce))
}

// SetStyle sets the style to be used for conditional rules
func (_fae ConditionalFormattingRule) SetStyle(d DifferentialStyle) {
	_fae._bcca.DxfIdAttr = _g.Uint32(d.Index())
}

// SetColor sets the text color.
func (_gbf RichTextRun) SetColor(c _gb.Color) {
	_gbf.ensureRpr()
	_gbf._fgfg.RPr.Color = _ba.NewCT_Color()
	_eab := "\u0066\u0066" + *c.AsRGBString()
	_gbf._fgfg.RPr.Color.RgbAttr = &_eab
}

// ColOffset returns the offset from the row cell.
func (_eaae CellMarker) ColOffset() _cf.Distance {
	if _eaae._ccb.RowOff.ST_CoordinateUnqualified == nil {
		return 0
	}
	return _cf.Distance(float64(*_eaae._ccb.ColOff.ST_CoordinateUnqualified) * _cf.EMU)
}

// LockStructure controls the locking of the workbook structure.
func (_bbbf WorkbookProtection) LockStructure(b bool) {
	if !b {
		_bbbf._aba.LockStructureAttr = nil
	} else {
		_bbbf._aba.LockStructureAttr = _g.Bool(true)
	}
}

// Validate attempts to validate the structure of a workbook.
func (_gdef *Workbook) Validate() error {
	if _gdef == nil || _gdef._badbd == nil {
		return _de.New("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065")
	}
	_feec := uint32(0)
	for _, _gaf := range _gdef._badbd.Sheets.Sheet {
		if _gaf.SheetIdAttr > _feec {
			_feec = _gaf.SheetIdAttr
		}
	}
	if _feec != uint32(len(_gdef._fgc)) {
		return _ade.Errorf("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073", _feec, len(_gdef._fgc))
	}
	_dbccf := map[string]struct{}{}
	for _dfcc, _dgdf := range _gdef._badbd.Sheets.Sheet {
		_fbgf := Sheet{_gdef, _dgdf, _gdef._fgc[_dfcc]}
		if _, _bafc := _dbccf[_fbgf.Name()]; _bafc {
			return _ade.Errorf("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027", _dfcc, _fbgf.Name())
		}
		_dbccf[_fbgf.Name()] = struct{}{}
		if _ffgb := _fbgf.ValidateWithPath(_ade.Sprintf("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d", _dfcc)); _ffgb != nil {
			return _ffgb
		}
		if _aegb := _fbgf.Validate(); _aegb != nil {
			return _aegb
		}
	}
	return nil
}

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_faee Row) CellsWithEmpty(lastColIdx uint32) []Cell {
	_cfaaa := []Cell{}
	for _cbdf := uint32(0); _cbdf <= lastColIdx; _cbdf++ {
		_adc := _faee.Cell(_dg.IndexToColumn(_cbdf))
		_cfaaa = append(_cfaaa, _adc)
	}
	return _cfaaa
}

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_gdc DataValidation) SetRange(cellRange string) { _gdc._daec.SqrefAttr = _ba.ST_Sqref{cellRange} }
func (_fgg Cell) getLocked() bool {
	if _fgg._eeg.SAttr == nil {
		return false
	}
	_gc := *_fgg._eeg.SAttr
	_baf := _fgg._agg.StyleSheet.GetCellStyle(_gc)
	return *_baf._daa.Protection.LockedAttr
}

// GetFilename returns the filename of the context's workbook.
func (_cfcg *evalContext) GetFilename() string { return _cfcg._abgg._ebee.GetFilename() }

const (
	StandardFormatGeneral     StandardFormat = 0
	StandardFormat0           StandardFormat = 0
	StandardFormatWholeNumber StandardFormat = 1
	StandardFormat1           StandardFormat = 1
	StandardFormat2           StandardFormat = 2
	StandardFormat3           StandardFormat = 3
	StandardFormat4           StandardFormat = 4
	StandardFormatPercent     StandardFormat = 9
	StandardFormat9           StandardFormat = 9
	StandardFormat10          StandardFormat = 10
	StandardFormat11          StandardFormat = 11
	StandardFormat12          StandardFormat = 12
	StandardFormat13          StandardFormat = 13
	StandardFormatDate        StandardFormat = 14
	StandardFormat14          StandardFormat = 14
	StandardFormat15          StandardFormat = 15
	StandardFormat16          StandardFormat = 16
	StandardFormat17          StandardFormat = 17
	StandardFormat18          StandardFormat = 18
	StandardFormatTime        StandardFormat = 19
	StandardFormat19          StandardFormat = 19
	StandardFormat20          StandardFormat = 20
	StandardFormat21          StandardFormat = 21
	StandardFormatDateTime    StandardFormat = 22
	StandardFormat22          StandardFormat = 22
	StandardFormat37          StandardFormat = 37
	StandardFormat38          StandardFormat = 38
	StandardFormat39          StandardFormat = 39
	StandardFormat40          StandardFormat = 40
	StandardFormat45          StandardFormat = 45
	StandardFormat46          StandardFormat = 46
	StandardFormat47          StandardFormat = 47
	StandardFormat48          StandardFormat = 48
	StandardFormat49          StandardFormat = 49
)

// SetUnderline controls if the run is underlined.
func (_ccdg RichTextRun) SetUnderline(u _ba.ST_UnderlineValues) {
	_ccdg.ensureRpr()
	_ccdg._fgfg.RPr.U = _ba.NewCT_UnderlineProperty()
	_ccdg._fgfg.RPr.U.ValAttr = u
}

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_fg AbsoluteAnchor) SetRowOffset(m _cf.Distance) {
	_fg._deb.Pos.YAttr.ST_CoordinateUnqualified = _g.Int64(int64(m / _cf.EMU))
}

// IsBool returns true if the cell is a boolean type cell.
func (_gbec Cell) IsBool() bool { return _gbec._eeg.TAttr == _ba.ST_CellTypeB }

// AddDataValidation adds a data validation rule to a sheet.
func (_geac *Sheet) AddDataValidation() DataValidation {
	if _geac._edeb.DataValidations == nil {
		_geac._edeb.DataValidations = _ba.NewCT_DataValidations()
	}
	_ggd := _ba.NewCT_DataValidation()
	_ggd.ShowErrorMessageAttr = _g.Bool(true)
	_geac._edeb.DataValidations.DataValidation = append(_geac._edeb.DataValidations.DataValidation, _ggd)
	_geac._edeb.DataValidations.CountAttr = _g.Uint32(uint32(len(_geac._edeb.DataValidations.DataValidation)))
	return DataValidation{_ggd}
}

// X returns the inner wrapped XML type.
func (_adeb Table) X() *_ba.Table { return _adeb._eega }
func (_egdd *Sheet) getAllCellsInFormulaArraysForColumn() (map[string]bool, error) {
	return _egdd.getAllCellsInFormulaArrays(false)
}

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{ _adgd *_ba.CT_SheetView }

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_effb TwoCellAnchor) BottomRight() CellMarker { return CellMarker{_effb._afgbc.To} }

// X returns the inner wrapped XML type.
func (_bae DifferentialStyle) X() *_ba.CT_Dxf { return _bae._geff }

// Sheets returns the sheets from the workbook.
func (_fggdb *Workbook) Sheets() []Sheet {
	_dbeb := []Sheet{}
	for _geeag, _cgee := range _fggdb._fgc {
		_aacd := _fggdb._badbd.Sheets.Sheet[_geeag]
		_bace := Sheet{_fggdb, _aacd, _cgee}
		_dbeb = append(_dbeb, _bace)
	}
	return _dbeb
}

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_fagf *Workbook) SetActiveSheetIndex(idx uint32) {
	if _fagf._badbd.BookViews == nil {
		_fagf._badbd.BookViews = _ba.NewCT_BookViews()
	}
	if len(_fagf._badbd.BookViews.WorkbookView) == 0 {
		_fagf._badbd.BookViews.WorkbookView = append(_fagf._badbd.BookViews.WorkbookView, _ba.NewCT_BookView())
	}
	_fagf._badbd.BookViews.WorkbookView[0].ActiveTabAttr = _g.Uint32(idx)
}

// SetIcons sets the icon set to use for display.
func (_fff IconScale) SetIcons(t _ba.ST_IconSetType) { _fff._dacb.IconSetAttr = t }

// IconScale maps values to icons.
type IconScale struct{ _dacb *_ba.CT_IconSet }

// SetPasswordHash sets the password hash to the input.
func (_bdgb WorkbookProtection) SetPasswordHash(pwHash string) {
	_bdgb._aba.WorkbookPasswordAttr = _g.String(pwHash)
}
func _feae(_eeea string, _fefc uint32, _afgb bool) string {
	_cabd, _ecg, _dfbga := _dg.ParseRangeReference(_eeea)
	if _dfbga == nil {
		_eggg, _aeag := _cabd.ColumnIdx, _ecg.ColumnIdx
		if _fefc >= _eggg && _fefc <= _aeag {
			if _eggg == _aeag {
				if _afgb {
					return ""
				} else {
					return _eeea
				}
			} else {
				_faccg := _ecg.Update(_cfa.UpdateActionRemoveColumn)
				return _ade.Sprintf("\u0025\u0073\u003a%\u0073", _cabd.String(), _faccg.String())
			}
		} else if _fefc < _eggg {
			_cdfb := _cabd.Update(_cfa.UpdateActionRemoveColumn)
			_geab := _ecg.Update(_cfa.UpdateActionRemoveColumn)
			return _ade.Sprintf("\u0025\u0073\u003a%\u0073", _cdfb.String(), _geab.String())
		}
	} else {
		_bbd, _gbeg, _daab := _dg.ParseColumnRangeReference(_eeea)
		if _daab != nil {
			return ""
		}
		_ffede, _gdaf := _bbd.ColumnIdx, _gbeg.ColumnIdx
		if _fefc >= _ffede && _fefc <= _gdaf {
			if _ffede == _gdaf {
				if _afgb {
					return ""
				} else {
					return _eeea
				}
			} else {
				_afeba := _gbeg.Update(_cfa.UpdateActionRemoveColumn)
				return _ade.Sprintf("\u0025\u0073\u003a%\u0073", _bbd.String(), _afeba.String())
			}
		} else if _fefc < _ffede {
			_dag := _bbd.Update(_cfa.UpdateActionRemoveColumn)
			_eaba := _gbeg.Update(_cfa.UpdateActionRemoveColumn)
			return _ade.Sprintf("\u0025\u0073\u003a%\u0073", _dag.String(), _eaba.String())
		}
	}
	return ""
}
func (_fcag CellStyle) SetShrinkToFit(b bool) {
	if _fcag._daa.Alignment == nil {
		_fcag._daa.Alignment = _ba.NewCT_CellAlignment()
	}
	_fcag._daa.ApplyAlignmentAttr = _g.Bool(true)
	if !b {
		_fcag._daa.Alignment.ShrinkToFitAttr = nil
	} else {
		_fcag._daa.Alignment.ShrinkToFitAttr = _g.Bool(b)
	}
}

// CellStyles returns the list of defined cell styles
func (_gdbb StyleSheet) CellStyles() []CellStyle {
	_efad := []CellStyle{}
	for _, _bbcc := range _gdbb._gfde.CellXfs.Xf {
		_efad = append(_efad, CellStyle{_gdbb._aced, _bbcc, _gdbb._gfde.CellXfs})
	}
	return _efad
}

// Rows returns all of the rows in a sheet.
func (_babed *Sheet) Rows() []Row {
	_ebga := []Row{}
	for _, _dadg := range _babed._edeb.SheetData.Row {
		_ebga = append(_ebga, Row{_babed._ebee, _babed, _dadg})
	}
	return _ebga
}

// Content returns the content of the defined range (the range in most cases)/
func (_dgfa DefinedName) Content() string { return _dgfa._dcd.Content }

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct {
	_faeg *_ba.Sst
	_ceae map[string]int
}

// X returns the inner wrapped XML type.
func (_fcfe SheetView) X() *_ba.CT_SheetView { return _fcfe._adgd }
func _ca(_acd _ag.Time) _ag.Time {
	_acd = _acd.Local()
	return _ag.Date(_acd.Year(), _acd.Month(), _acd.Day(), _acd.Hour(), _acd.Minute(), _acd.Second(), _acd.Nanosecond(), _ag.UTC)
}

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_cfg Cell) SetString(s string) int {
	_cfg._agg.ensureSharedStringsRelationships()
	_cfg.clearValue()
	_bdf := _cfg._agg.SharedStrings.AddString(s)
	_cfg._eeg.V = _g.String(_cg.Itoa(_bdf))
	_cfg._eeg.TAttr = _ba.ST_CellTypeS
	return _bdf
}
func (_gcb Cell) getRawSortValue() (string, bool) {
	if _gcb.HasFormula() {
		_ddd := _gcb.GetCachedFormulaResult()
		return _ddd, _gdd.IsNumber(_ddd)
	}
	_afc, _ := _gcb.GetRawValue()
	return _afc, _gdd.IsNumber(_afc)
}
func (_bbgc StandardFormat) String() string {
	switch {
	case 0 <= _bbgc && _bbgc <= 4:
		return _eedef[_dcfb[_bbgc]:_dcfb[_bbgc+1]]
	case 9 <= _bbgc && _bbgc <= 22:
		_bbgc -= 9
		return _faag[_aage[_bbgc]:_aage[_bbgc+1]]
	case 37 <= _bbgc && _bbgc <= 40:
		_bbgc -= 37
		return _gbga[_gebcd[_bbgc]:_gebcd[_bbgc+1]]
	case 45 <= _bbgc && _bbgc <= 49:
		_bbgc -= 45
		return _dddb[_dgbc[_bbgc]:_dgbc[_bbgc+1]]
	default:
		return _ade.Sprintf("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029", _bbgc)
	}
}

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_bff CellStyle) SetNumberFormatStandard(s StandardFormat) {
	_bff._daa.NumFmtIdAttr = _g.Uint32(uint32(s))
	_bff._daa.ApplyNumberFormatAttr = _g.Bool(true)
}

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_gfc *evalContext) LastColumn(rowFrom, rowTo int) string {
	_deed := _gfc._abgg
	_fgb := 1
	for _egcg := rowFrom; _egcg <= rowTo; _egcg++ {
		_ebg := len(_deed.Row(uint32(_egcg)).Cells())
		if _ebg > _fgb {
			_fgb = _ebg
		}
	}
	return _dg.IndexToColumn(uint32(_fgb - 1))
}
func _daee(_cca *Sheet) *evalContext {
	return &evalContext{_abgg: _cca, _egcb: make(map[string]struct{})}
}

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_cefb *Workbook) Close() error {
	if _cefb.TmpPath != "" {
		return _b.RemoveAll(_cefb.TmpPath)
	}
	return nil
}

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_cdbd *Sheet) ClearCachedFormulaResults() {
	for _, _geed := range _cdbd.Rows() {
		for _, _ddca := range _geed.Cells() {
			if _ddca.X().F != nil {
				_ddca.X().V = nil
			}
		}
	}
}

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_bafb CellStyle) SetHorizontalAlignment(a _ba.ST_HorizontalAlignment) {
	if _bafb._daa.Alignment == nil {
		_bafb._daa.Alignment = _ba.NewCT_CellAlignment()
	}
	_bafb._daa.Alignment.HorizontalAttr = a
	_bafb._daa.ApplyAlignmentAttr = _g.Bool(true)
}

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_ccc *Sheet) AddNumberedRow(rowNum uint32) Row {
	_abbf := _ba.NewCT_Row()
	_abbf.RAttr = _g.Uint32(rowNum)
	_ccc._edeb.SheetData.Row = append(_ccc._edeb.SheetData.Row, _abbf)
	_f.Slice(_ccc._edeb.SheetData.Row, func(_bga, _acef int) bool {
		_bbbe := _ccc._edeb.SheetData.Row[_bga].RAttr
		_eebee := _ccc._edeb.SheetData.Row[_acef].RAttr
		if _bbbe == nil {
			return true
		}
		if _eebee == nil {
			return true
		}
		return *_bbbe < *_eebee
	})
	return Row{_ccc._ebee, _ccc, _abbf}
}

// AddFormatValue adds a format value to be used to determine the cell background.
func (_gag ColorScale) AddFormatValue(t _ba.ST_CfvoType, val string) {
	_acge := _ba.NewCT_Cfvo()
	_acge.TypeAttr = t
	_acge.ValAttr = _g.String(val)
	_gag._dgec.Cfvo = append(_gag._dgec.Cfvo, _acge)
}

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_dbccd Sheet) ValidateWithPath(path string) error { return _dbccd._edeb.ValidateWithPath(path) }

var _bccb = _g.RelativeFilename(_g.DocTypeSpreadsheet, _g.OfficeDocumentType, _g.SharedStringsType, 0)

// SetHeight is a nop-op.
func (_cceb TwoCellAnchor) SetHeight(h _cf.Distance) {}

// X returns the inner wrapped XML type.
func (_defg WorkbookProtection) X() *_ba.CT_WorkbookProtection { return _defg._aba }

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_faa *Sheet) SheetViews() []SheetView {
	if _faa._edeb.SheetViews == nil {
		return nil
	}
	_fbga := []SheetView{}
	for _, _edgd := range _faa._edeb.SheetViews.SheetView {
		_fbga = append(_fbga, SheetView{_edgd})
	}
	return _fbga
}

// X returns the inner wrapped XML type.
func (_bgba SharedStrings) X() *_ba.Sst { return _bgba._faeg }

// AddCommentWithStyle adds a new comment styled in a default way
func (_agf Comments) AddCommentWithStyle(cellRef string, author string, comment string) error {
	_efa := _agf.AddComment(cellRef, author)
	_acdb := _efa.AddRun()
	_acdb.SetBold(true)
	_acdb.SetSize(10)
	_acdb.SetColor(_gb.Black)
	_acdb.SetFont("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_acdb.SetText(author + "\u003a")
	_acdb = _efa.AddRun()
	_acdb.SetSize(10)
	_acdb.SetFont("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_acdb.SetColor(_gb.Black)
	_acdb.SetText("\u000d\u000a" + comment + "\u000d\u000a")
	_cdd, _aac := _dg.ParseCellReference(cellRef)
	if _aac != nil {
		return _aac
	}
	_agf._efc._effd[0].Shape = append(_agf._efc._effd[0].Shape, _da.NewCommentShape(int64(_cdd.ColumnIdx), int64(_cdd.RowIdx-1)))
	return nil
}
func (_bbb PatternFill) ClearFgColor() { _bbb._fefe.FgColor = nil }

// SetPattern sets the pattern of the fill.
func (_fdbbb PatternFill) SetPattern(p _ba.ST_PatternType) { _fdbbb._fefe.PatternTypeAttr = p }

// SetName sets the sheet name.
func (_bca *Sheet) SetName(name string) { _bca._ggeg.NameAttr = name }

// SetContent sets the defined name content.
func (_ceb DefinedName) SetContent(s string) { _ceb._dcd.Content = s }
func (_gedc Font) Index() uint32 {
	for _cdfe, _fdb := range _gedc._abc.Fonts.Font {
		if _gedc._gcc == _fdb {
			return uint32(_cdfe)
		}
	}
	return 0
}

const (
	DVCompareOpEqual        = DVCompareOp(_ba.ST_DataValidationOperatorEqual)
	DVCompareOpBetween      = DVCompareOp(_ba.ST_DataValidationOperatorBetween)
	DVCompareOpNotBetween   = DVCompareOp(_ba.ST_DataValidationOperatorNotBetween)
	DVCompareOpNotEqual     = DVCompareOp(_ba.ST_DataValidationOperatorNotEqual)
	DVCompareOpGreater      = DVCompareOp(_ba.ST_DataValidationOperatorGreaterThan)
	DVCompareOpGreaterEqual = DVCompareOp(_ba.ST_DataValidationOperatorGreaterThanOrEqual)
	DVCompareOpLess         = DVCompareOp(_ba.ST_DataValidationOperatorLessThan)
	DVCompareOpLessEqual    = DVCompareOp(_ba.ST_DataValidationOperatorLessThanOrEqual)
)

type Fill struct {
	_dbf   *_ba.CT_Fill
	_bafba *_ba.CT_Fills
}

func (_deeg Cell) setLocked(_eg bool) {
	_fbc := _deeg._eeg.SAttr
	if _fbc != nil {
		_bfdf := _deeg._agg.StyleSheet.GetCellStyle(*_fbc)
		if _bfdf._daa.Protection == nil {
			_bfdf._daa.Protection = _ba.NewCT_CellProtection()
		}
		_bfdf._daa.Protection.LockedAttr = &_eg
	}
}

// AddSheet adds a new sheet to a workbook.
func (_efag *Workbook) AddSheet() Sheet {
	_fcdg := _ba.NewCT_Sheet()
	_fcdg.SheetIdAttr = 1
	for _, _bafa := range _efag._badbd.Sheets.Sheet {
		if _fcdg.SheetIdAttr <= _bafa.SheetIdAttr {
			_fcdg.SheetIdAttr = _bafa.SheetIdAttr + 1
		}
	}
	_efag._badbd.Sheets.Sheet = append(_efag._badbd.Sheets.Sheet, _fcdg)
	_fcdg.NameAttr = _ade.Sprintf("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064", _fcdg.SheetIdAttr)
	_fgee := _ba.NewWorksheet()
	_fgee.Dimension = _ba.NewCT_SheetDimension()
	_fgee.Dimension.RefAttr = "\u0041\u0031"
	_efag._fgc = append(_efag._fgc, _fgee)
	_begd := _bfd.NewRelationships()
	_efag._gcga = append(_efag._gcga, _begd)
	_fgee.SheetData = _ba.NewCT_SheetData()
	_efag._eabg = append(_efag._eabg, nil)
	_agbe := _g.DocTypeSpreadsheet
	_cggcf := _efag._fcad.AddAutoRelationship(_agbe, _g.OfficeDocumentType, len(_efag._badbd.Sheets.Sheet), _g.WorksheetType)
	_fcdg.IdAttr = _cggcf.ID()
	_efag.ContentTypes.AddOverride(_g.AbsoluteFilename(_agbe, _g.WorksheetContentType, len(_efag._badbd.Sheets.Sheet)), _g.WorksheetContentType)
	return Sheet{_efag, _fcdg, _fgee}
}

// AddFont adds a new empty font to the stylesheet.
func (_gdfg StyleSheet) AddFont() Font {
	_fcae := _ba.NewCT_Font()
	_gdfg._gfde.Fonts.Font = append(_gdfg._gfde.Fonts.Font, _fcae)
	_gdfg._gfde.Fonts.CountAttr = _g.Uint32(uint32(len(_gdfg._gfde.Fonts.Font)))
	return Font{_fcae, _gdfg._gfde}
}

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_ggcg *Sheet) SetBorder(cellRange string, border Border) error {
	_fgbdc, _eddb, _fecc := _dg.ParseRangeReference(cellRange)
	if _fecc != nil {
		return _fecc
	}
	_faf := _ggcg._ebee.StyleSheet.AddCellStyle()
	_aeaa := _ggcg._ebee.StyleSheet.AddBorder()
	_faf.SetBorder(_aeaa)
	_aeaa._cba.Top = border._cba.Top
	_aeaa._cba.Left = border._cba.Left
	_eccc := _ggcg._ebee.StyleSheet.AddCellStyle()
	_effgd := _ggcg._ebee.StyleSheet.AddBorder()
	_eccc.SetBorder(_effgd)
	_effgd._cba.Top = border._cba.Top
	_effgd._cba.Right = border._cba.Right
	_adga := _ggcg._ebee.StyleSheet.AddCellStyle()
	_dgag := _ggcg._ebee.StyleSheet.AddBorder()
	_adga.SetBorder(_dgag)
	_dgag._cba.Top = border._cba.Top
	_ffaa := _ggcg._ebee.StyleSheet.AddCellStyle()
	_fgda := _ggcg._ebee.StyleSheet.AddBorder()
	_ffaa.SetBorder(_fgda)
	_fgda._cba.Left = border._cba.Left
	_ddeb := _ggcg._ebee.StyleSheet.AddCellStyle()
	_dfgcd := _ggcg._ebee.StyleSheet.AddBorder()
	_ddeb.SetBorder(_dfgcd)
	_dfgcd._cba.Right = border._cba.Right
	_ceef := _ggcg._ebee.StyleSheet.AddCellStyle()
	_fbgd := _ggcg._ebee.StyleSheet.AddBorder()
	_ceef.SetBorder(_fbgd)
	_fbgd._cba.Bottom = border._cba.Bottom
	_cbbcb := _ggcg._ebee.StyleSheet.AddCellStyle()
	_ffcg := _ggcg._ebee.StyleSheet.AddBorder()
	_cbbcb.SetBorder(_ffcg)
	_ffcg._cba.Bottom = border._cba.Bottom
	_ffcg._cba.Left = border._cba.Left
	_ggbea := _ggcg._ebee.StyleSheet.AddCellStyle()
	_gadf := _ggcg._ebee.StyleSheet.AddBorder()
	_ggbea.SetBorder(_gadf)
	_gadf._cba.Bottom = border._cba.Bottom
	_gadf._cba.Right = border._cba.Right
	_cggc := _fgbdc.RowIdx
	_fgbb := _fgbdc.ColumnIdx
	_dcbd := _eddb.RowIdx
	_eccf := _eddb.ColumnIdx
	for _cffgg := _cggc; _cffgg <= _dcbd; _cffgg++ {
		for _dfcg := _fgbb; _dfcg <= _eccf; _dfcg++ {
			_cgeg := _ade.Sprintf("\u0025\u0073\u0025\u0064", _dg.IndexToColumn(_dfcg), _cffgg)
			switch {
			case _cffgg == _cggc && _dfcg == _fgbb:
				_ggcg.Cell(_cgeg).SetStyle(_faf)
			case _cffgg == _cggc && _dfcg == _eccf:
				_ggcg.Cell(_cgeg).SetStyle(_eccc)
			case _cffgg == _dcbd && _dfcg == _fgbb:
				_ggcg.Cell(_cgeg).SetStyle(_cbbcb)
			case _cffgg == _dcbd && _dfcg == _eccf:
				_ggcg.Cell(_cgeg).SetStyle(_ggbea)
			case _cffgg == _cggc:
				_ggcg.Cell(_cgeg).SetStyle(_adga)
			case _cffgg == _dcbd:
				_ggcg.Cell(_cgeg).SetStyle(_ceef)
			case _dfcg == _fgbb:
				_ggcg.Cell(_cgeg).SetStyle(_ffaa)
			case _dfcg == _eccf:
				_ggcg.Cell(_cgeg).SetStyle(_ddeb)
			}
		}
	}
	return nil
}

// RemoveSheet removes the sheet with the given index from the workbook.
func (_ccag *Workbook) RemoveSheet(ind int) error {
	if _ccag.SheetCount() <= ind {
		return ErrorNotFound
	}
	for _, _edfc := range _ccag._fcad.Relationships() {
		if _edfc.ID() == _ccag._badbd.Sheets.Sheet[ind].IdAttr {
			_ccag._fcad.Remove(_edfc)
			break
		}
	}
	_ccag.ContentTypes.RemoveOverride(_g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.WorksheetContentType, ind+1))
	copy(_ccag._fgc[ind:], _ccag._fgc[ind+1:])
	_ccag._fgc = _ccag._fgc[:len(_ccag._fgc)-1]
	_daef := _ccag._badbd.Sheets.Sheet[ind]
	copy(_ccag._badbd.Sheets.Sheet[ind:], _ccag._badbd.Sheets.Sheet[ind+1:])
	_ccag._badbd.Sheets.Sheet = _ccag._badbd.Sheets.Sheet[:len(_ccag._badbd.Sheets.Sheet)-1]
	for _fada := range _ccag._badbd.Sheets.Sheet {
		if _ccag._badbd.Sheets.Sheet[_fada].SheetIdAttr > _daef.SheetIdAttr {
			_ccag._badbd.Sheets.Sheet[_fada].SheetIdAttr--
		}
	}
	copy(_ccag._gcga[ind:], _ccag._gcga[ind+1:])
	_ccag._gcga = _ccag._gcga[:len(_ccag._gcga)-1]
	copy(_ccag._eabg[ind:], _ccag._eabg[ind+1:])
	_ccag._eabg = _ccag._eabg[:len(_ccag._eabg)-1]
	return nil
}

var _dgfad = _g.AbsoluteFilename(_g.DocTypeSpreadsheet, _g.SharedStringsType, 0)

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct {
	_bfd.DocBase
	_badbd        *_ba.Workbook
	StyleSheet    StyleSheet
	SharedStrings SharedStrings
	_eabg         []*_ba.Comments
	_fgc          []*_ba.Worksheet
	_gcga         []_bfd.Relationships
	_fcad         _bfd.Relationships
	_bbf          []*_dgf.Theme
	_cbgc         []*_ea.WsDr
	_dbagc        []_bfd.Relationships
	_effd         []*_da.Container
	_bgfa         []*_ef.ChartSpace
	_eedb         []*_ba.Table
	_gff          string
}

// ClearProtection clears all workbook protections.
func (_eacb *Workbook) ClearProtection() { _eacb._badbd.WorkbookProtection = nil }
func (_cfgb DataValidation) SetComparison(t DVCompareType, op DVCompareOp) DataValidationCompare {
	_cfgb.clear()
	_cfgb._daec.TypeAttr = _ba.ST_DataValidationType(t)
	_cfgb._daec.OperatorAttr = _ba.ST_DataValidationOperator(op)
	return DataValidationCompare{_cfgb._daec}
}

// SetFont sets the font name for a rich text run.
func (_gbfg RichTextRun) SetFont(s string) {
	_gbfg.ensureRpr()
	_gbfg._fgfg.RPr.RFont = _ba.NewCT_FontName()
	_gbfg._fgfg.RPr.RFont.ValAttr = s
}

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_fc AbsoluteAnchor) SetColOffset(m _cf.Distance) {
	_fc._deb.Pos.XAttr.ST_CoordinateUnqualified = _g.Int64(int64(m / _cf.EMU))
}
func (_ebcg Fills) AddFill() Fill {
	_bcge := _ba.NewCT_Fill()
	_ebcg._caabg.Fill = append(_ebcg._caabg.Fill, _bcge)
	_ebcg._caabg.CountAttr = _g.Uint32(uint32(len(_ebcg._caabg.Fill)))
	return Fill{_bcge, _ebcg._caabg}
}

// SetHeight sets the height of the anchored object.
func (_cdb OneCellAnchor) SetHeight(h _cf.Distance) { _cdb._agc.Ext.CyAttr = int64(h / _cf.EMU) }

// SetStyle sets the cell style for an entire column.
func (_dca Column) SetStyle(cs CellStyle) { _dca._eaac.StyleAttr = _g.Uint32(cs.Index()) }

// AddHyperlink creates and sets a hyperlink on a cell.
func (_baa Cell) AddHyperlink(url string) {
	for _bcb, _bddc := range _baa._agg._fgc {
		if _bddc == _baa._afe._edeb {
			_baa.SetHyperlink(_baa._agg._gcga[_bcb].AddHyperlink(url))
			return
		}
	}
}
func (_ddcec Fill) Index() uint32 {
	if _ddcec._bafba == nil {
		return 0
	}
	for _geef, _cbcee := range _ddcec._bafba.Fill {
		if _ddcec._dbf == _cbcee {
			return uint32(_geef)
		}
	}
	return 0
}

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_bda Cell) SetBool(v bool) {
	_bda.clearValue()
	_bda._eeg.V = _g.String(_cg.Itoa(_feb(v)))
	_bda._eeg.TAttr = _ba.ST_CellTypeB
}

const (
	DVOpGreater = _ba.ST_DataValidationOperatorGreaterThanOrEqual
)

// Comments is the container for comments for a single sheet.
type Comments struct {
	_efc *Workbook
	_caa *_ba.Comments
}

// X returns the inner wrapped XML type.
func (_cce Comment) X() *_ba.CT_Comment { return _cce._fdd }
func NewFills() Fills                   { return Fills{_ba.NewCT_Fills()} }

// GetOrCreateCustomProperties returns the custom properties of the document (and if they not exist yet, creating them first)
func (_aega *Workbook) GetOrCreateCustomProperties() _bfd.CustomProperties {
	if _aega.CustomProperties.X() == nil {
		_aega.createCustomProperties()
	}
	return _aega.CustomProperties
}

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_cdbg *Workbook) RemoveCalcChain() {
	var _cafb string
	for _, _ffbd := range _cdbg._fcad.Relationships() {
		if _ffbd.Type() == "ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e" {
			_cafb = "\u0078\u006c\u002f" + _ffbd.Target()
			_cdbg._fcad.Remove(_ffbd)
			break
		}
	}
	if _cafb == "" {
		return
	}
	_cdbg.ContentTypes.RemoveOverride(_cafb)
	for _gefa, _ffbc := range _cdbg.ExtraFiles {
		if _ffbc.ZipPath == _cafb {
			_cdbg.ExtraFiles[_gefa] = _cdbg.ExtraFiles[len(_cdbg.ExtraFiles)-1]
			_cdbg.ExtraFiles = _cdbg.ExtraFiles[:len(_cdbg.ExtraFiles)-1]
			return
		}
	}
}

// Fonts returns the list of fonts defined in the stylesheet.
func (_bddfa StyleSheet) Fonts() []Font {
	_efae := []Font{}
	for _, _afcg := range _bddfa._gfde.Fonts.Font {
		_efae = append(_efae, Font{_afcg, _bddfa._gfde})
	}
	return _efae
}
func (_gf Border) SetTop(style _ba.ST_BorderStyle, c _gb.Color) {
	if _gf._cba.Top == nil {
		_gf._cba.Top = _ba.NewCT_BorderPr()
	}
	_gf._cba.Top.Color = _ba.NewCT_Color()
	_gf._cba.Top.Color.RgbAttr = c.AsRGBAString()
	_gf._cba.Top.StyleAttr = style
}

// Border is a cell border configuraton.
type Border struct {
	_cba *_ba.CT_Border
	_dae *_ba.CT_Borders
}

// SetWidth sets the width of the anchored object.
func (_dgdg OneCellAnchor) SetWidth(w _cf.Distance) { _dgdg._agc.Ext.CxAttr = int64(w / _cf.EMU) }

// X returns the inner wrapped XML type.
func (_ggb ConditionalFormattingRule) X() *_ba.CT_CfRule { return _ggb._bcca }

// SetHidden hides or unhides the row
func (_bdef Row) SetHidden(hidden bool) {
	if !hidden {
		_bdef._agbf.HiddenAttr = nil
	} else {
		_bdef._agbf.HiddenAttr = _g.Bool(true)
	}
}

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_egdc *Sheet) Sort(column string, firstRow uint32, order SortOrder) {
	_dgeg := _egdc._edeb.SheetData.Row
	_ggfc := _egdc.Rows()
	for _bcag, _acff := range _ggfc {
		if _acff.RowNumber() == firstRow {
			_dgeg = _egdc._edeb.SheetData.Row[_bcag:]
			break
		}
	}
	_aaff := Comparer{Order: order}
	_f.Slice(_dgeg, func(_dfac, _daea int) bool {
		return _aaff.LessRows(column, Row{_egdc._ebee, _egdc, _dgeg[_dfac]}, Row{_egdc._ebee, _egdc, _dgeg[_daea]})
	})
	for _aed, _dcfc := range _egdc.Rows() {
		_agbc := uint32(_aed + 1)
		if _dcfc.RowNumber() != _agbc {
			_dcfc.renumberAs(_agbc)
		}
	}
}

// X returns the inner wrapped XML type.
func (_bec Row) X() *_ba.CT_Row { return _bec._agbf }

// GetValueAsBool retrieves the cell's value as a boolean
func (_cbbc Cell) GetValueAsBool() (bool, error) {
	if _cbbc._eeg.TAttr != _ba.ST_CellTypeB {
		return false, _de.New("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065")
	}
	if _cbbc._eeg.V == nil {
		return false, _de.New("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065")
	}
	return _cg.ParseBool(*_cbbc._eeg.V)
}

// DataValidation controls cell validation
type DataValidation struct{ _daec *_ba.CT_DataValidation }

// IsError returns true if the cell is an error type cell.
func (_ede Cell) IsError() bool { return _ede._eeg.TAttr == _ba.ST_CellTypeE }

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_gbba DataValidationList) SetRange(cellRange string) {
	_gbba._dddf.Formula1 = _g.String(cellRange)
	_gbba._dddf.Formula2 = _g.String("\u0030")
}

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_cdgc StyleSheet) RemoveFont(f Font) error {
	for _eacga, _dggeb := range _cdgc._gfde.Fonts.Font {
		if _dggeb == f.X() {
			_cdgc._gfde.Fonts.Font = append(_cdgc._gfde.Fonts.Font[:_eacga], _cdgc._gfde.Fonts.Font[_eacga+1:]...)
			return nil
		}
	}
	return _de.New("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// X returns the inner wrapped XML type.
func (_aca DataValidation) X() *_ba.CT_DataValidation { return _aca._daec }

// Col returns the column of the cell marker.
func (_egd CellMarker) Col() int32 { return _egd._ccb.Col }

// SetColOffset sets a column offset in absolute distance.
func (_dbb CellMarker) SetColOffset(m _cf.Distance) {
	_dbb._ccb.ColOff.ST_CoordinateUnqualified = _g.Int64(int64(m / _cf.EMU))
}

// LockWindow controls the locking of the workbook windows.
func (_ebac WorkbookProtection) LockWindow(b bool) {
	if !b {
		_ebac._aba.LockWindowsAttr = nil
	} else {
		_ebac._aba.LockWindowsAttr = _g.Bool(true)
	}
}

// ClearBorder clears any border configuration from the cell style.
func (_gbd CellStyle) ClearBorder() { _gbd._daa.BorderIdAttr = nil; _gbd._daa.ApplyBorderAttr = nil }

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_egb DataValidationCompare) SetValue(v string) { _egb._bgdf.Formula1 = &v }

// MergedCells returns the merged cell regions within the sheet.
func (_fgeaa *Sheet) MergedCells() []MergedCell {
	if _fgeaa._edeb.MergeCells == nil {
		return nil
	}
	_faba := []MergedCell{}
	for _, _gedcb := range _fgeaa._edeb.MergeCells.MergeCell {
		_faba = append(_faba, MergedCell{_fgeaa._ebee, _fgeaa, _gedcb})
	}
	return _faba
}

// GetString retrieves a string from the shared strings table by index.
func (_cfggb SharedStrings) GetString(id int) (string, error) {
	if id < 0 {
		return "", _ade.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030", id)
	}
	if id > len(_cfggb._faeg.Si) {
		return "", _ade.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073", id, len(_cfggb._faeg.Si))
	}
	_eacd := _cfggb._faeg.Si[id]
	if _eacd.T != nil {
		return *_eacd.T, nil
	}
	return "", nil
}

// SetHidden marks the defined name as hidden.
func (_cbce DefinedName) SetHidden(b bool) { _cbce._dcd.HiddenAttr = _g.Bool(b) }

// MakeComments constructs a new Comments wrapper.
func MakeComments(w *Workbook, x *_ba.Comments) Comments { return Comments{w, x} }

// SetError sets the cell type to error and the value to the given error message.
func (_cge Cell) SetError(msg string) {
	_cge.clearValue()
	_cge._eeg.V = _g.String(msg)
	_cge._eeg.TAttr = _ba.ST_CellTypeE
}

// MoveTo repositions the anchor without changing the objects size.
func (_feac TwoCellAnchor) MoveTo(col, row int32) {
	_baea := _feac.TopLeft()
	_dcebe := _feac.BottomRight()
	_fdefg := _dcebe.Col() - _baea.Col()
	_bgaf := _dcebe.Row() - _baea.Row()
	_baea.SetCol(col)
	_baea.SetRow(row)
	_dcebe.SetCol(col + _fdefg)
	_dcebe.SetRow(row + _bgaf)
}

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_ffac *Workbook) CopySheetByName(name, copiedSheetName string) (Sheet, error) {
	_ffdda := -1
	for _gdad, _eaebc := range _ffac.Sheets() {
		if name == _eaebc.Name() {
			_ffdda = _gdad
			break
		}
	}
	if _ffdda == -1 {
		return Sheet{}, ErrorNotFound
	}
	return _ffac.CopySheet(_ffdda, copiedSheetName)
}

// AddGradientStop adds a color gradient stop.
func (_aeb ColorScale) AddGradientStop(color _gb.Color) {
	_gece := _ba.NewCT_Color()
	_gece.RgbAttr = color.AsRGBAString()
	_aeb._dgec.Color = append(_aeb._dgec.Color, _gece)
}

// TopLeft is a no-op.
func (_bc AbsoluteAnchor) TopLeft() CellMarker { return CellMarker{} }

// SetWidthCells is a no-op.
func (_eb AbsoluteAnchor) SetWidthCells(int32) {}

// Type returns the type of anchor
func (_fbebb TwoCellAnchor) Type() AnchorType { return AnchorTypeTwoCell }

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_bad ConditionalFormattingRule) SetIcons() IconScale {
	_bad.clear()
	_bad.SetType(_ba.ST_CfTypeIconSet)
	_bad._bcca.IconSet = _ba.NewCT_IconSet()
	_acdc := IconScale{_bad._bcca.IconSet}
	_acdc.SetIcons(_ba.ST_IconSetType3TrafficLights1)
	return _acdc
}

// IsHidden returns whether the row is hidden or not.
func (_acgeb Row) IsHidden() bool { return _acgeb._agbf.HiddenAttr != nil && *_acgeb._agbf.HiddenAttr }

const _dcbg = "\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067"

// CellMarker represents a cell position
type CellMarker struct{ _ccb *_ea.CT_Marker }

// AddString adds a string to the shared string cache.
func (_aaaa SharedStrings) AddString(v string) int {
	if _egde, _afbb := _aaaa._ceae[v]; _afbb {
		return _egde
	}
	_ebceb := _ba.NewCT_Rst()
	_ebceb.T = _g.String(v)
	_aaaa._faeg.Si = append(_aaaa._faeg.Si, _ebceb)
	_fgfb := len(_aaaa._faeg.Si) - 1
	_aaaa._ceae[v] = _fgfb
	_aaaa._faeg.CountAttr = _g.Uint32(uint32(len(_aaaa._faeg.Si)))
	_aaaa._faeg.UniqueCountAttr = _aaaa._faeg.CountAttr
	return _fgfb
}

// IsEmpty returns true if the cell is empty.
func (_ccd Cell) IsEmpty() bool {
	return _ccd._eeg.TAttr == _ba.ST_CellTypeUnset && _ccd._eeg.V == nil && _ccd._eeg.F == nil
}
func (_bcfcd *evalContext) SetOffset(col, row uint32) { _bcfcd._efe = col; _bcfcd._ecad = row }

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32

// Cell is a single cell within a sheet.
type Cell struct {
	_agg *Workbook
	_afe *Sheet
	_adg *_ba.CT_Row
	_eeg *_ba.CT_Cell
}

// X returns the inner wrapped XML type.
func (_acce Drawing) X() *_ea.WsDr { return _acce._bacd }

// IsStructureLocked returns whether the workbook structure is locked.
func (_agfg WorkbookProtection) IsStructureLocked() bool {
	return _agfg._aba.LockStructureAttr != nil && *_agfg._aba.LockStructureAttr
}
func (_cdfc DataValidation) SetList() DataValidationList {
	_cdfc.clear()
	_cdfc._daec.TypeAttr = _ba.ST_DataValidationTypeList
	_cdfc._daec.OperatorAttr = _ba.ST_DataValidationOperatorEqual
	return DataValidationList{_cdfc._daec}
}

// SetColor sets teh color of the databar.
func (_fdc DataBarScale) SetColor(c _gb.Color) {
	_fdc._abb.Color = _ba.NewCT_Color()
	_fdc._abb.Color.RgbAttr = c.AsRGBAString()
}

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_cdaf *Workbook) GetFilename() string { return _cdaf._gff }

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_add Cell) SetStringByID(id int) {
	_add._agg.ensureSharedStringsRelationships()
	_add.clearValue()
	_add._eeg.V = _g.String(_cg.Itoa(id))
	_add._eeg.TAttr = _ba.ST_CellTypeS
}
func (_beb *evalContext) NamedRange(ref string) _cgd.Reference {
	for _, _acb := range _beb._abgg._ebee.DefinedNames() {
		if _acb.Name() == ref {
			return _cgd.MakeRangeReference(_acb.Content())
		}
	}
	for _, _geaa := range _beb._abgg._ebee.Tables() {
		if _geaa.Name() == ref {
			return _cgd.MakeRangeReference(_ade.Sprintf("\u0025\u0073\u0021%\u0073", _beb._abgg.Name(), _geaa.Reference()))
		}
	}
	return _cgd.ReferenceInvalid
}

// SaveToFile writes the workbook out to a file.
func (_bcbc *Workbook) SaveToFile(path string) error {
	_fbff, _ggde := _af.Create(path)
	if _ggde != nil {
		return _ggde
	}
	defer _fbff.Close()
	return _bcbc.Save(_fbff)
}

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_dadc *Sheet) InitialView() SheetView {
	if _dadc._edeb.SheetViews == nil || len(_dadc._edeb.SheetViews.SheetView) == 0 {
		return _dadc.AddView()
	}
	return SheetView{_dadc._edeb.SheetViews.SheetView[0]}
}

type MergedCell struct {
	_bdbe *Workbook
	_ffg  *Sheet
	_ddgc *_ba.CT_MergeCell
}

// GetWidth returns a worksheet's column width.
func (_adeg *evalContext) GetWidth(colIdx int) float64 {
	colIdx++
	for _, _ccg := range _adeg._abgg.X().Cols[0].Col {
		if int(_ccg.MinAttr) <= colIdx && colIdx <= int(_ccg.MaxAttr) {
			return float64(int(*_ccg.WidthAttr))
		}
	}
	return 0
}

// HasFormula returns true if the cell has an asoociated formula.
func (_gcgc Cell) HasFormula() bool { return _gcgc._eeg.F != nil }

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet(wb *Workbook) StyleSheet {
	_agfa := _ba.NewStyleSheet()
	_agfa.CellStyleXfs = _ba.NewCT_CellStyleXfs()
	_agfa.CellXfs = _ba.NewCT_CellXfs()
	_agfa.CellStyles = _ba.NewCT_CellStyles()
	_cfccb := _ba.NewCT_CellStyle()
	_cfccb.NameAttr = _g.String("\u004e\u006f\u0072\u006d\u0061\u006c")
	_cfccb.XfIdAttr = 0
	_cfccb.BuiltinIdAttr = _g.Uint32(0)
	_agfa.CellStyles.CellStyle = append(_agfa.CellStyles.CellStyle, _cfccb)
	_agfa.CellStyles.CountAttr = _g.Uint32(uint32(len(_agfa.CellStyles.CellStyle)))
	_cadg := _ba.NewCT_Xf()
	_cadg.NumFmtIdAttr = _g.Uint32(0)
	_cadg.FontIdAttr = _g.Uint32(0)
	_cadg.FillIdAttr = _g.Uint32(0)
	_cadg.BorderIdAttr = _g.Uint32(0)
	_agfa.CellStyleXfs.Xf = append(_agfa.CellStyleXfs.Xf, _cadg)
	_agfa.CellStyleXfs.CountAttr = _g.Uint32(uint32(len(_agfa.CellStyleXfs.Xf)))
	_gdgc := NewFills()
	_agfa.Fills = _gdgc.X()
	_abce := _gdgc.AddFill().SetPatternFill()
	_abce.SetPattern(_ba.ST_PatternTypeNone)
	_abce = _gdgc.AddFill().SetPatternFill()
	_abce.SetPattern(_ba.ST_PatternTypeGray125)
	_agfa.Fonts = _ba.NewCT_Fonts()
	_agfa.Borders = _ba.NewCT_Borders()
	_fdbd := StyleSheet{wb, _agfa}
	_fdbd.AddBorder().InitializeDefaults()
	_cebc := _fdbd.AddFont()
	_cebc.SetName("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_cebc.SetSize(11)
	_fbge := _ba.NewCT_Xf()
	*_fbge = *_cadg
	_fbge.XfIdAttr = _g.Uint32(0)
	_agfa.CellXfs.Xf = append(_agfa.CellXfs.Xf, _fbge)
	_agfa.CellXfs.CountAttr = _g.Uint32(uint32(len(_agfa.CellXfs.Xf)))
	return _fdbd
}

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_ddfc Sheet) RangeReference(n string) string {
	_agdg := _d.Split(n, "\u003a")
	_agdgg, _ := _dg.ParseCellReference(_agdg[0])
	_fefa := _ade.Sprintf("\u0024\u0025\u0073\u0024\u0025\u0064", _agdgg.Column, _agdgg.RowIdx)
	if len(_agdg) == 1 {
		return _ade.Sprintf("\u0027%\u0073\u0027\u0021\u0025\u0073", _ddfc.Name(), _fefa)
	}
	_cacd, _ := _dg.ParseCellReference(_agdg[1])
	_gfgc := _ade.Sprintf("\u0024\u0025\u0073\u0024\u0025\u0064", _cacd.Column, _cacd.RowIdx)
	return _ade.Sprintf("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073", _ddfc.Name(), _fefa, _gfgc)
}
func (_fdec StyleSheet) GetNumberFormat(id uint32) NumberFormat {
	if id >= 0 && id < 50 {
		return CreateDefaultNumberFormat(StandardFormat(id))
	}
	for _, _bbdd := range _fdec._gfde.NumFmts.NumFmt {
		if _bbdd.NumFmtIdAttr == id {
			return NumberFormat{_fdec._aced, _bbdd}
		}
	}
	return NumberFormat{}
}

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_gaa Cell) SetRichTextString() RichText {
	_gaa.clearValue()
	_gaa._eeg.Is = _ba.NewCT_Rst()
	_gaa._eeg.TAttr = _ba.ST_CellTypeInlineStr
	return RichText{_gaa._eeg.Is}
}

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_ggg *Workbook) Uses1904Dates() bool {
	if _ggg._badbd.WorkbookPr == nil || _ggg._badbd.WorkbookPr.Date1904Attr == nil {
		return false
	}
	return *_ggg._badbd.WorkbookPr.Date1904Attr
}

// Wrapped returns true if the cell will wrap text.
func (_eca CellStyle) Wrapped() bool {
	if _eca._daa.Alignment == nil {
		return false
	}
	if _eca._daa.Alignment.WrapTextAttr == nil {
		return false
	}
	return *_eca._daa.Alignment.WrapTextAttr
}

// DefinedNames returns a slice of all defined names in the workbook.
func (_dfbbc *Workbook) DefinedNames() []DefinedName {
	if _dfbbc._badbd.DefinedNames == nil {
		return nil
	}
	_eeca := []DefinedName{}
	for _, _fgdf := range _dfbbc._badbd.DefinedNames.DefinedName {
		_eeca = append(_eeca, DefinedName{_fgdf})
	}
	return _eeca
}

// AddRun adds a new run of text to the cell.
func (_adfe RichText) AddRun() RichTextRun {
	_ggea := _ba.NewCT_RElt()
	_adfe._aef.R = append(_adfe._aef.R, _ggea)
	return RichTextRun{_ggea}
}

// Sheet is a single sheet within a workbook.
type Sheet struct {
	_ebee *Workbook
	_ggeg *_ba.CT_Sheet
	_edeb *_ba.Worksheet
}

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_bcgec Row) RowNumber() uint32 {
	if _bcgec._agbf.RAttr != nil {
		return *_bcgec._agbf.RAttr
	}
	return 0
}

// SetFill applies a fill to a cell style.  The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_fab CellStyle) SetFill(f Fill) {
	_fab._daa.FillIdAttr = _g.Uint32(f.Index())
	_fab._daa.ApplyFillAttr = _g.Bool(true)
}

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_cab *Sheet) AddRow() Row {
	_aadd := uint32(0)
	_bcd := uint32(len(_cab._edeb.SheetData.Row))
	if _bcd > 0 && _cab._edeb.SheetData.Row[_bcd-1].RAttr != nil && *_cab._edeb.SheetData.Row[_bcd-1].RAttr == _bcd {
		return _cab.addNumberedRowFast(_bcd + 1)
	}
	for _, _cgad := range _cab._edeb.SheetData.Row {
		if _cgad.RAttr != nil && *_cgad.RAttr > _aadd {
			_aadd = *_cgad.RAttr
		}
	}
	return _cab.AddNumberedRow(_aadd + 1)
}

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_bdbf *Sheet) FormulaContext() _cgd.Context { return _daee(_bdbf) }
func (_ffd PatternFill) SetBgColor(c _gb.Color) {
	_ffd._fefe.BgColor = _ba.NewCT_Color()
	_ffd._fefe.BgColor.RgbAttr = c.AsRGBAString()
}

// X returns the inner wrapped XML type.
func (_ddg CellMarker) X() *_ea.CT_Marker { return _ddg._ccb }

// SetText sets the text to be displayed.
func (_cdae RichTextRun) SetText(s string) { _cdae._fgfg.T = s }

// InitializeDefaults initializes a border to its defaulte empty values.
func (_ab Border) InitializeDefaults() {
	_ab._cba.Left = _ba.NewCT_BorderPr()
	_ab._cba.Bottom = _ba.NewCT_BorderPr()
	_ab._cba.Right = _ba.NewCT_BorderPr()
	_ab._cba.Top = _ba.NewCT_BorderPr()
	_ab._cba.Diagonal = _ba.NewCT_BorderPr()
}

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_befg Comment) SetAuthor(author string) {
	_befg._fdd.AuthorIdAttr = Comments{_befg._gcbe, _befg._aaf}.getOrCreateAuthor(author)
}

type SheetProtection struct{ _baca *_ba.CT_SheetProtection }

func (_daeb CellStyle) SetNumberFormat(s string) {
	_ffe := _daeb._fga.StyleSheet.AddNumberFormat()
	_ffe.SetFormat(s)
	_daeb._daa.ApplyNumberFormatAttr = _g.Bool(true)
	_daeb._daa.NumFmtIdAttr = _g.Uint32(_ffe.ID())
}

// Cell returns the actual cell behind the merged region
func (_fgeg MergedCell) Cell() Cell {
	_fdefe := _fgeg.Reference()
	if _ffb := _d.Index(_fgeg.Reference(), "\u003a"); _ffb != -1 {
		_fdefe = _fdefe[0:_ffb]
		return _fgeg._ffg.Cell(_fdefe)
	}
	return Cell{}
}

// X returns the inner wrapped XML type.
func (_edc Comments) X() *_ba.Comments { return _edc._caa }

// BottomRight is a no-op.
func (_dd AbsoluteAnchor) BottomRight() CellMarker { return CellMarker{} }
func (_eaed StyleSheet) GetCellStyle(id uint32) CellStyle {
	for _abbc, _bceg := range _eaed._gfde.CellXfs.Xf {
		if uint32(_abbc) == id {
			return CellStyle{_eaed._aced, _bceg, _eaed._gfde.CellXfs}
		}
	}
	return CellStyle{}
}

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{ _aef *_ba.CT_Rst }

func (_afed *Sheet) slideCellsLeft(_aeaae []*_ba.CT_Cell) []*_ba.CT_Cell {
	for _, _fbba := range _aeaae {
		_ggead, _dfefd := _dg.ParseCellReference(*_fbba.RAttr)
		if _dfefd != nil {
			return _aeaae
		}
		_fcbc := _ggead.ColumnIdx - 1
		_gead := _dg.IndexToColumn(_fcbc) + _ade.Sprintf("\u0025\u0064", _ggead.RowIdx)
		_fbba.RAttr = &_gead
	}
	return _aeaae
}

// MaxColumnIdx returns the max used column of the sheet.
func (_dbed Sheet) MaxColumnIdx() uint32 {
	_fbdeg := uint32(0)
	for _, _afeb := range _dbed.Rows() {
		_cgcce := _afeb._agbf.C
		if len(_cgcce) > 0 {
			_aaed := _cgcce[len(_cgcce)-1]
			_dgee, _ := _dg.ParseCellReference(*_aaed.RAttr)
			if _fbdeg < _dgee.ColumnIdx {
				_fbdeg = _dgee.ColumnIdx
			}
		}
	}
	return _fbdeg
}

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_fgbg TwoCellAnchor) SetWidthCells(w int32) {
	_aedc := _fgbg.TopLeft()
	_bbbc := _fgbg.BottomRight()
	_bbbc.SetCol(_aedc.Col() + w)
}

// SetRowOffset sets a column offset in absolute distance.
func (_egc CellMarker) SetRowOffset(m _cf.Distance) {
	_egc._ccb.RowOff.ST_CoordinateUnqualified = _g.Int64(int64(m / _cf.EMU))
}
func (_fbcg *Sheet) updateAfterRemove(_acea uint32, _gcfd _cfa.UpdateAction) error {
	_bbae := _fbcg.Name()
	_gdf := &_cfa.UpdateQuery{UpdateType: _gcfd, ColumnIdx: _acea, SheetToUpdate: _bbae}
	for _, _dgba := range _fbcg._ebee.Sheets() {
		_gdf.UpdateCurrentSheet = _bbae == _dgba.Name()
		for _, _bbcd := range _dgba.Rows() {
			for _, _fdeg := range _bbcd.Cells() {
				if _fdeg.X().F != nil {
					_dgge := _fdeg.X().F.Content
					_efdef := _cgd.ParseString(_dgge)
					if _efdef == nil {
						_fdeg.SetError("\u0023\u0052\u0045F\u0021")
					} else {
						_ffga := _efdef.Update(_gdf)
						_fdeg.X().F.Content = _ade.Sprintf("\u003d\u0025\u0073", _ffga.String())
					}
				}
			}
		}
	}
	return nil
}
func (_deeb SheetView) ensurePane() {
	if _deeb._adgd.Pane == nil {
		_deeb._adgd.Pane = _ba.NewCT_Pane()
		_deeb._adgd.Pane.ActivePaneAttr = _ba.ST_PaneBottomLeft
	}
}

// PasswordHash returns the hash of the workbook password.
func (_ebgab WorkbookProtection) PasswordHash() string {
	if _ebgab._aba.WorkbookPasswordAttr == nil {
		return ""
	}
	return *_ebgab._aba.WorkbookPasswordAttr
}

// SetValues sets the possible values. This is incompatible with SetRange.
func (_ead DataValidationList) SetValues(values []string) {
	_ead._dddf.Formula1 = _g.String("\u0022" + _d.Join(values, "\u002c") + "\u0022")
	_ead._dddf.Formula2 = _g.String("\u0030")
}

// SetMaxLength sets the maximum bar length in percent.
func (_agb DataBarScale) SetMaxLength(l uint32) { _agb._abb.MaxLengthAttr = _g.Uint32(l) }

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_bdbcc StyleSheet) AddNumberFormat() NumberFormat {
	if _bdbcc._gfde.NumFmts == nil {
		_bdbcc._gfde.NumFmts = _ba.NewCT_NumFmts()
	}
	_cgadg := _ba.NewCT_NumFmt()
	_cgadg.NumFmtIdAttr = uint32(200 + len(_bdbcc._gfde.NumFmts.NumFmt))
	_bdbcc._gfde.NumFmts.NumFmt = append(_bdbcc._gfde.NumFmts.NumFmt, _cgadg)
	_bdbcc._gfde.NumFmts.CountAttr = _g.Uint32(uint32(len(_bdbcc._gfde.NumFmts.NumFmt)))
	return NumberFormat{_bdbcc._aced, _cgadg}
}
func (_gae Font) SetItalic(b bool) {
	if b {
		_gae._gcc.I = []*_ba.CT_BooleanProperty{{}}
	} else {
		_gae._gcc.I = nil
	}
}

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{ _deb *_ea.CT_AbsoluteAnchor }

// SetXSplit sets the column split point
func (_eafd SheetView) SetXSplit(v float64) {
	_eafd.ensurePane()
	_eafd._adgd.Pane.XSplitAttr = _g.Float64(v)
}

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_egg Comment) CellReference() string { return _egg._fdd.RefAttr }

// SetYSplit sets the row split point
func (_acbc SheetView) SetYSplit(v float64) {
	_acbc.ensurePane()
	_acbc._adgd.Pane.YSplitAttr = _g.Float64(v)
}

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_abde *Workbook) Epoch() _ag.Time {
	if _abde.Uses1904Dates() {
		_ag.Date(1904, 1, 1, 0, 0, 0, 0, _ag.UTC)
	}
	return _ag.Date(1899, 12, 30, 0, 0, 0, 0, _ag.UTC)
}
func (_dcg Fills) X() *_ba.CT_Fills { return _dcg._caabg }

// SetShowRuler controls the visibility of the ruler
func (_bbgd SheetView) SetShowRuler(b bool) {
	if !b {
		_bbgd._adgd.ShowRulerAttr = _g.Bool(false)
	} else {
		_bbgd._adgd.ShowRulerAttr = nil
	}
}

// MoveTo moves the top-left of the anchored object.
func (_fbde OneCellAnchor) MoveTo(col, row int32) {
	_fbde.TopLeft().SetCol(col)
	_fbde.TopLeft().SetRow(row)
}

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_caac Comments) AddComment(cellRef string, author string) RichText {
	_ebeb := _ba.NewCT_Comment()
	_caac._caa.CommentList.Comment = append(_caac._caa.CommentList.Comment, _ebeb)
	_ebeb.RefAttr = cellRef
	_ebeb.AuthorIdAttr = _caac.getOrCreateAuthor(author)
	_ebeb.Text = _ba.NewCT_Rst()
	return RichText{_ebeb.Text}
}
func (_eege DifferentialStyle) Fill() Fill {
	if _eege._geff.Fill == nil {
		_eege._geff.Fill = _ba.NewCT_Fill()
	}
	return Fill{_eege._geff.Fill, nil}
}
func (_age Comments) getOrCreateAuthor(_egfe string) uint32 {
	for _ebc, _cgf := range _age._caa.Authors.Author {
		if _cgf == _egfe {
			return uint32(_ebc)
		}
	}
	_dda := uint32(len(_age._caa.Authors.Author))
	_age._caa.Authors.Author = append(_age._caa.Authors.Author, _egfe)
	return _dda
}
