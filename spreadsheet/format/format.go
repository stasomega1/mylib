//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format

import (
	_bf "bytes"
	_b "fmt"
	_f "github.com/unidoc/unioffice"
	_d "io"
	_a "math"
	_bb "strconv"
	_eb "strings"
	_e "time"
)

func _caa(_bae float64) string {
	_fgb := _bb.FormatFloat(_bae, 'E', -1, 64)
	_fcb := _bb.FormatFloat(_bae, 'E', 5, 64)
	if len(_fgb) < len(_fcb) {
		return _bb.FormatFloat(_bae, 'E', 2, 64)
	}
	return _fcb
}

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte

const (
	FmtTypeLiteral FmtType = iota
	FmtTypeDigit
	FmtTypeDigitOpt
	FmtTypeComma
	FmtTypeDecimal
	FmtTypePercent
	FmtTypeDollar
	FmtTypeDigitOptThousands
	FmtTypeUnderscore
	FmtTypeDate
	FmtTypeTime
	FmtTypeFraction
	FmtTypeText
)

func _ddf(_aec []byte) []byte {
	for _dgd := len(_aec) - 1; _dgd > 0; _dgd-- {
		if _aec[_dgd] == '9'+1 {
			_aec[_dgd] = '0'
			if _aec[_dgd-1] == '.' {
				_dgd--
			}
			_aec[_dgd-1]++
		}
	}
	if _aec[0] == '9'+1 {
		_aec[0] = '0'
		copy(_aec[1:], _aec[0:])
		_aec[0] = '1'
	}
	return _aec
}

const _be = 1e-10

func _fag(_beg []byte) []byte {
	_fae := len(_beg)
	_adag := false
	_bff := false
	for _bga := len(_beg) - 1; _bga >= 0; _bga-- {
		if _beg[_bga] == '0' && !_bff && !_adag {
			_fae = _bga
		} else if _beg[_bga] == '.' {
			_adag = true
		} else {
			_bff = true
		}
	}
	if _adag && _bff {
		if _beg[_fae-1] == '.' {
			_fae--
		}
		return _beg[0:_fae]
	}
	return _beg
}

var _bc = [...]uint8{0, 14, 26, 41, 53, 67, 81, 94, 118, 135, 146, 157, 172, 183}

const _fdcb int = 0
const _cca int = 0

func _ced(_bec []byte) []byte {
	for _faf := 0; _faf < len(_bec)/2; _faf++ {
		_gf := len(_bec) - 1 - _faf
		_bec[_faf], _bec[_gf] = _bec[_gf], _bec[_faf]
	}
	return _bec
}
func _bcfg(_ebfd _e.Time) _e.Time {
	_ebfd = _ebfd.UTC()
	return _e.Date(_ebfd.Year(), _ebfd.Month(), _ebfd.Day(), _ebfd.Hour(), _ebfd.Minute(), _ebfd.Second(), _ebfd.Nanosecond(), _e.Local)
}
func _bgc(_fagd _e.Time, _cae float64, _cba string) []byte {
	_aggf := []byte{}
	_bfg := 0
	for _ceb := 0; _ceb < len(_cba); _ceb++ {
		var _bgg string
		if _cba[_ceb] == ':' {
			_bgg = string(_cba[_bfg:_ceb])
			_bfg = _ceb + 1
		} else if _ceb == len(_cba)-1 {
			_bgg = string(_cba[_bfg : _ceb+1])
		} else {
			continue
		}
		switch _bgg {
		case "\u0064":
			_aggf = _fagd.AppendFormat(_aggf, "\u0032")
		case "\u0068":
			_aggf = _fagd.AppendFormat(_aggf, "\u0033")
		case "\u0068\u0068":
			_aggf = _fagd.AppendFormat(_aggf, "\u0031\u0035")
		case "\u006d":
			_aggf = _fagd.AppendFormat(_aggf, "\u0034")
		case "\u006d\u006d":
			_aggf = _fagd.AppendFormat(_aggf, "\u0030\u0034")
		case "\u0073":
			_aggf = _fagd.Round(_e.Second).AppendFormat(_aggf, "\u0035")
		case "\u0073\u002e\u0030":
			_aggf = _fagd.Round(_e.Second/10).AppendFormat(_aggf, "\u0035\u002e\u0030")
		case "\u0073\u002e\u0030\u0030":
			_aggf = _fagd.Round(_e.Second/100).AppendFormat(_aggf, "\u0035\u002e\u0030\u0030")
		case "\u0073\u002e\u00300\u0030":
			_aggf = _fagd.Round(_e.Second/1000).AppendFormat(_aggf, "\u0035\u002e\u00300\u0030")
		case "\u0073\u0073":
			_aggf = _fagd.Round(_e.Second).AppendFormat(_aggf, "\u0030\u0035")
		case "\u0073\u0073\u002e\u0030":
			_aggf = _fagd.Round(_e.Second/10).AppendFormat(_aggf, "\u0030\u0035\u002e\u0030")
		case "\u0073\u0073\u002e0\u0030":
			_aggf = _fagd.Round(_e.Second/100).AppendFormat(_aggf, "\u0030\u0035\u002e0\u0030")
		case "\u0073\u0073\u002e\u0030\u0030\u0030":
			_aggf = _fagd.Round(_e.Second/1000).AppendFormat(_aggf, "\u0030\u0035\u002e\u0030\u0030\u0030")
		case "\u0041\u004d\u002fP\u004d":
			_aggf = _fagd.AppendFormat(_aggf, "\u0050\u004d")
		case "\u005b\u0068\u005d":
			_aggf = _bb.AppendInt(_aggf, int64(_cae*24), 10)
		case "\u005b\u006d\u005d":
			_aggf = _bb.AppendInt(_aggf, int64(_cae*24*60), 10)
		case "\u005b\u0073\u005d":
			_aggf = _bb.AppendInt(_aggf, int64(_cae*24*60*60), 10)
		case "":
		default:
			_f.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073", _bgg)
		}
		if _cba[_ceb] == ':' {
			_aggf = append(_aggf, ':')
		}
	}
	return _aggf
}

const _cag int = 0

func _cfe(_fdc int64) int64 {
	if _fdc < 0 {
		return -_fdc
	}
	return _fdc
}

const _bbg int = 34

func _ecf(_ef _e.Time, _aea string) []byte {
	_acf := []byte{}
	_ggag := 0
	for _beaa := 0; _beaa < len(_aea); _beaa++ {
		var _cfa string
		if _aea[_beaa] == '/' {
			_cfa = string(_aea[_ggag:_beaa])
			_ggag = _beaa + 1
		} else if _beaa == len(_aea)-1 {
			_cfa = string(_aea[_ggag : _beaa+1])
		} else {
			continue
		}
		switch _cfa {
		case "\u0079\u0079":
			_acf = _ef.AppendFormat(_acf, "\u0030\u0036")
		case "\u0079\u0079\u0079\u0079":
			_acf = _ef.AppendFormat(_acf, "\u0032\u0030\u0030\u0036")
		case "\u006d":
			_acf = _ef.AppendFormat(_acf, "\u0031")
		case "\u006d\u006d":
			_acf = _ef.AppendFormat(_acf, "\u0030\u0031")
		case "\u006d\u006d\u006d":
			_acf = _ef.AppendFormat(_acf, "\u004a\u0061\u006e")
		case "\u006d\u006d\u006d\u006d":
			_acf = _ef.AppendFormat(_acf, "\u004aa\u006e\u0075\u0061\u0072\u0079")
		case "\u006d\u006d\u006dm\u006d":
			switch _ef.Month() {
			case _e.January, _e.July, _e.June:
				_acf = append(_acf, 'J')
			case _e.February:
				_acf = append(_acf, 'M')
			case _e.March, _e.May:
				_acf = append(_acf, 'M')
			case _e.April, _e.August:
				_acf = append(_acf, 'A')
			case _e.September:
				_acf = append(_acf, 'S')
			case _e.October:
				_acf = append(_acf, 'O')
			case _e.November:
				_acf = append(_acf, 'N')
			case _e.December:
				_acf = append(_acf, 'D')
			}
		case "\u0064":
			_acf = _ef.AppendFormat(_acf, "\u0032")
		case "\u0064\u0064":
			_acf = _ef.AppendFormat(_acf, "\u0030\u0032")
		case "\u0064\u0064\u0064":
			_acf = _ef.AppendFormat(_acf, "\u004d\u006f\u006e")
		case "\u0064\u0064\u0064\u0064":
			_acf = _ef.AppendFormat(_acf, "\u004d\u006f\u006e\u0064\u0061\u0079")
		default:
			_f.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073", _cfa)
		}
		if _aea[_beaa] == '/' {
			_acf = append(_acf, '/')
		}
	}
	return _acf
}

// Token is a format token in the Excel format string.
type Token struct {
	Type     FmtType
	Literal  byte
	DateTime string
}

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number(v float64, f string) string {
	if f == "" || f == "\u0047e\u006e\u0065\u0072\u0061\u006c" || f == "\u0040" {
		return NumberGeneric(v)
	}
	_gd := Parse(f)
	if len(_gd) == 1 {
		return _ebg(v, _gd[0], false)
	} else if len(_gd) > 1 && v < 0 {
		return _ebg(v, _gd[1], true)
	} else if len(_gd) > 2 && v == 0 {
		return _ebg(v, _gd[2], false)
	}
	return _ebg(v, _gd[0], false)
}

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value(v string, f string) string {
	if IsNumber(v) {
		_ce, _ := _bb.ParseFloat(v, 64)
		return Number(_ce, f)
	}
	return String(v, f)
}

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric(v float64) string {
	if _a.Abs(v) >= _fg || _a.Abs(v) <= _be && v != 0 {
		return _caa(v)
	}
	_ebcb := make([]byte, 0, 15)
	_ebcb = _bb.AppendFloat(_ebcb, v, 'f', -1, 64)
	if len(_ebcb) > 11 {
		_gccc := _ebcb[11] - '0'
		if _gccc >= 5 && _gccc <= 9 {
			_ebcb[10]++
			_ebcb = _ebcb[0:11]
			_ebcb = _ddf(_ebcb)
		}
		_ebcb = _ebcb[0:11]
	} else if len(_ebcb) == 11 {
		if _ebcb[len(_ebcb)-1] == '9' {
			_ebcb[len(_ebcb)-1]++
			_ebcb = _ddf(_ebcb)
		}
	}
	_ebcb = _fag(_ebcb)
	return string(_ebcb)
}
func _geb(_ffgc int64, _gb Format) []byte {
	if !_gb.IsExponential || len(_gb.Exponent) == 0 {
		return nil
	}
	_edc := _bb.AppendInt(nil, _cfe(_ffgc), 10)
	_gcg := make([]byte, 0, len(_edc)+2)
	_gcg = append(_gcg, 'E')
	if _ffgc >= 0 {
		_gcg = append(_gcg, '+')
	} else {
		_gcg = append(_gcg, '-')
		_ffgc *= -1
	}
	_gbd := 0
_bac:
	for _gff := len(_gb.Exponent) - 1; _gff >= 0; _gff-- {
		_dag := len(_edc) - 1 - _gbd
		_ggd := _gb.Exponent[_gff]
		switch _ggd.Type {
		case FmtTypeDigit:
			if _dag >= 0 {
				_gcg = append(_gcg, _edc[_dag])
				_gbd++
			} else {
				_gcg = append(_gcg, '0')
			}
		case FmtTypeDigitOpt:
			if _dag >= 0 {
				_gcg = append(_gcg, _edc[_dag])
				_gbd++
			} else {
				for _cff := _gff; _cff >= 0; _cff-- {
					_ga := _gb.Exponent[_cff]
					if _ga.Type == FmtTypeLiteral {
						_gcg = append(_gcg, _ga.Literal)
					}
				}
				break _bac
			}
		case FmtTypeLiteral:
			_gcg = append(_gcg, _ggd.Literal)
		default:
			_f.Log("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076", _ggd)
		}
	}
	if _gbd < len(_edc) {
		_gcg = append(_gcg, _edc[len(_edc)-_gbd-1:_gbd-1]...)
	}
	_ced(_gcg[2:])
	return _gcg
}

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String(v string, f string) string {
	_acd := Parse(f)
	var _af Format
	if len(_acd) == 1 {
		_af = _acd[0]
	} else if len(_acd) == 4 {
		_af = _acd[3]
	}
	_fb := false
	for _, _bcc := range _af.Whole {
		if _bcc.Type == FmtTypeText {
			_fb = true
		}
	}
	if !_fb {
		return v
	}
	_dde := _bf.Buffer{}
	for _, _ebb := range _af.Whole {
		switch _ebb.Type {
		case FmtTypeLiteral:
			_dde.WriteByte(_ebb.Literal)
		case FmtTypeText:
			_dde.WriteString(v)
		}
	}
	return _dde.String()
}

const _edba int = 34

func (_c FmtType) String() string {
	if _c >= FmtType(len(_bc)-1) {
		return _b.Sprintf("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029", _c)
	}
	return _dd[_bc[_c]:_bc[_c+1]]
}
func _ebg(_gc float64, _ag Format, _eef bool) string {
	if _ag._fa {
		return NumberGeneric(_gc)
	}
	_edd := make([]byte, 0, 20)
	_gg := _a.Signbit(_gc)
	_bfa := _a.Abs(_gc)
	_ea := int64(0)
	_agg := int64(0)
	if _ag.IsExponential {
		for _bfa >= 10 {
			_agg++
			_bfa /= 10
		}
		for _bfa < 1 {
			_agg--
			_bfa *= 10
		}
	} else if _ag._ad {
		_bfa *= 100
	} else if _ag._fc {
		if _ag._ff == 0 {
			_ffc := _a.Pow(10, float64(_ag._ac))
			_ceg, _cc := 1.0, 1.0
			_ = _ceg
			for _eab := 1.0; _eab < _ffc; _eab++ {
				_, _ecd := _a.Modf(_bfa * float64(_eab))
				if _ecd < _cc {
					_cc = _ecd
					_ceg = _eab
					if _ecd == 0 {
						break
					}
				}
			}
			_ag._ff = int64(_ceg)
		}
		_ea = int64(_bfa*float64(_ag._ff) + 0.5)
		if len(_ag.Whole) > 0 && _ea > _ag._ff {
			_ea = int64(_bfa*float64(_ag._ff)) % _ag._ff
			_bfa -= float64(_ea) / float64(_ag._ff)
		} else {
			_bfa -= float64(_ea) / float64(_ag._ff)
			if _a.Abs(_bfa) < 1 {
				_gce := true
				for _, _dfe := range _ag.Whole {
					if _dfe.Type == FmtTypeDigitOpt {
						continue
					}
					if _dfe.Type == FmtTypeLiteral && _dfe.Literal == ' ' {
						continue
					}
					_gce = false
				}
				if _gce {
					_ag.Whole = nil
				}
			}
		}
	}
	_gdf := 1
	for _, _db := range _ag.Fractional {
		if _db.Type == FmtTypeDigit || _db.Type == FmtTypeDigitOpt {
			_gdf++
		}
	}
	_bfa += 5 * _a.Pow10(-_gdf)
	_gcc, _ecb := _a.Modf(_bfa)
	_edd = append(_edd, _afb(_gcc, _gc, _ag)...)
	_edd = append(_edd, _fe(_ecb, _gc, _ag)...)
	_edd = append(_edd, _geb(_agg, _ag)...)
	if _ag._fc {
		_edd = _bb.AppendInt(_edd, _ea, 10)
		_edd = append(_edd, '/')
		_edd = _bb.AppendInt(_edd, _ag._ff, 10)
	}
	if !_eef && _gg {
		return "\u002d" + string(_edd)
	}
	return string(_edd)
}
func Parse(s string) []Format {
	_eee := Lexer{}
	_eee.Lex(_eb.NewReader(s))
	_eee._aeg = append(_eee._aeg, _eee._fee)
	return _eee._aeg
}

type Lexer struct {
	_fee Format
	_aeg []Format
}

func (_dbf *Lexer) nextFmt() { _dbf._aeg = append(_dbf._aeg, _dbf._fee); _dbf._fee = Format{} }

const _cce int = -1

// Format is a parsed number format.
type Format struct {
	Whole         []Token
	Fractional    []Token
	Exponent      []Token
	IsExponential bool
	_fc           bool
	_ad           bool
	_fa           bool
	_df           bool
	_ed           bool
	_fd           bool
	_ff           int64
	_ac           int
}

func _afb(_dg, _bfae float64, _ab Format) []byte {
	if len(_ab.Whole) == 0 {
		return nil
	}
	_cec := _e.Date(1899, 12, 30, 0, 0, 0, 0, _e.UTC)
	_dge := _cec.Add(_e.Duration(_bfae * float64(24*_e.Hour)))
	_dge = _bcfg(_dge)
	_bea := _bb.AppendFloat(nil, _dg, 'f', -1, 64)
	_ada := make([]byte, 0, len(_bea))
	_fdb := 0
	_cb := 1
_ede:
	for _eg := len(_ab.Whole) - 1; _eg >= 0; _eg-- {
		_edb := len(_bea) - 1 - _fdb
		_ae := _ab.Whole[_eg]
		switch _ae.Type {
		case FmtTypeDigit:
			if _edb >= 0 {
				_ada = append(_ada, _bea[_edb])
				_fdb++
				_cb = _eg
			} else {
				_ada = append(_ada, '0')
			}
		case FmtTypeDigitOpt:
			if _edb >= 0 {
				_ada = append(_ada, _bea[_edb])
				_fdb++
				_cb = _eg
			} else {
				for _bcg := _eg; _bcg >= 0; _bcg-- {
					_eeg := _ab.Whole[_bcg]
					if _eeg.Type == FmtTypeLiteral {
						_ada = append(_ada, _eeg.Literal)
					}
				}
				break _ede
			}
		case FmtTypeDollar:
			for _dab := _fdb; _dab < len(_bea); _dab++ {
				_ada = append(_ada, _bea[len(_bea)-1-_dab])
				_fdb++
			}
			_ada = append(_ada, '$')
		case FmtTypeComma:
			if !_ab._df {
				_ada = append(_ada, ',')
			}
		case FmtTypeLiteral:
			_ada = append(_ada, _ae.Literal)
		case FmtTypeDate:
			_ada = append(_ada, _ced(_ecf(_dge, _ae.DateTime))...)
		case FmtTypeTime:
			_ada = append(_ada, _ced(_bgc(_dge, _bfae, _ae.DateTime))...)
		default:
			_f.Log("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076", _ae)
		}
	}
	_cda := _ced(_ada)
	if _fdb < len(_bea) && (_fdb != 0 || _ab._fd) {
		_bd := len(_bea) - _fdb
		_bda := make([]byte, len(_cda)+_bd)
		copy(_bda, _cda[0:_cb])
		copy(_bda[_cb:], _bea[0:])
		copy(_bda[_cb+_bd:], _cda[_cb:])
		_cda = _bda
	}
	if _ab._df {
		_aca := _bf.Buffer{}
		_cea := 0
		for _eba := len(_cda) - 1; _eba >= 0; _eba-- {
			if !(_cda[_eba] >= '0' && _cda[_eba] <= '9') {
				_cea++
			} else {
				break
			}
		}
		for _acc := 0; _acc < len(_cda); _acc++ {
			_cde := (len(_cda) - _acc - _cea)
			if _cde%3 == 0 && _cde != 0 && _acc != 0 {
				_aca.WriteByte(',')
			}
			_aca.WriteByte(_cda[_acc])
		}
		_cda = _aca.Bytes()
	}
	return _cda
}

const _bgf int = 34

func _fe(_aa, _dac float64, _abe Format) []byte {
	if len(_abe.Fractional) == 0 {
		return nil
	}
	_daf := _bb.AppendFloat(nil, _aa, 'f', -1, 64)
	if len(_daf) > 2 {
		_daf = _daf[2:]
	} else {
		_daf = nil
	}
	_gga := make([]byte, 0, len(_daf))
	_gga = append(_gga, '.')
	_egd := 0
_dff:
	for _bg := 0; _bg < len(_abe.Fractional); _bg++ {
		_ba := _bg
		_fdg := _abe.Fractional[_bg]
		switch _fdg.Type {
		case FmtTypeDigit:
			if _ba < len(_daf) {
				_gga = append(_gga, _daf[_ba])
				_egd++
			} else {
				_gga = append(_gga, '0')
			}
		case FmtTypeDigitOpt:
			if _ba >= 0 {
				_gga = append(_gga, _daf[_ba])
				_egd++
			} else {
				break _dff
			}
		case FmtTypeLiteral:
			_gga = append(_gga, _fdg.Literal)
		default:
			_f.Log("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076", _fdg)
		}
	}
	return _gga
}

const _fg = 1e11
const _gcd int = -1

// AddToken adds a format token to the format.
func (_ec *Format) AddToken(t FmtType, l []byte) {
	if _ec._ed {
		_ec._ed = false
		return
	}
	switch t {
	case FmtTypeDecimal:
		_ec._fd = true
	case FmtTypeUnderscore:
		_ec._ed = true
	case FmtTypeText:
		_ec.Whole = append(_ec.Whole, Token{Type: t})
	case FmtTypeDate, FmtTypeTime:
		_ec.Whole = append(_ec.Whole, Token{Type: t, DateTime: string(l)})
	case FmtTypePercent:
		_ec._ad = true
		t = FmtTypeLiteral
		l = []byte{'%'}
		fallthrough
	case FmtTypeDigitOpt:
		fallthrough
	case FmtTypeLiteral, FmtTypeDigit, FmtTypeDollar, FmtTypeComma:
		if l == nil {
			l = []byte{0}
		}
		for _, _ge := range l {
			if _ec.IsExponential {
				_ec.Exponent = append(_ec.Exponent, Token{Type: t, Literal: _ge})
			} else if !_ec._fd {
				_ec.Whole = append(_ec.Whole, Token{Type: t, Literal: _ge})
			} else {
				_ec.Fractional = append(_ec.Fractional, Token{Type: t, Literal: _ge})
			}
		}
	case FmtTypeDigitOptThousands:
		_ec._df = true
	case FmtTypeFraction:
		_cf := _eb.Split(string(l), "\u002f")
		if len(_cf) == 2 {
			_ec._fc = true
			_ec._ff, _ = _bb.ParseInt(_cf[1], 10, 64)
			for _, _fgf := range _cf[1] {
				if _fgf == '?' || _fgf == '0' {
					_ec._ac++
				}
			}
		}
	default:
		_f.Log("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076", t)
	}
}

const _dd = "\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074"

func (_bgfg *Lexer) Lex(r _d.Reader) {
	_dafc, _bed, _edef := 0, 0, 0
	_add := -1
	_efg, _fbf, _becc := 0, 0, 0
	_ = _fbf
	_ = _becc
	_gdbc := 1
	_ = _gdbc
	_cef := make([]byte, 4096)
	_caf := false
	for !_caf {
		_afcg := 0
		if _efg > 0 {
			_afcg = _bed - _efg
		}
		_bed = 0
		_gccb, _ggc := r.Read(_cef[_afcg:])
		if _gccb == 0 || _ggc != nil {
			_caf = true
		}
		_edef = _gccb + _afcg
		if _edef < len(_cef) {
			_add = _edef
		}
		{
			_dafc = _edba
			_efg = 0
			_fbf = 0
			_becc = 0
		}
		{
			if _bed == _edef {
				goto _bggc
			}
			switch _dafc {
			case 34:
				goto _eege
			case 35:
				goto _fea
			case 0:
				goto _gfe
			case 36:
				goto _geg
			case 37:
				goto _eac
			case 1:
				goto _beab
			case 2:
				goto _afdf
			case 38:
				goto _gcb
			case 3:
				goto _cdb
			case 4:
				goto _daa
			case 39:
				goto _dgff
			case 5:
				goto _dafg
			case 6:
				goto _bffa
			case 7:
				goto _aeb
			case 8:
				goto _ffgd
			case 40:
				goto _cad
			case 9:
				goto _ead
			case 41:
				goto _dae
			case 10:
				goto _gabg
			case 42:
				goto _ddg
			case 11:
				goto _gag
			case 43:
				goto _ccf
			case 44:
				goto _dccb
			case 45:
				goto _cbe
			case 12:
				goto _fed
			case 46:
				goto _gbf
			case 13:
				goto _ecdd
			case 14:
				goto _afdg
			case 15:
				goto _cgc
			case 16:
				goto _efa
			case 47:
				goto _aega
			case 17:
				goto _bbc
			case 48:
				goto _bef
			case 18:
				goto _fdgg
			case 19:
				goto _acg
			case 20:
				goto _edfa
			case 49:
				goto _eaed
			case 50:
				goto _dfb
			case 21:
				goto _bag
			case 22:
				goto _dgc
			case 23:
				goto _gec
			case 24:
				goto _bgb
			case 25:
				goto _egfe
			case 51:
				goto _efgc
			case 26:
				goto _bccd
			case 52:
				goto _fedg
			case 53:
				goto _beb
			case 54:
				goto _ebad
			case 55:
				goto _bbeeb
			case 56:
				goto _cdc
			case 57:
				goto _bad
			case 27:
				goto _fgg
			case 28:
				goto _eeed
			case 29:
				goto _dgeb
			case 30:
				goto _agfce
			case 31:
				goto _cgd
			case 58:
				goto _eea
			case 32:
				goto _gaf
			case 59:
				goto _cffg
			case 33:
				goto _bgbc
			case 60:
				goto _efc
			case 61:
				goto _cgf
			case 62:
				goto _dgec
			}
			goto _egb
		_ebca:
			switch _becc {
			case 2:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeDigit, nil)
				}
			case 3:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeDigitOpt, nil)
				}
			case 5:
				{
					_bed = (_fbf) - 1
				}
			case 8:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypePercent, nil)
				}
			case 13:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeFraction, _cef[_efg:_fbf])
				}
			case 14:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeDate, _cef[_efg:_fbf])
				}
			case 15:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeTime, _cef[_efg:_fbf])
				}
			case 16:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeTime, _cef[_efg:_fbf])
				}
			case 18:
				{
					_bed = (_fbf) - 1
				}
			case 20:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeLiteral, _cef[_efg:_fbf])
				}
			case 21:
				{
					_bed = (_fbf) - 1
					_bgfg._fee.AddToken(FmtTypeLiteral, _cef[_efg+1:_fbf-1])
				}
			}
			goto _gfag
		_cabd:
			_bed = (_fbf) - 1
			{
				_bgfg._fee.AddToken(FmtTypeFraction, _cef[_efg:_fbf])
			}
			goto _gfag
		_baef:
			_bed = (_fbf) - 1
			{
				_bgfg._fee.AddToken(FmtTypeDigitOpt, nil)
			}
			goto _gfag
		_gdfd:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeDigitOptThousands, nil)
			}
			goto _gfag
		_aba:
			_bed = (_fbf) - 1
			{
				_bgfg._fee.AddToken(FmtTypePercent, nil)
			}
			goto _gfag
		_bbe:
			_bed = (_fbf) - 1
			{
				_bgfg._fee.AddToken(FmtTypeDate, _cef[_efg:_fbf])
			}
			goto _gfag
		_fdf:
			_bed = (_fbf) - 1
			{
				_bgfg._fee.AddToken(FmtTypeDigit, nil)
			}
			goto _gfag
		_fec:
			_bed = (_fbf) - 1
			{
				_bgfg._fee.AddToken(FmtTypeTime, _cef[_efg:_fbf])
			}
			goto _gfag
		_gbbd:
			_bed = (_fbf) - 1
			{
				_bgfg._fee.AddToken(FmtTypeLiteral, _cef[_efg:_fbf])
			}
			goto _gfag
		_faa:
			_fbf = _bed + 1
			{
				_bgfg._fee._fa = true
			}
			goto _gfag
		_acade:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeLiteral, _cef[_efg:_fbf])
			}
			goto _gfag
		_dcc:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeDollar, nil)
			}
			goto _gfag
		_eda:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeComma, nil)
			}
			goto _gfag
		_aege:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeDecimal, nil)
			}
			goto _gfag
		_afa:
			_fbf = _bed + 1
			{
				_bgfg.nextFmt()
			}
			goto _gfag
		_edf:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeText, nil)
			}
			goto _gfag
		_gaa:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeUnderscore, nil)
			}
			goto _gfag
		_gab:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypeLiteral, _cef[_efg:_fbf])
			}
			goto _gfag
		_ccaf:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypeLiteral, _cef[_efg+1:_fbf-1])
			}
			goto _gfag
		_fbda:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypeDigitOpt, nil)
			}
			goto _gfag
		_adb:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypeFraction, _cef[_efg:_fbf])
			}
			goto _gfag
		_eed:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypePercent, nil)
			}
			goto _gfag
		_agga:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypeDate, _cef[_efg:_fbf])
			}
			goto _gfag
		_cg:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypeDigit, nil)
			}
			goto _gfag
		_fga:
			_fbf = _bed
			_bed--
			{
				_bgfg._fee.AddToken(FmtTypeTime, _cef[_efg:_fbf])
			}
			goto _gfag
		_ffge:
			_fbf = _bed
			_bed--
			{
			}
			goto _gfag
		_bafa:
			_fbf = _bed + 1
			{
				_bgfg._fee.IsExponential = true
			}
			goto _gfag
		_abd:
			_fbf = _bed + 1
			{
				_bgfg._fee.AddToken(FmtTypeLiteral, _cef[_efg+1:_fbf])
			}
			goto _gfag
		_gfag:
			_efg = 0
			if _bed++; _bed == _edef {
				goto _fba
			}
		_eege:
			_efg = _bed
			switch _cef[_bed] {
			case 34:
				goto _ccc
			case 35:
				goto _ebae
			case 36:
				goto _dcc
			case 37:
				goto _aece
			case 44:
				goto _eda
			case 46:
				goto _aege
			case 47:
				goto _cecb
			case 48:
				goto _dgdf
			case 58:
				goto _dbb
			case 59:
				goto _afa
			case 63:
				goto _addd
			case 64:
				goto _edf
			case 65:
				goto _baa
			case 69:
				goto _gcdd
			case 71:
				goto _dgfc
			case 91:
				goto _fgff
			case 92:
				goto _afg
			case 95:
				goto _gaa
			case 100:
				goto _cecb
			case 104:
				goto _dbb
			case 109:
				goto _ccfa
			case 115:
				goto _bbeg
			case 121:
				goto _bcgd
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _cega
			}
			goto _acade
		_ccc:
			_fbf = _bed + 1
			_becc = 20
			goto _cgb
		_cgb:
			if _bed++; _bed == _edef {
				goto _deg
			}
		_fea:
			if _cef[_bed] == 34 {
				goto _dbd
			}
			goto _dgb
		_dgb:
			if _bed++; _bed == _edef {
				goto _dbec
			}
		_gfe:
			if _cef[_bed] == 34 {
				goto _dbd
			}
			goto _dgb
		_dbd:
			_fbf = _bed + 1
			_becc = 21
			goto _cbb
		_cbb:
			if _bed++; _bed == _edef {
				goto _bcd
			}
		_geg:
			if _cef[_bed] == 34 {
				goto _dgb
			}
			goto _ccaf
		_ebae:
			_fbf = _bed + 1
			_becc = 3
			goto _eeee
		_eeee:
			if _bed++; _bed == _edef {
				goto _fggc
			}
		_eac:
			switch _cef[_bed] {
			case 35:
				goto _fbe
			case 37:
				goto _fbe
			case 44:
				goto _cede
			case 47:
				goto _gfc
			case 48:
				goto _fbe
			case 63:
				goto _fbe
			}
			goto _fbda
		_fbe:
			if _bed++; _bed == _edef {
				goto _bffb
			}
		_beab:
			switch _cef[_bed] {
			case 35:
				goto _fbe
			case 37:
				goto _fbe
			case 47:
				goto _gfc
			case 48:
				goto _fbe
			case 63:
				goto _fbe
			}
			goto _ebca
		_gfc:
			if _bed++; _bed == _edef {
				goto _gbg
			}
		_afdf:
			switch _cef[_bed] {
			case 35:
				goto _fcf
			case 37:
				goto _baff
			case 48:
				goto _bcga
			case 63:
				goto _fcf
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dec
			}
			goto _ebca
		_fcf:
			_fbf = _bed + 1
			goto _ffb
		_ffb:
			if _bed++; _bed == _edef {
				goto _beda
			}
		_gcb:
			switch _cef[_bed] {
			case 35:
				goto _fcf
			case 37:
				goto _fcf
			case 44:
				goto _fcf
			case 46:
				goto _fcf
			case 48:
				goto _fcf
			case 63:
				goto _fcf
			case 65:
				goto _cccc
			}
			goto _adb
		_cccc:
			if _bed++; _bed == _edef {
				goto _fdd
			}
		_cdb:
			switch _cef[_bed] {
			case 47:
				goto _aaa
			case 77:
				goto _abcf
			}
			goto _cabd
		_aaa:
			if _bed++; _bed == _edef {
				goto _gdfe
			}
		_daa:
			if _cef[_bed] == 80 {
				goto _ddfg
			}
			goto _cabd
		_ddfg:
			_fbf = _bed + 1
			goto _ccb
		_ccb:
			if _bed++; _bed == _edef {
				goto _gbe
			}
		_dgff:
			if _cef[_bed] == 65 {
				goto _cccc
			}
			goto _adb
		_abcf:
			if _bed++; _bed == _edef {
				goto _cdg
			}
		_dafg:
			if _cef[_bed] == 47 {
				goto _ffdc
			}
			goto _cabd
		_ffdc:
			if _bed++; _bed == _edef {
				goto _acgg
			}
		_bffa:
			if _cef[_bed] == 80 {
				goto _adca
			}
			goto _cabd
		_adca:
			if _bed++; _bed == _edef {
				goto _cffc
			}
		_aeb:
			if _cef[_bed] == 77 {
				goto _ddfg
			}
			goto _cabd
		_baff:
			if _bed++; _bed == _edef {
				goto _dba
			}
		_ffgd:
			switch _cef[_bed] {
			case 35:
				goto _gfg
			case 37:
				goto _eae
			case 63:
				goto _gfg
			}
			if 48 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _ccbg
			}
			goto _ebca
		_gfg:
			_fbf = _bed + 1
			goto _gbc
		_gbc:
			if _bed++; _bed == _edef {
				goto _aad
			}
		_cad:
			switch _cef[_bed] {
			case 35:
				goto _fcf
			case 37:
				goto _eeeb
			case 44:
				goto _fcf
			case 46:
				goto _fcf
			case 48:
				goto _fcf
			case 63:
				goto _fcf
			case 65:
				goto _cccc
			}
			goto _adb
		_eeeb:
			if _bed++; _bed == _edef {
				goto _cgfc
			}
		_ead:
			switch _cef[_bed] {
			case 35:
				goto _egf
			case 44:
				goto _egf
			case 46:
				goto _egf
			case 48:
				goto _egf
			case 63:
				goto _egf
			}
			goto _cabd
		_egf:
			_fbf = _bed + 1
			goto _baeg
		_baeg:
			if _bed++; _bed == _edef {
				goto _aae
			}
		_dae:
			switch _cef[_bed] {
			case 35:
				goto _egf
			case 44:
				goto _egf
			case 46:
				goto _egf
			case 48:
				goto _egf
			case 63:
				goto _egf
			case 65:
				goto _cccc
			}
			goto _adb
		_eae:
			if _bed++; _bed == _edef {
				goto _egef
			}
		_gabg:
			if _cef[_bed] == 37 {
				goto _eae
			}
			if 48 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _ccbg
			}
			goto _ebca
		_ccbg:
			_fbf = _bed + 1
			_becc = 13
			goto _gdg
		_gdg:
			if _bed++; _bed == _edef {
				goto _bbad
			}
		_ddg:
			switch _cef[_bed] {
			case 35:
				goto _fcf
			case 37:
				goto _fcbdf
			case 44:
				goto _fcf
			case 46:
				goto _fcf
			case 48:
				goto _eca
			case 63:
				goto _fcf
			case 65:
				goto _cccc
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _ccbg
			}
			goto _adb
		_fcbdf:
			if _bed++; _bed == _edef {
				goto _ggg
			}
		_gag:
			switch _cef[_bed] {
			case 35:
				goto _egf
			case 37:
				goto _eae
			case 44:
				goto _egf
			case 46:
				goto _egf
			case 63:
				goto _egf
			}
			if 48 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _ccbg
			}
			goto _cabd
		_eca:
			_fbf = _bed + 1
			goto _dfa
		_dfa:
			if _bed++; _bed == _edef {
				goto _cgee
			}
		_ccf:
			switch _cef[_bed] {
			case 35:
				goto _fcf
			case 37:
				goto _eca
			case 44:
				goto _fcf
			case 46:
				goto _fcf
			case 48:
				goto _eca
			case 63:
				goto _fcf
			case 65:
				goto _cccc
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _ccbg
			}
			goto _adb
		_bcga:
			_fbf = _bed + 1
			goto _fff
		_fff:
			if _bed++; _bed == _edef {
				goto _abb
			}
		_dccb:
			switch _cef[_bed] {
			case 35:
				goto _fcf
			case 37:
				goto _eca
			case 44:
				goto _fcf
			case 46:
				goto _fcf
			case 48:
				goto _bcga
			case 63:
				goto _fcf
			case 65:
				goto _cccc
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dec
			}
			goto _adb
		_dec:
			_fbf = _bed + 1
			goto _cge
		_cge:
			if _bed++; _bed == _edef {
				goto _gabf
			}
		_cbe:
			switch _cef[_bed] {
			case 35:
				goto _fcf
			case 37:
				goto _ccbg
			case 44:
				goto _fcf
			case 46:
				goto _fcf
			case 48:
				goto _bcga
			case 63:
				goto _fcf
			case 65:
				goto _cccc
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dec
			}
			goto _adb
		_cede:
			if _bed++; _bed == _edef {
				goto _eedf
			}
		_fed:
			if _cef[_bed] == 35 {
				goto _gdfd
			}
			goto _baef
		_aece:
			_fbf = _bed + 1
			_becc = 8
			goto _faff
		_faff:
			if _bed++; _bed == _edef {
				goto _efae
			}
		_gbf:
			switch _cef[_bed] {
			case 35:
				goto _ffcd
			case 37:
				goto _ggee
			case 48:
				goto _ffca
			case 63:
				goto _ffcd
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dafcg
			}
			goto _eed
		_ffcd:
			if _bed++; _bed == _edef {
				goto _aecb
			}
		_ecdd:
			switch _cef[_bed] {
			case 35:
				goto _ffcd
			case 47:
				goto _gfc
			case 48:
				goto _ffcd
			case 63:
				goto _ffcd
			}
			goto _aba
		_ggee:
			if _bed++; _bed == _edef {
				goto _cgec
			}
		_afdg:
			if _cef[_bed] == 37 {
				goto _ggee
			}
			if 48 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dafcg
			}
			goto _ebca
		_dafcg:
			if _bed++; _bed == _edef {
				goto _fbea
			}
		_cgc:
			switch _cef[_bed] {
			case 37:
				goto _ggee
			case 47:
				goto _gfc
			}
			if 48 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dafcg
			}
			goto _ebca
		_ffca:
			if _bed++; _bed == _edef {
				goto _efe
			}
		_efa:
			switch _cef[_bed] {
			case 35:
				goto _ffcd
			case 37:
				goto _ggee
			case 47:
				goto _gfc
			case 48:
				goto _ffca
			case 63:
				goto _ffcd
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dafcg
			}
			goto _aba
		_cecb:
			_fbf = _bed + 1
			goto _eefg
		_eefg:
			if _bed++; _bed == _edef {
				goto _afdgd
			}
		_aega:
			switch _cef[_bed] {
			case 47:
				goto _cecb
			case 100:
				goto _cecb
			case 109:
				goto _cecb
			case 121:
				goto _agf
			}
			goto _agga
		_agf:
			if _bed++; _bed == _edef {
				goto _bffd
			}
		_bbc:
			if _cef[_bed] == 121 {
				goto _cecb
			}
			goto _bbe
		_dgdf:
			_fbf = _bed + 1
			_becc = 2
			goto _gfcb
		_gfcb:
			if _bed++; _bed == _edef {
				goto _cedf
			}
		_bef:
			switch _cef[_bed] {
			case 35:
				goto _fbe
			case 37:
				goto _adcc
			case 47:
				goto _gfc
			case 48:
				goto _bcb
			case 63:
				goto _fbe
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _fgc
			}
			goto _cg
		_adcc:
			if _bed++; _bed == _edef {
				goto _cgg
			}
		_fdgg:
			switch _cef[_bed] {
			case 35:
				goto _fbe
			case 37:
				goto _adcc
			case 47:
				goto _gfc
			case 48:
				goto _adcc
			case 63:
				goto _fbe
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _dafcg
			}
			goto _fdf
		_bcb:
			if _bed++; _bed == _edef {
				goto _fce
			}
		_acg:
			switch _cef[_bed] {
			case 35:
				goto _fbe
			case 37:
				goto _adcc
			case 47:
				goto _gfc
			case 48:
				goto _bcb
			case 63:
				goto _fbe
			}
			if 49 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _fgc
			}
			goto _fdf
		_fgc:
			if _bed++; _bed == _edef {
				goto _aaaf
			}
		_edfa:
			switch _cef[_bed] {
			case 37:
				goto _dafcg
			case 47:
				goto _gfc
			}
			if 48 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _fgc
			}
			goto _ebca
		_cega:
			_fbf = _bed + 1
			_becc = 20
			goto _feb
		_feb:
			if _bed++; _bed == _edef {
				goto _fcec
			}
		_eaed:
			switch _cef[_bed] {
			case 37:
				goto _dafcg
			case 47:
				goto _gfc
			}
			if 48 <= _cef[_bed] && _cef[_bed] <= 57 {
				goto _fgc
			}
			goto _gab
		_dbb:
			_fbf = _bed + 1
			_becc = 15
			goto _gae
		_gae:
			if _bed++; _bed == _edef {
				goto _eag
			}
		_dfb:
			switch _cef[_bed] {
			case 58:
				goto _dbb
			case 65:
				goto _bacg
			case 104:
				goto _dbb
			case 109:
				goto _dbb
			case 115:
				goto _bbeg
			}
			goto _fga
		_bacg:
			if _bed++; _bed == _edef {
				goto _cgecg
			}
		_bag:
			switch _cef[_bed] {
			case 47:
				goto _aag
			case 77:
				goto _edfc
			}
			goto _ebca
		_aag:
			if _bed++; _bed == _edef {
				goto _egc
			}
		_dgc:
			if _cef[_bed] == 80 {
				goto _dbb
			}
			goto _ebca
		_edfc:
			if _bed++; _bed == _edef {
				goto _gfab
			}
		_gec:
			if _cef[_bed] == 47 {
				goto _agfc
			}
			goto _ebca
		_agfc:
			if _bed++; _bed == _edef {
				goto _fbfg
			}
		_bgb:
			if _cef[_bed] == 80 {
				goto _gbfb
			}
			goto _ebca
		_gbfb:
			if _bed++; _bed == _edef {
				goto _ccg
			}
		_egfe:
			if _cef[_bed] == 77 {
				goto _dbb
			}
			goto _ebca
		_bbeg:
			_fbf = _bed + 1
			_becc = 15
			goto _baeb
		_baeb:
			if _bed++; _bed == _edef {
				goto _begd
			}
		_efgc:
			switch _cef[_bed] {
			case 46:
				goto _ded
			case 58:
				goto _dbb
			case 65:
				goto _bacg
			case 104:
				goto _dbb
			case 109:
				goto _dbb
			case 115:
				goto _bbeg
			}
			goto _fga
		_ded:
			if _bed++; _bed == _edef {
				goto _cbbb
			}
		_bccd:
			if _cef[_bed] == 48 {
				goto _bbee
			}
			goto _fec
		_bbee:
			_fbf = _bed + 1
			_becc = 15
			goto _gaad
		_gaad:
			if _bed++; _bed == _edef {
				goto _bddd
			}
		_fedg:
			switch _cef[_bed] {
			case 48:
				goto _caff
			case 58:
				goto _dbb
			case 65:
				goto _bacg
			case 104:
				goto _dbb
			case 109:
				goto _dbb
			case 115:
				goto _bbeg
			}
			goto _fga
		_caff:
			_fbf = _bed + 1
			_becc = 15
			goto _bgbb
		_bgbb:
			if _bed++; _bed == _edef {
				goto _fgcd
			}
		_beb:
			switch _cef[_bed] {
			case 48:
				goto _dbb
			case 58:
				goto _dbb
			case 65:
				goto _bacg
			case 104:
				goto _dbb
			case 109:
				goto _dbb
			case 115:
				goto _bbeg
			}
			goto _fga
		_addd:
			_fbf = _bed + 1
			_becc = 5
			goto _bba
		_bba:
			if _bed++; _bed == _edef {
				goto _dcb
			}
		_ebad:
			switch _cef[_bed] {
			case 35:
				goto _fbe
			case 37:
				goto _fbe
			case 47:
				goto _gfc
			case 48:
				goto _fbe
			case 63:
				goto _fbe
			}
			goto _ffge
		_baa:
			_fbf = _bed + 1
			_becc = 20
			goto _bdd
		_bdd:
			if _bed++; _bed == _edef {
				goto _faag
			}
		_bbeeb:
			switch _cef[_bed] {
			case 47:
				goto _aag
			case 77:
				goto _edfc
			}
			goto _gab
		_gcdd:
			if _bed++; _bed == _edef {
				goto _efd
			}
		_cdc:
			switch _cef[_bed] {
			case 43:
				goto _bafa
			case 45:
				goto _bafa
			}
			goto _gab
		_dgfc:
			_fbf = _bed + 1
			goto _cdef
		_cdef:
			if _bed++; _bed == _edef {
				goto _daad
			}
		_bad:
			if _cef[_bed] == 101 {
				goto _dged
			}
			goto _gab
		_dged:
			if _bed++; _bed == _edef {
				goto _cdd
			}
		_fgg:
			if _cef[_bed] == 110 {
				goto _cffd
			}
			goto _gbbd
		_cffd:
			if _bed++; _bed == _edef {
				goto _cbf
			}
		_eeed:
			if _cef[_bed] == 101 {
				goto _bdb
			}
			goto _gbbd
		_bdb:
			if _bed++; _bed == _edef {
				goto _efgcb
			}
		_dgeb:
			if _cef[_bed] == 114 {
				goto _ebf
			}
			goto _gbbd
		_ebf:
			if _bed++; _bed == _edef {
				goto _eaf
			}
		_agfce:
			if _cef[_bed] == 97 {
				goto _ffdb
			}
			goto _gbbd
		_ffdb:
			if _bed++; _bed == _edef {
				goto _dbee
			}
		_cgd:
			if _cef[_bed] == 108 {
				goto _faa
			}
			goto _gbbd
		_fgff:
			_fbf = _bed + 1
			_becc = 20
			goto _abcfe
		_abcfe:
			if _bed++; _bed == _edef {
				goto _gba
			}
		_eea:
			switch _cef[_bed] {
			case 104:
				goto _gde
			case 109:
				goto _gde
			case 115:
				goto _gde
			}
			goto _fcg
		_fcg:
			if _bed++; _bed == _edef {
				goto _eadb
			}
		_gaf:
			if _cef[_bed] == 93 {
				goto _gceb
			}
			goto _fcg
		_gceb:
			_fbf = _bed + 1
			_becc = 18
			goto _feg
		_aebb:
			_fbf = _bed + 1
			_becc = 16
			goto _feg
		_feg:
			if _bed++; _bed == _edef {
				goto _becf
			}
		_cffg:
			if _cef[_bed] == 93 {
				goto _gceb
			}
			goto _fcg
		_gde:
			if _bed++; _bed == _edef {
				goto _cdag
			}
		_bgbc:
			if _cef[_bed] == 93 {
				goto _aebb
			}
			goto _fcg
		_afg:
			if _bed++; _bed == _edef {
				goto _acaa
			}
		_efc:
			goto _abd
		_ccfa:
			_fbf = _bed + 1
			_becc = 14
			goto _aaf
		_aaf:
			if _bed++; _bed == _edef {
				goto _fedb
			}
		_cgf:
			switch _cef[_bed] {
			case 47:
				goto _cecb
			case 58:
				goto _dbb
			case 65:
				goto _bacg
			case 100:
				goto _cecb
			case 104:
				goto _dbb
			case 109:
				goto _ccfa
			case 115:
				goto _bbeg
			case 121:
				goto _agf
			}
			goto _agga
		_bcgd:
			if _bed++; _bed == _edef {
				goto _cdea
			}
		_dgec:
			if _cef[_bed] == 121 {
				goto _cecb
			}
			goto _gab
		_egb:
		_fba:
			_dafc = 34
			goto _bggc
		_deg:
			_dafc = 35
			goto _bggc
		_dbec:
			_dafc = 0
			goto _bggc
		_bcd:
			_dafc = 36
			goto _bggc
		_fggc:
			_dafc = 37
			goto _bggc
		_bffb:
			_dafc = 1
			goto _bggc
		_gbg:
			_dafc = 2
			goto _bggc
		_beda:
			_dafc = 38
			goto _bggc
		_fdd:
			_dafc = 3
			goto _bggc
		_gdfe:
			_dafc = 4
			goto _bggc
		_gbe:
			_dafc = 39
			goto _bggc
		_cdg:
			_dafc = 5
			goto _bggc
		_acgg:
			_dafc = 6
			goto _bggc
		_cffc:
			_dafc = 7
			goto _bggc
		_dba:
			_dafc = 8
			goto _bggc
		_aad:
			_dafc = 40
			goto _bggc
		_cgfc:
			_dafc = 9
			goto _bggc
		_aae:
			_dafc = 41
			goto _bggc
		_egef:
			_dafc = 10
			goto _bggc
		_bbad:
			_dafc = 42
			goto _bggc
		_ggg:
			_dafc = 11
			goto _bggc
		_cgee:
			_dafc = 43
			goto _bggc
		_abb:
			_dafc = 44
			goto _bggc
		_gabf:
			_dafc = 45
			goto _bggc
		_eedf:
			_dafc = 12
			goto _bggc
		_efae:
			_dafc = 46
			goto _bggc
		_aecb:
			_dafc = 13
			goto _bggc
		_cgec:
			_dafc = 14
			goto _bggc
		_fbea:
			_dafc = 15
			goto _bggc
		_efe:
			_dafc = 16
			goto _bggc
		_afdgd:
			_dafc = 47
			goto _bggc
		_bffd:
			_dafc = 17
			goto _bggc
		_cedf:
			_dafc = 48
			goto _bggc
		_cgg:
			_dafc = 18
			goto _bggc
		_fce:
			_dafc = 19
			goto _bggc
		_aaaf:
			_dafc = 20
			goto _bggc
		_fcec:
			_dafc = 49
			goto _bggc
		_eag:
			_dafc = 50
			goto _bggc
		_cgecg:
			_dafc = 21
			goto _bggc
		_egc:
			_dafc = 22
			goto _bggc
		_gfab:
			_dafc = 23
			goto _bggc
		_fbfg:
			_dafc = 24
			goto _bggc
		_ccg:
			_dafc = 25
			goto _bggc
		_begd:
			_dafc = 51
			goto _bggc
		_cbbb:
			_dafc = 26
			goto _bggc
		_bddd:
			_dafc = 52
			goto _bggc
		_fgcd:
			_dafc = 53
			goto _bggc
		_dcb:
			_dafc = 54
			goto _bggc
		_faag:
			_dafc = 55
			goto _bggc
		_efd:
			_dafc = 56
			goto _bggc
		_daad:
			_dafc = 57
			goto _bggc
		_cdd:
			_dafc = 27
			goto _bggc
		_cbf:
			_dafc = 28
			goto _bggc
		_efgcb:
			_dafc = 29
			goto _bggc
		_eaf:
			_dafc = 30
			goto _bggc
		_dbee:
			_dafc = 31
			goto _bggc
		_gba:
			_dafc = 58
			goto _bggc
		_eadb:
			_dafc = 32
			goto _bggc
		_becf:
			_dafc = 59
			goto _bggc
		_cdag:
			_dafc = 33
			goto _bggc
		_acaa:
			_dafc = 60
			goto _bggc
		_fedb:
			_dafc = 61
			goto _bggc
		_cdea:
			_dafc = 62
			goto _bggc
		_bggc:
			{
			}
			if _bed == _add {
				switch _dafc {
				case 35:
					goto _gab
				case 0:
					goto _ebca
				case 36:
					goto _ccaf
				case 37:
					goto _fbda
				case 1:
					goto _ebca
				case 2:
					goto _ebca
				case 38:
					goto _adb
				case 3:
					goto _cabd
				case 4:
					goto _cabd
				case 39:
					goto _adb
				case 5:
					goto _cabd
				case 6:
					goto _cabd
				case 7:
					goto _cabd
				case 8:
					goto _ebca
				case 40:
					goto _adb
				case 9:
					goto _cabd
				case 41:
					goto _adb
				case 10:
					goto _ebca
				case 42:
					goto _adb
				case 11:
					goto _cabd
				case 43:
					goto _adb
				case 44:
					goto _adb
				case 45:
					goto _adb
				case 12:
					goto _baef
				case 46:
					goto _eed
				case 13:
					goto _aba
				case 14:
					goto _ebca
				case 15:
					goto _ebca
				case 16:
					goto _aba
				case 47:
					goto _agga
				case 17:
					goto _bbe
				case 48:
					goto _cg
				case 18:
					goto _fdf
				case 19:
					goto _fdf
				case 20:
					goto _ebca
				case 49:
					goto _gab
				case 50:
					goto _fga
				case 21:
					goto _ebca
				case 22:
					goto _ebca
				case 23:
					goto _ebca
				case 24:
					goto _ebca
				case 25:
					goto _ebca
				case 51:
					goto _fga
				case 26:
					goto _fec
				case 52:
					goto _fga
				case 53:
					goto _fga
				case 54:
					goto _ffge
				case 55:
					goto _gab
				case 56:
					goto _gab
				case 57:
					goto _gab
				case 27:
					goto _gbbd
				case 28:
					goto _gbbd
				case 29:
					goto _gbbd
				case 30:
					goto _gbbd
				case 31:
					goto _gbbd
				case 58:
					goto _gab
				case 32:
					goto _ebca
				case 59:
					goto _ebca
				case 33:
					goto _gbbd
				case 60:
					goto _gab
				case 61:
					goto _agga
				case 62:
					goto _gab
				}
			}
		}
		if _efg > 0 {
			copy(_cef[0:], _cef[_efg:])
		}
	}
	_ = _add
	if _dafc == _cce {
		_f.Log("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072")
	}
}
func IsNumber(data string) (_agc bool) {
	_ebgg, _egdg, _cffa := 0, 0, len(data)
	_gdc := len(data)
	_de, _bdae, _fcbd := 0, 0, 0
	_ = _bdae
	_ = _fcbd
	_ = _de
	{
		_ebgg = _cag
		_de = 0
		_bdae = 0
		_fcbd = 0
	}
	{
		if _egdg == _cffa {
			goto _adcd
		}
		switch _ebgg {
		case 0:
			goto _gcgc
		case 1:
			goto _baf
		case 2:
			goto _bcf
		case 3:
			goto _cab
		case 4:
			goto _aef
		case 5:
			goto _ffcf
		case 6:
			goto _ggba
		case 7:
			goto _gge
		}
		goto _ccad
	_cagc:
		_bdae = _egdg
		_egdg--
		{
			_agc = false
		}
		goto _gfa
	_dgf:
		_bdae = _egdg
		_egdg--
		{
			_agc = _bdae == len(data)
		}
		goto _gfa
	_ege:
		_bdae = _egdg
		_egdg--
		{
			_agc = _bdae == len(data)
		}
		goto _gfa
	_gcgg:
		switch _fcbd {
		case 2:
			{
				_egdg = (_bdae) - 1
				_agc = _bdae == len(data)
			}
		case 3:
			{
				_egdg = (_bdae) - 1
				_agc = false
			}
		}
		goto _gfa
	_gfa:
		_de = 0
		if _egdg++; _egdg == _cffa {
			goto _adae
		}
	_gcgc:
		_de = _egdg
		switch data[_egdg] {
		case 43:
			goto _afc
		case 45:
			goto _afc
		}
		if 48 <= data[_egdg] && data[_egdg] <= 57 {
			goto _dcf
		}
		goto _ggdd
	_ggdd:
		if _egdg++; _egdg == _cffa {
			goto _abc
		}
	_baf:
		goto _ggdd
	_afc:
		if _egdg++; _egdg == _cffa {
			goto _acad
		}
	_bcf:
		if 48 <= data[_egdg] && data[_egdg] <= 57 {
			goto _dcf
		}
		goto _ggdd
	_dcf:
		if _egdg++; _egdg == _cffa {
			goto _ffd
		}
	_cab:
		if data[_egdg] == 46 {
			goto _ggb
		}
		if 48 <= data[_egdg] && data[_egdg] <= 57 {
			goto _dcf
		}
		goto _ggdd
	_ggb:
		if _egdg++; _egdg == _cffa {
			goto _efb
		}
	_aef:
		if 48 <= data[_egdg] && data[_egdg] <= 57 {
			goto _dgfg
		}
		goto _ggdd
	_dgfg:
		if _egdg++; _egdg == _cffa {
			goto _fbd
		}
	_ffcf:
		if data[_egdg] == 69 {
			goto _egg
		}
		if 48 <= data[_egdg] && data[_egdg] <= 57 {
			goto _dgfg
		}
		goto _ggdd
	_egg:
		if _egdg++; _egdg == _cffa {
			goto _ged
		}
	_ggba:
		switch data[_egdg] {
		case 43:
			goto _adc
		case 45:
			goto _adc
		}
		goto _ggdd
	_adc:
		_bdae = _egdg + 1
		_fcbd = 3
		goto _gbb
	_adf:
		_bdae = _egdg + 1
		_fcbd = 2
		goto _gbb
	_gbb:
		if _egdg++; _egdg == _cffa {
			goto _adfd
		}
	_gge:
		if 48 <= data[_egdg] && data[_egdg] <= 57 {
			goto _adf
		}
		goto _ggdd
	_ccad:
	_adae:
		_ebgg = 0
		goto _adcd
	_abc:
		_ebgg = 1
		goto _adcd
	_acad:
		_ebgg = 2
		goto _adcd
	_ffd:
		_ebgg = 3
		goto _adcd
	_efb:
		_ebgg = 4
		goto _adcd
	_fbd:
		_ebgg = 5
		goto _adcd
	_ged:
		_ebgg = 6
		goto _adcd
	_adfd:
		_ebgg = 7
		goto _adcd
	_adcd:
		{
		}
		if _egdg == _gdc {
			switch _ebgg {
			case 1:
				goto _cagc
			case 2:
				goto _cagc
			case 3:
				goto _dgf
			case 4:
				goto _cagc
			case 5:
				goto _ege
			case 6:
				goto _cagc
			case 7:
				goto _gcgg
			}
		}
	}
	if _ebgg == _cce {
		return false
	}
	return
}
