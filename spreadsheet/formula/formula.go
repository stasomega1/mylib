//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package formula provides formula parsing and evaluation. The lexer is
// implemented with a ragel grammar while the the parser is implemented with
// goyacc. The entire formula grammar is not implemented and not all functions
// are supported yet. For compatibility sake, upon failure to parse or execute a
// formula, unioffice leaves cached formula results blank allowing Excel to compute
// formulas upon load. This is similar to what most other Excel libraries do
// which leave all cached results blank instead of attempting to execute
// formulas.
//
// The unit tests for this package are unique in that we can take advantage of
// "cached" formula results that Excel/LibreOffice write to the sheet.  These
// are the computed results of a formula in string form.  By comparing these
// values to the value computed by the unioffice evaluation of the formula, adding
// a new test means just adding a new formula to one of the reference sheets
// with Excel. During the unit test, we evaluate the formula and compare it to
// the value that Excel computed.  If they're the same, the test passes.
package formula

import (
	_bg "bytes"
	_b "fmt"
	_cg "github.com/stasomega1/mylib"
	_egc "github.com/stasomega1/mylib/internal/mergesort"
	_d "github.com/stasomega1/mylib/internal/wildcard"
	_c "github.com/stasomega1/mylib/spreadsheet/format"
	_df "github.com/stasomega1/mylib/spreadsheet/reference"
	_egg "github.com/stasomega1/mylib/spreadsheet/update"
	_e "io"
	_gg "math"
	_ac "math/big"
	_aca "math/rand"
	_af "regexp"
	_f "sort"
	_ga "strconv"
	_fa "strings"
	_eg "sync"
	_ea "time"
	_g "unicode"
)

// Columns implements the Excel COLUMNS function.
func Columns(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0043\u004fL\u0055\u004d\u004e\u0053\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075me\u006e\u0074")
	}
	_adgg := args[0]
	if _adgg.Type != ResultTypeArray && _adgg.Type != ResultTypeList {
		return MakeErrorResult("\u0043O\u004c\u0055M\u004e\u0053\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_baggb := _adgg.ValueArray
	if len(_baggb) == 0 {
		return MakeErrorResult("\u0043\u004f\u004c\u0055\u004d\u004e\u0053\u0020r\u0065\u0071\u0075ir\u0065\u0073\u0020\u0061\u0072\u0072a\u0079\u0020\u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0031\u0020r\u006f\u0077")
	}
	return MakeNumberResult(float64(len(_baggb[0])))
}
func _gfe(_eeg, _beed float64, _afda, _dcca int) float64 {
	_gecgd := _ddef(_eeg)
	_bgdcc := _ddef(_beed)
	_cfg := _fcag(_gecgd, _bgdcc, _afda)
	return _bdeb(_gecgd, _cfg, _dcca)
}
func _fdffc(_dgddf Result, _agcb, _ffgf string) (string, Result) {
	switch _dgddf.Type {
	case ResultTypeString, ResultTypeNumber, ResultTypeEmpty:
		return _dgddf.Value(), _aaa
	default:
		return "", MakeErrorResult(_agcb + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _ffgf + "\u0020t\u006f\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006db\u0065r\u0020o\u0072\u0020\u0073\u0074\u0072\u0069\u006eg")
	}
}
func _aggbe(_bgbc []Result, _agee string) (*durationArgs, Result) {
	_bgg := len(_bgbc)
	if _bgg != 5 && _bgg != 6 {
		return nil, MakeErrorResult(_agee + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0066\u0069\u0076\u0065\u0020\u006fr\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_cdfc, _abcf, _ceb := _daea(_bgbc[0], _bgbc[1], _agee)
	if _ceb.Type == ResultTypeError {
		return nil, _ceb
	}
	_egb := _bgbc[2]
	if _egb.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_agee + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0063\u006fupo\u006e r\u0061\u0074\u0065\u0020\u006f\u0066\u0020ty\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_afae := _egb.ValueNumber
	if _afae < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0043\u006f\u0075po\u006e\u0020\u0072\u0061\u0074\u0065\u0020\u0073\u0068o\u0075l\u0064 \u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_dfbge := _bgbc[3]
	if _dfbge.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_agee + " \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0079\u0069\u0065\u006cd\u0020\u0072\u0061\u0074\u0065\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_bdc := _dfbge.ValueNumber
	if _bdc < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006c\u0064\u0020r\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020\u0062\u0065\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	_eag := _bgbc[4]
	if _eag.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_agee + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u0065\u0071u\u0065n\u0063y\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_cbe := float64(int(_eag.ValueNumber))
	if !_degc(_cbe) {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_cccd := 0
	if _bgg == 6 && _bgbc[5].Type != ResultTypeEmpty {
		_cbbc := _bgbc[5]
		if _cbbc.Type != ResultTypeNumber {
			return nil, MakeErrorResult(_agee + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u006f\u0066 \u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_cccd = int(_cbbc.ValueNumber)
		if !_efb(_cccd) {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062a\u0073\u0069\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020"+_agee)
		}
	}
	return &durationArgs{_cdfc, _abcf, _afae, _bdc, _cbe, _cccd}, _aaa
}
func (_badf Result) String() string { return _badf.Value() }

// Eval evaluates the binary expression using the context given.
func (_ad BinaryExpr) Eval(ctx Context, ev Evaluator) Result {
	_fc := _ad._ag.Eval(ctx, ev)
	if _fc.Type == ResultTypeError {
		return _fc
	}
	_gaf := _ad._bd.Eval(ctx, ev)
	if _gaf.Type == ResultTypeError {
		return _gaf
	}
	if _fc.Type == _gaf.Type {
		if _fc.Type == ResultTypeArray {
			if !_cc(_fc.ValueArray, _gaf.ValueArray) {
				return MakeErrorResult("l\u0068\u0073\u002f\u0072\u0068\u0073 \u0073\u0068\u006f\u0075\u006c\u0064 \u0068\u0061\u0076\u0065\u0020\u0073\u0061m\u0065\u0020\u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006fn\u0073")
			}
			return _bdd(_ad._bc, _fc.ValueArray, _gaf.ValueArray)
		} else if _fc.Type == ResultTypeList {
			if len(_fc.ValueList) != len(_gaf.ValueList) {
				return MakeErrorResult("l\u0068\u0073\u002f\u0072\u0068\u0073 \u0073\u0068\u006f\u0075\u006c\u0064 \u0068\u0061\u0076\u0065\u0020\u0073\u0061m\u0065\u0020\u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006fn\u0073")
			}
			return _aa(_ad._bc, _fc.ValueList, _gaf.ValueList)
		}
	} else if _fc.Type == ResultTypeArray && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
		return _fab(_ad._bc, _fc.ValueArray, _gaf)
	} else if _fc.Type == ResultTypeList && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
		return _cgc(_ad._bc, _fc.ValueList, _gaf)
	}
	switch _ad._bc {
	case BinOpTypePlus:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeNumberResult(_fc.ValueNumber + _gaf.ValueNumber)
			}
		}
	case BinOpTypeMinus:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeNumberResult(_fc.ValueNumber - _gaf.ValueNumber)
			}
		}
	case BinOpTypeMult:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeNumberResult(_fc.ValueNumber * _gaf.ValueNumber)
			}
		}
	case BinOpTypeDiv:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				if _gaf.ValueNumber == 0 {
					return MakeErrorResultType(ErrorTypeDivideByZero, "\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079 \u007a\u0065\u0072\u006f")
				}
				return MakeNumberResult(_fc.ValueNumber / _gaf.ValueNumber)
			}
		}
	case BinOpTypeExp:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeNumberResult(_gg.Pow(_fc.ValueNumber, _gaf.ValueNumber))
			}
		}
	case BinOpTypeLT:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeBoolResult(_fc.ValueNumber < _gaf.ValueNumber)
			}
			if _fc.Type == ResultTypeString {
				return MakeBoolResult(_fc.ValueString < _gaf.ValueString)
			}
			if _fc.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if _fc.Type == ResultTypeString && _gaf.Type == ResultTypeNumber {
			return MakeBoolResult(false)
		} else if _fc.Type == ResultTypeNumber && _gaf.Type == ResultTypeString {
			return MakeBoolResult(true)
		} else if _fc.Type == ResultTypeEmpty && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
			return MakeBoolResult(true)
		} else if (_fc.Type == ResultTypeNumber || _fc.Type == ResultTypeString) && _gaf.Type == ResultTypeEmpty {
			return MakeBoolResult(false)
		}
	case BinOpTypeGT:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeBoolResult(_fc.ValueNumber > _gaf.ValueNumber)
			}
			if _fc.Type == ResultTypeString {
				return MakeBoolResult(_fc.ValueString > _gaf.ValueString)
			}
			if _fc.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if _fc.Type == ResultTypeString && _gaf.Type == ResultTypeNumber {
			return MakeBoolResult(true)
		} else if _fc.Type == ResultTypeNumber && _gaf.Type == ResultTypeString {
			return MakeBoolResult(false)
		} else if _fc.Type == ResultTypeEmpty && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
			return MakeBoolResult(false)
		} else if (_fc.Type == ResultTypeNumber || _fc.Type == ResultTypeString) && _gaf.Type == ResultTypeEmpty {
			return MakeBoolResult(true)
		}
	case BinOpTypeEQ:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeBoolResult(_fc.ValueNumber == _gaf.ValueNumber)
			}
			if _fc.Type == ResultTypeString {
				return MakeBoolResult(_fc.ValueString == _gaf.ValueString)
			}
			if _fc.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if (_fc.Type == ResultTypeString && _gaf.Type == ResultTypeNumber) || (_fc.Type == ResultTypeNumber && _gaf.Type == ResultTypeString) {
			return MakeBoolResult(false)
		} else if _fc.Type == ResultTypeEmpty && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
			return MakeBoolResult(_ed(_gaf))
		} else if (_fc.Type == ResultTypeNumber || _fc.Type == ResultTypeString) && _gaf.Type == ResultTypeEmpty {
			return MakeBoolResult(_ed(_fc))
		}
	case BinOpTypeNE:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeBoolResult(_fc.ValueNumber != _gaf.ValueNumber)
			}
			if _fc.Type == ResultTypeString {
				return MakeBoolResult(_fc.ValueString != _gaf.ValueString)
			}
			if _fc.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if (_fc.Type == ResultTypeString && _gaf.Type == ResultTypeNumber) || (_fc.Type == ResultTypeNumber && _gaf.Type == ResultTypeString) {
			return MakeBoolResult(true)
		} else if _fc.Type == ResultTypeEmpty && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
			return MakeBoolResult(!_ed(_gaf))
		} else if (_fc.Type == ResultTypeNumber || _fc.Type == ResultTypeString) && _gaf.Type == ResultTypeEmpty {
			return MakeBoolResult(!_ed(_fc))
		}
	case BinOpTypeLEQ:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeBoolResult(_fc.ValueNumber <= _gaf.ValueNumber)
			}
			if _fc.Type == ResultTypeString {
				return MakeBoolResult(_fc.ValueString <= _gaf.ValueString)
			}
			if _fc.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if _fc.Type == ResultTypeString && _gaf.Type == ResultTypeNumber {
			return MakeBoolResult(false)
		} else if _fc.Type == ResultTypeNumber && _gaf.Type == ResultTypeString {
			return MakeBoolResult(true)
		} else if _fc.Type == ResultTypeEmpty && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
			return MakeBoolResult(_ed(_gaf))
		} else if (_fc.Type == ResultTypeNumber || _fc.Type == ResultTypeString) && _gaf.Type == ResultTypeEmpty {
			return MakeBoolResult(_ed(_fc))
		}
	case BinOpTypeGEQ:
		if _fc.Type == _gaf.Type {
			if _fc.Type == ResultTypeNumber {
				return MakeBoolResult(_fc.ValueNumber >= _gaf.ValueNumber)
			}
			if _fc.Type == ResultTypeString {
				return MakeBoolResult(_fc.ValueString >= _gaf.ValueString)
			}
			if _fc.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if _fc.Type == ResultTypeString && _gaf.Type == ResultTypeNumber {
			return MakeBoolResult(true)
		} else if _fc.Type == ResultTypeNumber && _gaf.Type == ResultTypeString {
			return MakeBoolResult(false)
		} else if _fc.Type == ResultTypeEmpty && (_gaf.Type == ResultTypeNumber || _gaf.Type == ResultTypeString) {
			return MakeBoolResult(_ed(_gaf))
		} else if (_fc.Type == ResultTypeNumber || _fc.Type == ResultTypeString) && _gaf.Type == ResultTypeEmpty {
			return MakeBoolResult(_ed(_fc))
		}
	case BinOpTypeConcat:
		return MakeStringResult(_fc.Value() + _gaf.Value())
	}
	return MakeErrorResult("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006f\u0070")
}

// Eval evaluates and returns the result of an error expression.
func (_efc Error) Eval(ctx Context, ev Evaluator) Result { return MakeErrorResult(_efc._ce) }

var _ggd = []*_af.Regexp{}

// Error is an error expression.
type Error struct{ _ce string }

func _ggc(_bcdc int) bool { return _bcdc == 0 || _bcdc == 4 }

// Evaluator is the interface for a formula evaluator.  This is needed so we can
// pass it to the spreadsheet to let it evaluate formula cells before returning
// the results.
// NOTE: in order to implement Evaluator without cache embed noCache in it.
type Evaluator interface {
	Eval(_ebe Context, formula string) Result
	SetCache(_effd string, _bda Result)
	GetFromCache(_cded string) (Result, bool)
	LastEvalIsRef() bool
}

// Eval evaluates and returns a boolean.
func (_fad Bool) Eval(ctx Context, ev Evaluator) Result { return MakeBoolResult(_fad._ccda) }
func _dfaca(_gccb []Result, _ccce bool) (float64, float64) {
	_debe := 0.0
	_ebdf := 0.0
	for _, _abbd := range _gccb {
		switch _abbd.Type {
		case ResultTypeNumber:
			if _ccce || !_abbd.IsBoolean {
				_ebdf += _abbd.ValueNumber
				_debe++
			}
		case ResultTypeList, ResultTypeArray:
			_aedb, _acdb := _dfaca(_abbd.ListValues(), _ccce)
			_ebdf += _aedb
			_debe += _acdb
		case ResultTypeString:
			if _ccce {
				_debe++
			}
		case ResultTypeEmpty:
		}
	}
	return _ebdf, _debe
}

// Combin is an implementation of the Excel COMBINA function whic returns the
// number of combinations.
func Combin(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004d\u0042\u0049\u004e\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bacg := args[0].AsNumber()
	_eaca := args[1].AsNumber()
	if _bacg.Type != ResultTypeNumber || _eaca.Type != ResultTypeNumber {
		return MakeErrorResult("C\u004f\u004d\u0042\u0049\u004e\u0028)\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_cfae := _gg.Trunc(_bacg.ValueNumber)
	_cgbb := _gg.Trunc(_eaca.ValueNumber)
	if _cgbb > _cfae {
		return MakeErrorResult("\u0043O\u004d\u0042\u0049\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006b\u0020\u003c\u003d\u0020\u006e")
	}
	if _cgbb == _cfae || _cgbb == 0 {
		return MakeNumberResult(1)
	}
	_fcge := float64(1)
	for _dcbb := float64(1); _dcbb <= _cgbb; _dcbb++ {
		_fcge *= (_cfae + 1 - _dcbb) / _dcbb
	}
	return MakeNumberResult(_fcge)
}

var _aebeb = false

const _abg = "\u0028\u0028\u006a\u0061\u006e|\u006a\u0061\u006e\u0075\u0061\u0072\u0079\u0029\u007c\u0028\u0066\u0065\u0062\u007c\u0066\u0065\u0062\u0072\u0075a\u0072\u0079\u0029\u007c\u0028\u006da\u0072\u007c\u006da\u0072\u0063\u0068\u0029\u007c\u0028\u0061\u0070\u0072\u007c\u0061\u0070\u0072\u0069\u006c\u0029\u007c\u0028\u006d\u0061\u0079\u0029\u007c\u0028j\u0075\u006e\u007cj\u0075\u006e\u0065\u0029\u007c\u0028\u006a\u0075\u006c\u007c\u006a\u0075\u006c\u0079\u0029\u007c\u0028a\u0075\u0067\u007c\u0061\u0075\u0067\u0075\u0073t\u0029\u007c\u0028\u0073\u0065\u0070\u007c\u0073\u0065\u0070\u0074\u0065\u006d\u0062\u0065\u0072\u0029\u007c\u0028o\u0063\u0074\u007c\u006f\u0063\u0074\u006f\u0062\u0065\u0072\u0029\u007c\u0028\u006e\u006f\u0076\u007c\u006e\u006f\u0076\u0065\u006d\u0062e\u0072\u0029\u007c\u0028\u0064\u0065\u0063\u007c\u0064\u0065\u0063\u0065\u006d\u0062\u0065\u0072\u0029\u0029"

// String returns a string representation for Negate.
func (_eabb Negate) String() string { return "\u002d" + _eabb._bddff.String() }
func _agcgb(_eeeg yyLexer, _dgfa *yySymType) (_abbff, _defa int) {
	_defa = 0
	_abbff = _eeeg.Lex(_dgfa)
	if _abbff <= 0 {
		_defa = _eabad[0]
		goto _aecb
	}
	if _abbff < len(_eabad) {
		_defa = _eabad[_abbff]
		goto _aecb
	}
	if _abbff >= _agaaf {
		if _abbff < _agaaf+len(_ccbd) {
			_defa = _ccbd[_abbff-_agaaf]
			goto _aecb
		}
	}
	for _bebag := 0; _bebag < len(_dfeac); _bebag += 2 {
		_defa = _dfeac[_bebag+0]
		if _defa == _abbff {
			_defa = _dfeac[_bebag+1]
			goto _aecb
		}
	}
_aecb:
	if _defa == 0 {
		_defa = _ccbd[1]
	}
	if _gfeg >= 3 {
		_b.Printf("l\u0065\u0078\u0020\u0025\u0073\u0028\u0025\u0064\u0029\u000a", _faafa(_defa), uint(_abbff))
	}
	return _abbff, _defa
}

var _agdgd = []ri{{1000, "\u004d"}, {995, "\u0056\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {495, "\u0056\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// Not is an implementation of the Excel NOT() function and takes a single
// argument.
func Not(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004eO\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	switch args[0].Type {
	case ResultTypeError:
		return args[0]
	case ResultTypeString, ResultTypeList:
		return MakeErrorResult("\u004e\u004f\u0054\u0020\u0065\u0078\u0070\u0065\u0063\u0074s\u0020\u0061\u0020\u006e\u0075\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	case ResultTypeNumber:
		return MakeBoolResult(!(args[0].ValueNumber != 0))
	default:
		return MakeErrorResult("u\u006e\u0068\u0061\u006e\u0064\u006ce\u0064\u0020\u004e\u004f\u0054\u0020\u0061\u0072\u0067u\u006d\u0065\u006et\u0020t\u0079\u0070\u0065")
	}
}
func (_dabac *ivr) SetOffset(col, row uint32) {}

// Reference returns an invalid reference for ConstArrayExpr.
func (_dfff ConstArrayExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }
func _dbbf(_dded string) (int, int, int, bool, Result) {
	_gbc := ""
	_cbff := []string{}
	for _fbe, _eggd := range _gcc {
		_cbff = _eggd.FindStringSubmatch(_dded)
		if len(_cbff) > 1 {
			_gbc = _fbe
			break
		}
	}
	if _gbc == "" {
		return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
	}
	_cagf := false
	var _aafd, _cec, _fcd int
	var _aeca error
	switch _gbc {
	case "\u006d\u006d\u002f\u0064\u0064\u002f\u0079\u0079":
		_cec, _aeca = _ga.Atoi(_cbff[1])
		if _aeca != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_fcd, _aeca = _ga.Atoi(_cbff[3])
		if _aeca != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_aafd, _aeca = _ga.Atoi(_cbff[5])
		if _aeca != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		if _aafd < 0 || _aafd > 9999 || (_aafd > 99 && _aafd < 1900) {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_aafd = _abad(_aafd)
		_cagf = _cbff[8] == ""
	case "\u006dm\u0020\u0064\u0064\u002c\u0020\u0079y":
		_cec = _dda[_cbff[1]]
		_fcd, _aeca = _ga.Atoi(_cbff[14])
		if _aeca != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_aafd, _aeca = _ga.Atoi(_cbff[16])
		if _aeca != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		if _aafd < 0 || _aafd > 9999 || (_aafd > 99 && _aafd < 1900) {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_aafd = _abad(_aafd)
		_cagf = _cbff[19] == ""
	case "\u0079\u0079\u002d\u006d\u006d\u002d\u0064\u0064":
		_aggd, _aeg := _ga.Atoi(_cbff[1])
		if _aeg != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_fee, _aeg := _ga.Atoi(_cbff[3])
		if _aeg != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_gdg, _aeg := _ga.Atoi(_cbff[5])
		if _aeg != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		if _aggd >= 1900 && _aggd < 10000 {
			_aafd = _aggd
			_cec = _fee
			_fcd = _gdg
		} else if _aggd > 0 && _aggd < 13 {
			_cec = _aggd
			_fcd = _fee
			_aafd = _gdg
		} else {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_cagf = _cbff[8] == ""
	case "y\u0079\u002d\u006d\u006d\u0053\u0074\u0072\u002d\u0064\u0064":
		_aafd, _aeca = _ga.Atoi(_cbff[16])
		if _aeca != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_cec = _dda[_cbff[3]]
		_fcd, _aeca = _ga.Atoi(_cbff[1])
		if _aeca != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
		}
		_cagf = _cbff[19] == ""
	}
	if !_bcfa(_aafd, _cec, _fcd) {
		return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _ddda)
	}
	return _aafd, _cec, _fcd, _cagf, _aaa
}

// ISNUMBER is an implementation of the Excel ISNUMBER() function.
func IsNumber(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053NU\u004d\u0042\u0045R\u0028\u0029\u0020\u0061cce\u0070ts\u0020\u0061\u0020\u0073\u0069\u006e\u0067le\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeNumber)
}

const _ecc = 86400000000000
const _bdaada = 57371

// Update returns the same object as updating sheet references does not affect named ranges.
func (_ebaae NamedRangeRef) Update(q *_egg.UpdateQuery) Expression { return _ebaae }

// GetLocked returns FALSE for the invalid reference context.
func (_cfda *ivr) GetLocked(cellRef string) bool { return false }

// ConstArrayExpr is a constant array expression.
type ConstArrayExpr struct{ _dd [][]Expression }

func _bbge(_aefb []Result, _afage rmode) Result {
	if len(_aefb) != 2 {
		return MakeErrorResult("\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_agefb := _aefb[0].AsNumber()
	if _agefb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bgffc := _aefb[1].AsNumber()
	if _bgffc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ccef := _bgffc.ValueNumber
	_gaca := _agefb.ValueNumber
	_gegf := 1.0
	if _ccef > 0 {
		_gegf = _gg.Pow(1/10.0, _ccef)
	} else {
		_gegf = _gg.Pow(10.0, -_ccef)
	}
	_gaca, _abgbb := _gg.Modf(_gaca / _gegf)
	switch _afage {
	case _egee:
		const _geeea = 0.499999999
		if _abgbb >= _geeea {
			_gaca++
		} else if _abgbb <= -_geeea {
			_gaca--
		}
	case _bdfce:
	case _fdddb:
		if _abgbb > 0 {
			_gaca++
		} else if _abgbb < 0 {
			_gaca--
		}
	}
	return MakeNumberResult(_gaca * _gegf)
}

// ISEVEN is an implementation of the Excel ISEVEN() function.
func IsEven(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0045VE\u004e\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070t\u0073 \u0061 \u0073i\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0045\u0056\u0045\u004e \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ggee := int(args[0].ValueNumber)
	return MakeBoolResult(_ggee == _ggee/2*2)
}

// Min is an implementation of the Excel MIN() function.
func Min(args []Result) Result { return _bcfdf(args, false) }

// MakeErrorResultType makes an error result of a given type with a specified
// debug message
func MakeErrorResultType(t ErrorType, msg string) Result {
	switch t {
	case ErrorTypeNull:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0055\u004c\u004c\u0021", ErrorMessage: msg}
	case ErrorTypeValue:
		return Result{Type: ResultTypeError, ValueString: "\u0023V\u0041\u004c\u0055\u0045\u0021", ErrorMessage: msg}
	case ErrorTypeRef:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u0052\u0045F\u0021", ErrorMessage: msg}
	case ErrorTypeName:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0041\u004d\u0045\u003f", ErrorMessage: msg}
	case ErrorTypeNum:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0055M\u0021", ErrorMessage: msg}
	case ErrorTypeSpill:
		return Result{Type: ResultTypeError, ValueString: "\u0023S\u0050\u0049\u004c\u004c\u0021", ErrorMessage: msg}
	case ErrorTypeNA:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u002f\u0041", ErrorMessage: msg}
	case ErrorTypeDivideByZero:
		return Result{Type: ResultTypeError, ValueString: "\u0023D\u0049\u0056\u002f\u0030\u0021", ErrorMessage: msg}
	default:
		return Result{Type: ResultTypeError, ValueString: "\u0023V\u0041\u004c\u0055\u0045\u0021", ErrorMessage: msg}
	}
}
func _eebd(_cade []Result) (float64, float64, Result) {
	_fagd := 0.0
	_gcfc := 1.0
	for _, _babe := range _cade {
		switch _babe.Type {
		case ResultTypeNumber:
			_fagd += _babe.ValueNumber
			_gcfc *= _fgbg(_babe.ValueNumber)
		case ResultTypeList, ResultTypeArray:
			_dadf, _dgbec, _egbee := _eebd(_babe.ListValues())
			_fagd += _dadf
			_gcfc *= _fgbg(_dgbec)
			if _egbee.Type == ResultTypeError {
				return 0, 0, _egbee
			}
		case ResultTypeString:
			return 0, 0, MakeErrorResult("M\u0055\u004c\u0054\u0049\u004e\u004f\u004d\u0049\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
		case ResultTypeError:
			return 0, 0, _babe
		}
	}
	return _fagd, _gcfc, _aaa
}

// Eval evaluates a range returning a list of results or an error.
func (_cgdfg Range) Eval(ctx Context, ev Evaluator) Result {
	_bggb := _cgdfg._ecgg.Reference(ctx, ev)
	_gacdg := _cgdfg._bgfde.Reference(ctx, ev)
	_fefae := _ddad(_bggb, _gacdg)
	if _bggb.Type == ReferenceTypeCell && _gacdg.Type == ReferenceTypeCell {
		if _abdd, _baade := ev.GetFromCache(_fefae); _baade {
			return _abdd
		} else {
			_dafaf := _bdgac(ctx, ev, _bggb.Value, _gacdg.Value)
			ev.SetCache(_fefae, _dafaf)
			return _dafaf
		}
	}
	return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072a\u006e\u0067\u0065\u0020" + _fefae)
}

// NewEvaluator constructs a new defEval object which is the default formula evaluator.
func NewEvaluator() Evaluator { _gae := &defEval{}; _gae.evCache = _fdba(); return _gae }

// Searchb is an implementation of the Excel SEARCHB().
func Searchb(ctx Context, ev Evaluator, args []Result) Result {
	if !ctx.IsDBCS() {
		return Search(args)
	}
	_bbgc, _fdff := _gfag("\u0046\u0049\u004e\u0044", args)
	if _fdff.Type != ResultTypeEmpty {
		return _fdff
	}
	_cgdfe := _fa.ToLower(_bbgc._fcac)
	_acee := _fa.ToLower(_bbgc._edegc)
	if _cgdfe == "" {
		return MakeNumberResult(1.0)
	}
	_bgbg := _bbgc._edafc - 1
	_cdggf := 1
	_abgbf := 0
	for _ebcd := range _acee {
		if _ebcd != 0 {
			_gdfda := 1
			if _ebcd-_abgbf > 1 {
				_gdfda = 2
			}
			_cdggf += _gdfda
		}
		if _cdggf > _bgbg {
			_gcfa := _d.Index(_cgdfe, _acee[_ebcd:])
			if _gcfa == 0 {
				return MakeNumberResult(float64(_cdggf))
			}
		}
		_abgbf = _ebcd
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// Ppmt implements the Excel PPPMT function.
func Ppmt(args []Result) Result {
	_gdcd := len(args)
	if _gdcd < 4 || _gdcd > 6 {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006ff\u0020\u0066\u006f\u0075\u0072\u0020a\u006e\u0064\u0020s\u0069\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_bef := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004dT\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ddfc := args[1].ValueNumber
	if _ddfc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "P\u0050\u004d\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020p\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069v\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cbddd := args[2].ValueNumber
	if _cbddd < _ddfc {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064s\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065s\u0073\u0020\u0074\u0068\u0061\u006e \u0070\u0065\u0072i\u006f\u0064")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_agfga := args[3].ValueNumber
	_degff := 0.0
	if _gdcd >= 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_degff = args[4].ValueNumber
	}
	_gabc := 0
	if _gdcd == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("P\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_gabc = int(args[5].ValueNumber)
		if _gabc != 0 {
			_gabc = 1
		}
	}
	return MakeNumberResult(_dgfg(_bef, _cbddd, _agfga, _degff, _gabc) - _aacfa(_bef, _ddfc, _cbddd, _agfga, _degff, _gabc))
}

// SetLocked does nothing for the invalid reference context.
func (_eafg *ivr) SetLocked(cellRef string, locked bool) {}
func _eab(_cced string) bool {
	for _, _ddae := range _ggd {
		_bfae := _ddae.FindStringSubmatch(_cced)
		if len(_bfae) > 1 {
			return true
		}
	}
	return false
}

// NewBool constructs a new boolean expression.
func NewBool(v string) Expression {
	_ee, _ab := _ga.ParseBool(v)
	if _ab != nil {
		_cg.Log("\u0065\u0072\u0072\u006f\u0072\u0020p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u006d\u0075\u006ca\u0020\u0062\u006f\u006f\u006c\u0020\u0025s\u003a\u0020\u0025\u0073", v, _ab)
	}
	return Bool{_ee}
}

// RoundDown is an implementation of the Excel ROUNDDOWN function that rounds a number
// down to a specified number of digits.
func RoundDown(args []Result) Result { return _bbge(args, _bdfce) }

// Today is an implementation of the Excel TODAY() function.
func Today(args []Result) Result {
	if len(args) > 0 {
		return MakeErrorResult("\u0054\u004f\u0044A\u0059\u0020\u0064\u006fe\u0073\u006e\u0027\u0074\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_deeg := _ea.Now()
	_, _ade := _deeg.Zone()
	_bgdc := _fdc(_ecf, _deeg.Unix()+int64(_ade)) + 1
	return MakeNumberResult(_bgdc)
}

const _eggdg = "\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065U\u006e\u006b\u006e\u006f\u0077\u006e\u0052\u0065\u0073u\u006c\u0074\u0054y\u0070\u0065\u004e\u0075\u006d\u0062\u0065\u0072\u0052\u0065s\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0053\u0074\u0072\u0069\u006e\u0067\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0073\u0074\u0052\u0065\u0073\u0075lt\u0054\u0079p\u0065\u0041r\u0072\u0061\u0079\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0045\u0072\u0072\u006f\u0072\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0045\u006d\u0070\u0074\u0079"
const _gcgc = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u0028\u0020\u0028\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"
const _caea = 57365

func _cfbd(_gaeae Context, _babf, _ccbgd int) (string, string) {
	_fbafd := "\u0041" + _ga.Itoa(_babf)
	_bgef := _gaeae.LastColumn(_babf, _ccbgd)
	_gaedc := _bgef + _ga.Itoa(_ccbgd)
	return _fbafd, _gaedc
}

// Oddlyield implements the Excel ODDLYIELD function.
func Oddlyield(args []Result) Result {
	if len(args) != 7 && len(args) != 8 {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u006f\u0072\u0020\u0065\u0069\u0067\u0068\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dgfdd, _debc, _agaef := _daea(args[0], args[1], "\u004fD\u0044\u004c\u0059\u0049\u0045\u004cD")
	if _agaef.Type == ResultTypeError {
		return _agaef
	}
	_bagb, _agaef := _dddb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _agaef.Type == ResultTypeError {
		return _agaef
	}
	if _bagb >= _dgfdd {
		return MakeErrorResultType(ErrorTypeNum, "\u004c\u0061\u0073\u0074\u0020i\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0064\u0061\u0074\u0065\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074e")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_gafb := args[3].ValueNumber
	if _gafb < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("O\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006ff \u0074\u0079p\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_fcga := args[4].ValueNumber
	if _fcga <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0073h\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[5].Type != ResultTypeNumber {
		return MakeErrorResult("\u004fD\u0044\u004cY\u0049\u0045\u004c\u0044 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_acacc := args[5].ValueNumber
	if _acacc < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	if args[6].Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_afge := float64(int(args[6].ValueNumber))
	if !_degc(_afge) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_aabf := 0
	if len(args) == 8 && args[7].Type != ResultTypeEmpty {
		if args[7].Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0062a\u0073\u0069\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
		}
		_aabf = int(args[7].ValueNumber)
		if !_efb(_aabf) {
			return MakeErrorResultType(ErrorTypeNum, "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0062\u0061\u0073\u0069s\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044")
		}
	}
	_fgbe, _agaef := _cbfa(_bagb, _debc, _aabf)
	if _agaef.Type == ResultTypeError {
		return _agaef
	}
	_fgbe *= _afge
	_feff, _agaef := _cbfa(_dgfdd, _debc, _aabf)
	if _agaef.Type == ResultTypeError {
		return _agaef
	}
	_feff *= _afge
	_agfg, _agaef := _cbfa(_bagb, _dgfdd, _aabf)
	if _agaef.Type == ResultTypeError {
		return _agaef
	}
	_agfg *= _afge
	_egde := _acacc + _fgbe*100*_gafb/_afge
	_egde /= _fcga + _agfg*100*_gafb/_afge
	_egde--
	_egde *= _afge / _feff
	return MakeNumberResult(_egde)
}
func (_ffcgf *ivr) NamedRange(ref string) Reference { return ReferenceInvalid }
func (_gebc *ivr) Sheet(name string) Context        { return _gebc }
func (_fcgbb HorizontalRange) horizontalRangeReference() string {
	return _b.Sprintf("\u0025\u0064\u003a%\u0064", _fcgbb._adac, _fcgbb._gfea)
}

const _eacgg = 57361

// Count implements the COUNT function.
func Count(args []Result) Result { return MakeNumberResult(_gcfe(args, _baead)) }

// Munit is an implementation of the Excel MUNIT function that returns an
// identity matrix.
func Munit(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0055\u004eIT\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073 \u006fn\u0065 \u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069\u006e\u0070\u0075\u0074")
	}
	_bgba := args[0].AsNumber()
	if _bgba.Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0055\u004eIT\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073 \u006fn\u0065 \u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069\u006e\u0070\u0075\u0074")
	}
	_eabfe := int(_bgba.ValueNumber)
	_ffeg := make([][]Result, 0, _eabfe)
	for _dafe := 0; _dafe < _eabfe; _dafe++ {
		_dcgd := make([]Result, _eabfe)
		for _geec := 0; _geec < _eabfe; _geec++ {
			if _dafe == _geec {
				_dcgd[_geec] = MakeNumberResult(1.0)
			} else {
				_dcgd[_geec] = MakeNumberResult(0.0)
			}
		}
		_ffeg = append(_ffeg, _dcgd)
	}
	return MakeArrayResult(_ffeg)
}

// True is an implementation of the Excel TRUE() function.  It takes no
// arguments.
func True(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0054\u0052\u0055E \u0074\u0061\u006b\u0065\u0073\u0020\u006e\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(true)
}

const _fdcf = 57376

// Couppcd implements the Excel COUPPCD function.
func Couppcd(args []Result) Result {
	_ffcc, _cafeg := _gdgb(args, "\u0043O\u0055\u0050\u0050\u0043\u0044")
	if _cafeg.Type == ResultTypeError {
		return _cafeg
	}
	_ggga := _ddef(_ffcc._eebf)
	_aagce := _ddef(_ffcc._edge)
	_ccbfc := _ffcc._eda
	_abfg := _ffcc._ceca
	_edca := _efe(_ggga, _aagce, _ccbfc, _abfg)
	_bagd, _bbbc, _bdbe := _edca.Date()
	return MakeNumberResult(_fag(_bagd, int(_bbbc), _bdbe))
}

// Left implements the Excel LEFT(string,[n]) function which returns the
// leftmost n characters.
func Left(args []Result) Result {
	_ceadb := 1
	switch len(args) {
	case 1:
	case 2:
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("\u004c\u0045F\u0054\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075me\u006e\u0074")
		}
		_ceadb = int(args[1].ValueNumber)
		if _ceadb < 0 {
			return MakeErrorResult("\u004c\u0045\u0046T \u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020n\u0075m\u0062e\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u003e\u003d\u0020\u0030")
		}
		if _ceadb == 0 {
			return MakeStringResult("")
		}
	default:
		return MakeErrorResult("\u004c\u0045\u0046T \u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeList {
		return MakeErrorResult("\u004c\u0045\u0046T\u0020\u0063\u0061\u006e'\u0074\u0020\u0062\u0065\u0020\u0063\u0061l\u006c\u0065\u0064\u0020\u006f\u006e\u0020\u0061\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_bcge := args[0].Value()
	if _ceadb > len(_bcge) {
		return MakeStringResult(_bcge)
	}
	return MakeStringResult(_bcge[0:_ceadb])
}
func _cfa(_eeff, _eeb, _bgb, _eee int) int {
	if !_ggc(_eee) {
		return _bgb
	}
	_gefg := _bgb
	_abdc := _eccg(_eeff, _eeb)
	if _gefg > 30 || _bgb >= _abdc || _gefg >= _abdc {
		_gefg = 30
	}
	return _gefg
}

type rmode byte

// NewEmptyExpr constructs a new empty expression.
func NewEmptyExpr() Expression { return EmptyExpr{} }
func init() {
	_edc()
	RegisterFunction("\u0044\u0041\u0054\u0045", Date)
	RegisterFunction("\u0044A\u0054\u0045\u0044\u0049\u0046", DateDif)
	RegisterFunction("\u0044A\u0054\u0045\u0056\u0041\u004c\u0055E", DateValue)
	RegisterFunction("\u0044\u0041\u0059", Day)
	RegisterFunction("\u0044\u0041\u0059\u0053", Days)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0044\u0041\u0059\u0053", Days)
	RegisterFunction("\u0045\u0044\u0041T\u0045", Edate)
	RegisterFunction("\u0045O\u004d\u004f\u004e\u0054\u0048", Eomonth)
	RegisterFunction("\u004d\u0049\u004e\u0055\u0054\u0045", Minute)
	RegisterFunction("\u004d\u004f\u004eT\u0048", Month)
	RegisterFunction("\u004e\u004f\u0057", Now)
	RegisterFunction("\u0054\u0049\u004d\u0045", Time)
	RegisterFunction("\u0054I\u004d\u0045\u0056\u0041\u004c\u0055E", TimeValue)
	RegisterFunction("\u0054\u004f\u0044A\u0059", Today)
	RegisterFunctionComplex("\u0059\u0045\u0041\u0052", Year)
	RegisterFunction("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043", YearFrac)
}

const _cac = "\u0028\u0020\u0028" + _dbfc + "\u007c" + _gcgc + "\u007c" + _dbdd + "\u007c" + _ddaf + "\u0029\u0029\u003f\u0024"

// SumIf implements the SUMIF function.
func SumIf(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0053\u0055\u004d\u0049\u0046\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0068\u0072e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_eegb := args[0]
	if _eegb.Type != ResultTypeArray && _eegb.Type != ResultTypeList {
		return MakeErrorResult("\u0053\u0055\u004d\u0049\u0046\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0066i\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_ceaa := _aefda(_eegb)
	_cbedd := args[2]
	if _cbedd.Type != ResultTypeArray && _cbedd.Type != ResultTypeList {
		return MakeErrorResult("\u0053\u0055\u004dI\u0046\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0061\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_cadg := _aefda(_cbedd)
	_gbbd := _adebe(args[1])
	_eefa := 0.0
	for _effc, _afbe := range _ceaa {
		for _cfbce, _fggd := range _afbe {
			if _aefe(_fggd, _gbbd) {
				_eefa += _cadg[_effc][_cfbce].ValueNumber
			}
		}
	}
	return MakeNumberResult(_eefa)
}

const _eead = 57346

// Max is an implementation of the Excel MAX() function.
func Max(args []Result) Result { return _add(args, false) }

// NewConstArrayExpr constructs a new constant array expression with a given data.
func NewConstArrayExpr(data [][]Expression) Expression { return &ConstArrayExpr{data} }

type countMode byte

func (_gceb PrefixHorizontalRange) horizontalRangeReference(_afcdf string) string {
	return _b.Sprintf("\u0025\u0073\u0021\u0025\u0064\u003a\u0025\u0064", _afcdf, _gceb._eadb, _gceb._abgg)
}

const _ggdfe = 57351

// CeilingMath implements _xlfn.CEILING.MATH which rounds numbers to the nearest
// multiple of the second argument, toward or away from zero as specified by the
// third argument.
func CeilingMath(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043E\u0049\u004cI\u004e\u0047\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006ee\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0043E\u0049\u004cI\u004e\u0047\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u0061l\u006c\u006f\u0077\u0073\u0020\u0061t\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dbge := args[0].AsNumber()
	if _dbge.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u004dA\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061 \u006eu\u006d\u0062\u0065\u0072")
	}
	_gcde := float64(1)
	if _dbge.ValueNumber < 0 {
		_gcde = -1
	}
	if len(args) > 1 {
		_ggbe := args[1].AsNumber()
		if _ggbe.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0043\u0045\u0049\u004c\u0049\u004e\u0047.\u004d\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_gcde = _ggbe.ValueNumber
	}
	_gefa := float64(1)
	if len(args) > 2 {
		_ccdfg := args[2].AsNumber()
		if _ccdfg.Type != ResultTypeNumber {
			return MakeErrorResult("\u0074\u0068\u0069\u0072\u0064\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u004dA\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061 \u006eu\u006d\u0062\u0065\u0072")
		}
		_gefa = _ccdfg.ValueNumber
	}
	if len(args) == 1 {
		return MakeNumberResult(_gg.Ceil(_dbge.ValueNumber))
	}
	_gecb := _dbge.ValueNumber
	_gecb, _bdaad := _gg.Modf(_gecb / _gcde)
	if _bdaad != 0 {
		if _dbge.ValueNumber > 0 {
			_gecb++
		} else if _gefa < 0 {
			_gecb--
		}
	}
	return MakeNumberResult(_gecb * _gcde)
}

var _aaa Result = MakeEmptyResult()

func (_ddafa *Lexer) lex(_dceda _e.Reader) {
	_acdce, _ceab, _fecae := 0, 0, 0
	_defcd := -1
	_dage, _gecbd, _bafe := 0, 0, 0
	_ = _bafe
	_dfaeb := 1
	_ = _dfaeb
	_efdb := make([]byte, 4096)
	_aaff := false
	for !_aaff {
		_eaab := 0
		if _dage > 0 {
			_eaab = _ceab - _dage
		}
		_ceab = 0
		_dfbgd, _eeeef := _dceda.Read(_efdb[_eaab:])
		if _dfbgd == 0 || _eeeef != nil {
			_aaff = true
		}
		_fecae = _dfbgd + _eaab
		if _fecae < len(_efdb) {
			_defcd = _fecae
		}
		{
			_acdce = _gabb
			_dage = 0
			_gecbd = 0
			_bafe = 0
		}
		{
			var _befd int
			var _eegg uint
			if _ceab == _fecae {
				goto _aaecg
			}
			if _acdce == 0 {
				goto _gffea
			}
		_bfgcb:
			_befd = int(_afbef[_acdce])
			_eegg = uint(_ffdbc[_befd])
			_befd++
			for ; _eegg > 0; _eegg-- {
				_befd++
				switch _ffdbc[_befd-1] {
				case 2:
					_dage = _ceab
				}
			}
			switch _acdce {
			case 30:
				switch _efdb[_ceab] {
				case 34:
					goto _ddcga
				case 35:
					goto _gfaf
				case 36:
					goto _baada
				case 38:
					goto _gggg
				case 39:
					goto _fdcb
				case 40:
					goto _ceae
				case 41:
					goto _eddgb
				case 42:
					goto _feae
				case 43:
					goto _abcdga
				case 44:
					goto _ggafb
				case 45:
					goto _afeag
				case 47:
					goto _bffe
				case 58:
					goto _baeae
				case 59:
					goto _feag
				case 60:
					goto _ddeee
				case 61:
					goto _efba
				case 62:
					goto _dafbf
				case 63:
					goto _dafc
				case 70:
					goto _ecdf
				case 84:
					goto _gdab
				case 92:
					goto _agegg
				case 94:
					goto _acgce
				case 95:
					goto _ecad
				case 123:
					goto _aegef
				case 125:
					goto _cfdb
				}
				switch {
				case _efdb[_ceab] < 65:
					switch {
					case _efdb[_ceab] > 37:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ffccbd
						}
					case _efdb[_ceab] >= 33:
						goto _dafc
					}
				case _efdb[_ceab] > 90:
					switch {
					case _efdb[_ceab] > 93:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _cfgg
						}
					case _efdb[_ceab] >= 91:
						goto _dafc
					}
				default:
					goto _ddead
				}
				goto _efea
			case 1:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _caedcd
				case 123:
					goto _caedcd
				case 125:
					goto _caedcd
				}
				switch {
				case _efdb[_ceab] < 37:
					if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
						goto _caedcd
					}
				case _efdb[_ceab] > 45:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _caedcd
						}
					case _efdb[_ceab] >= 58:
						goto _caedcd
					}
				default:
					goto _caedcd
				}
				goto _efea
			case 0:
				goto _gffea
			case 2:
				if _efdb[_ceab] == 34 {
					goto _daad
				}
				goto _ddcga
			case 31:
				if _efdb[_ceab] == 34 {
					goto _ddcga
				}
				goto _feee
			case 3:
				switch _efdb[_ceab] {
				case 78:
					goto _fbdce
				case 82:
					goto _efagd
				}
				goto _dafc
			case 4:
				switch _efdb[_ceab] {
				case 47:
					goto _dafbe
				case 85:
					goto _fffe
				}
				goto _dafc
			case 5:
				if _efdb[_ceab] == 65 {
					goto _abbdg
				}
				goto _dafc
			case 6:
				switch _efdb[_ceab] {
				case 76:
					goto _dbfea
				case 77:
					goto _gcgdc
				}
				goto _dafc
			case 7:
				if _efdb[_ceab] == 76 {
					goto _gcgdc
				}
				goto _dafc
			case 8:
				if _efdb[_ceab] == 33 {
					goto _abbdg
				}
				goto _dafc
			case 9:
				if _efdb[_ceab] == 69 {
					goto _ebae
				}
				goto _dafc
			case 10:
				if _efdb[_ceab] == 70 {
					goto _bcgf
				}
				goto _dafc
			case 11:
				if _efdb[_ceab] == 33 {
					goto _cgbbg
				}
				goto _dafc
			case 12:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _dafc
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 45 {
							goto _dafc
						}
					case _efdb[_ceab] >= 34:
						goto _dafc
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] < 65:
						if 58 <= _efdb[_ceab] && _efdb[_ceab] <= 63 {
							goto _dafc
						}
					case _efdb[_ceab] > 90:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _dafc
						}
					default:
						goto _gbace
					}
				default:
					goto _cbbgd
				}
				goto _efea
			case 13:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _dafc
				case 58:
					goto _gfgeg
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 45 {
							goto _dafc
						}
					case _efdb[_ceab] >= 34:
						goto _dafc
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _dafc
						}
					case _efdb[_ceab] >= 59:
						goto _dafc
					}
				default:
					goto _cbbgd
				}
				goto _efea
			case 14:
				if _efdb[_ceab] == 36 {
					goto _bcgg
				}
				if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
					goto _fecbe
				}
				goto _caedcd
			case 15:
				if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
					goto _fecbe
				}
				goto _caedcd
			case 32:
				if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
					goto _fecbe
				}
				goto _fdgb
			case 16:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 47:
					goto _dafc
				case 58:
					goto _aega
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 45:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _bdcb
						}
					case _efdb[_ceab] >= 34:
						goto _dafc
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] > 90:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _dafc
						}
					case _efdb[_ceab] >= 65:
						goto _gbace
					}
				default:
					goto _dafc
				}
				goto _efea
			case 17:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _caedcd
				case 123:
					goto _caedcd
				case 125:
					goto _caedcd
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 45 {
							goto _caedcd
						}
					case _efdb[_ceab] >= 34:
						goto _caedcd
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _caedcd
						}
					case _efdb[_ceab] >= 58:
						goto _caedcd
					}
				default:
					goto _bdcb
				}
				goto _efea
			case 33:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _dbeae
				case 123:
					goto _dbeae
				case 125:
					goto _dbeae
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 45 {
							goto _dbeae
						}
					case _efdb[_ceab] >= 34:
						goto _dbeae
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _dbeae
						}
					case _efdb[_ceab] >= 58:
						goto _dbeae
					}
				default:
					goto _bdcb
				}
				goto _efea
			case 18:
				if _efdb[_ceab] == 36 {
					goto _defcg
				}
				if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
					goto _fbbaf
				}
				goto _caedcd
			case 19:
				if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
					goto _fbbaf
				}
				goto _caedcd
			case 34:
				if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
					goto _fbbaf
				}
				goto _efbf
			case 20:
				switch _efdb[_ceab] {
				case 39:
					goto _dafc
				case 42:
					goto _dafc
				case 47:
					goto _dafc
				case 58:
					goto _dafc
				case 63:
					goto _dafc
				}
				if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 93 {
					goto _dafc
				}
				goto _geffe
			case 21:
				switch _efdb[_ceab] {
				case 39:
					goto _fdffce
				case 42:
					goto _dafc
				case 47:
					goto _dafc
				case 58:
					goto _dafc
				case 63:
					goto _dafc
				}
				if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 93 {
					goto _dafc
				}
				goto _geffe
			case 22:
				if _efdb[_ceab] == 33 {
					goto _dbbfb
				}
				goto _dafc
			case 35:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _adde
				case 58:
					goto _gfgeg
				case 101:
					goto _dbffe
				case 123:
					goto _gddgb
				case 125:
					goto _gddgb
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 47 {
							goto _gddgb
						}
					case _efdb[_ceab] >= 34:
						goto _gddgb
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _gddgb
						}
					case _efdb[_ceab] >= 59:
						goto _gddgb
					}
				default:
					goto _ffccbd
				}
				goto _efea
			case 36:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _gddgb
				case 101:
					goto _dbffe
				case 123:
					goto _gddgb
				case 125:
					goto _gddgb
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 45 {
							goto _gddgb
						}
					case _efdb[_ceab] >= 34:
						goto _gddgb
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _gddgb
						}
					case _efdb[_ceab] >= 58:
						goto _gddgb
					}
				default:
					goto _adde
				}
				goto _efea
			case 23:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _gfgea
				case 123:
					goto _gfgea
				case 125:
					goto _gfgea
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 45 {
							goto _gfgea
						}
					case _efdb[_ceab] >= 34:
						goto _gfgea
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _gfgea
						}
					case _efdb[_ceab] >= 58:
						goto _gfgea
					}
				default:
					goto _agcgf
				}
				goto _efea
			case 37:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 47:
					goto _gddgb
				case 123:
					goto _gddgb
				case 125:
					goto _gddgb
				}
				switch {
				case _efdb[_ceab] < 48:
					switch {
					case _efdb[_ceab] > 35:
						if 37 <= _efdb[_ceab] && _efdb[_ceab] <= 45 {
							goto _gddgb
						}
					case _efdb[_ceab] >= 34:
						goto _gddgb
					}
				case _efdb[_ceab] > 57:
					switch {
					case _efdb[_ceab] > 63:
						if 91 <= _efdb[_ceab] && _efdb[_ceab] <= 94 {
							goto _gddgb
						}
					case _efdb[_ceab] >= 58:
						goto _gddgb
					}
				default:
					goto _agcgf
				}
				goto _efea
			case 38:
				switch _efdb[_ceab] {
				case 61:
					goto _bfde
				case 62:
					goto _egge
				}
				goto _bdbb
			case 39:
				if _efdb[_ceab] == 61 {
					goto _gfgef
				}
				goto _fffc
			case 24:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dafc
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dafc
					}
				default:
					goto _dafc
				}
				goto _efea
			case 40:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _edfgd
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _edfgd
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 41:
				switch _efdb[_ceab] {
				case 46:
					goto _aggcd
				case 92:
					goto _aggcd
				case 95:
					goto _aggcd
				}
				switch {
				case _efdb[_ceab] < 65:
					if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
						goto _aggcd
					}
				case _efdb[_ceab] > 90:
					if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
						goto _aggcd
					}
				default:
					goto _aggcd
				}
				goto _dcfcg
			case 42:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 43:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dbeae
				case 125:
					goto _dbeae
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dbeae
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					default:
						goto _dbeae
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _edfgd
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dbeae
					}
				default:
					goto _dbeae
				}
				goto _efea
			case 44:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _caedcd
				case 125:
					goto _caedcd
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _caedcd
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _caedcd
					}
				default:
					goto _caedcd
				}
				goto _efea
			case 25:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 65:
					goto _fdgbg
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dafc
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 66 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dafc
					}
				default:
					goto _dafc
				}
				goto _efea
			case 45:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 76:
					goto _bfedf
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 46:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 83:
					goto _fcead
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 47:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 69:
					goto _cbgdc
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 26:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 79:
					goto _bfbaf
				case 82:
					goto _aafe
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dafc
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dafc
					}
				default:
					goto _dafc
				}
				goto _efea
			case 48:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 68:
					goto _dcbdb
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 49:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 79:
					goto _dgee
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 50:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 36:
					goto _efaff
				case 40:
					goto _eedbb
				case 46:
					goto _edfgd
				case 58:
					goto _aega
				case 85:
					goto _fcead
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 59:
					switch {
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _ecbbd
						}
					case _efdb[_ceab] >= 34:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _fgce
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 27:
				switch _efdb[_ceab] {
				case 46:
					goto _aggcd
				case 92:
					goto _aggcd
				case 95:
					goto _aggcd
				}
				switch {
				case _efdb[_ceab] < 65:
					if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
						goto _aggcd
					}
				case _efdb[_ceab] > 90:
					if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
						goto _aggcd
					}
				default:
					goto _aggcd
				}
				goto _dafc
			case 28:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 120:
					goto _ddcc
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dafc
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dafc
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dafc
					}
				default:
					goto _dafc
				}
				goto _efea
			case 51:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 108:
					goto _begag
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 52:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 102:
					goto _gacd
				case 110:
					goto _dbfdf
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 53:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 110:
					goto _bfafg
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 54:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _fbbb
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 55:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _cfcec
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _cfcec
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 56:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 40:
					goto _efdc
				case 46:
					goto _cfcec
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _cfcec
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _cfcec
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 57:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 109:
					goto _ffbb
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 58:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _egfca
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dcfcg
				case 125:
					goto _dcfcg
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dcfcg
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dcfcg
					}
				default:
					goto _dcfcg
				}
				goto _efea
			case 59:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _faddb
				case 123:
					goto _caedcd
				case 125:
					goto _caedcd
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _caedcd
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _caedcd
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _faddb
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _caedcd
					}
				default:
					goto _caedcd
				}
				goto _efea
			case 29:
				switch _efdb[_ceab] {
				case 33:
					goto _badd
				case 46:
					goto _febab
				case 92:
					goto _aggcd
				case 95:
					goto _febab
				case 123:
					goto _dafc
				case 125:
					goto _dafc
				}
				switch {
				case _efdb[_ceab] < 58:
					switch {
					case _efdb[_ceab] < 37:
						if 34 <= _efdb[_ceab] && _efdb[_ceab] <= 35 {
							goto _dafc
						}
					case _efdb[_ceab] > 47:
						if 48 <= _efdb[_ceab] && _efdb[_ceab] <= 57 {
							goto _febab
						}
					default:
						goto _dafc
					}
				case _efdb[_ceab] > 63:
					switch {
					case _efdb[_ceab] < 91:
						if 65 <= _efdb[_ceab] && _efdb[_ceab] <= 90 {
							goto _febab
						}
					case _efdb[_ceab] > 94:
						if 97 <= _efdb[_ceab] && _efdb[_ceab] <= 122 {
							goto _febab
						}
					default:
						goto _dafc
					}
				default:
					goto _dafc
				}
				goto _efea
			}
		_dafc:
			_acdce = 0
			goto _afgfd
		_efea:
			_acdce = 1
			goto _afgfd
		_ddcga:
			_acdce = 2
			goto _afgfd
		_gfaf:
			_acdce = 3
			goto _afgfd
		_fbdce:
			_acdce = 4
			goto _afgfd
		_dafbe:
			_acdce = 5
			goto _afgfd
		_fffe:
			_acdce = 6
			goto _afgfd
		_dbfea:
			_acdce = 7
			goto _afgfd
		_gcgdc:
			_acdce = 8
			goto _afgfd
		_efagd:
			_acdce = 9
			goto _afgfd
		_ebae:
			_acdce = 10
			goto _afgfd
		_bcgf:
			_acdce = 11
			goto _afgfd
		_baada:
			_acdce = 12
			goto _afgfd
		_cbbgd:
			_acdce = 13
			goto _afgfd
		_gfgeg:
			_acdce = 14
			goto _afgfd
		_bcgg:
			_acdce = 15
			goto _afgfd
		_gbace:
			_acdce = 16
			goto _afgfd
		_efaff:
			_acdce = 17
			goto _afgfd
		_aega:
			_acdce = 18
			goto _afgfd
		_defcg:
			_acdce = 19
			goto _afgfd
		_fdcb:
			_acdce = 20
			goto _afgfd
		_geffe:
			_acdce = 21
			goto _afgfd
		_fdffce:
			_acdce = 22
			goto _afgfd
		_dbffe:
			_acdce = 23
			goto _afgfd
		_ddead:
			_acdce = 24
			goto _afgfd
		_ecdf:
			_acdce = 25
			goto _afgfd
		_gdab:
			_acdce = 26
			goto _afgfd
		_agegg:
			_acdce = 27
			goto _afgfd
		_ecad:
			_acdce = 28
			goto _afgfd
		_cfgg:
			_acdce = 29
			goto _afgfd
		_caedcd:
			_acdce = 30
			goto _ccggfe
		_badd:
			_acdce = 30
			goto _gbcd
		_abbdg:
			_acdce = 30
			goto _dbbc
		_cgbbg:
			_acdce = 30
			goto _bcafd
		_dbbfb:
			_acdce = 30
			goto _aggddc
		_gfgea:
			_acdce = 30
			goto _bdca
		_eedbb:
			_acdce = 30
			goto _edeeb
		_gggg:
			_acdce = 30
			goto _ffgb
		_ceae:
			_acdce = 30
			goto _cafa
		_eddgb:
			_acdce = 30
			goto _bgadg
		_feae:
			_acdce = 30
			goto _dadb
		_abcdga:
			_acdce = 30
			goto _afeaf
		_ggafb:
			_acdce = 30
			goto _bcggc
		_afeag:
			_acdce = 30
			goto _gcfb
		_bffe:
			_acdce = 30
			goto _eaef
		_baeae:
			_acdce = 30
			goto _eddgf
		_feag:
			_acdce = 30
			goto _adca
		_efba:
			_acdce = 30
			goto _gfca
		_acgce:
			_acdce = 30
			goto _fcfcd
		_aegef:
			_acdce = 30
			goto _deab
		_cfdb:
			_acdce = 30
			goto _ffbfe
		_feee:
			_acdce = 30
			goto _egfb
		_fdgb:
			_acdce = 30
			goto _ddfce
		_dbeae:
			_acdce = 30
			goto _dfgf
		_efbf:
			_acdce = 30
			goto _dfefd
		_gddgb:
			_acdce = 30
			goto _fbed
		_bdbb:
			_acdce = 30
			goto _afcgg
		_bfde:
			_acdce = 30
			goto _ccfeb
		_egge:
			_acdce = 30
			goto _bageb
		_fffc:
			_acdce = 30
			goto _geece
		_gfgef:
			_acdce = 30
			goto _fggae
		_dcfcg:
			_acdce = 30
			goto _afad
		_efdc:
			_acdce = 30
			goto _dddbg
		_daad:
			_acdce = 31
			goto _gbfa
		_fecbe:
			_acdce = 32
			goto _afgfd
		_bdcb:
			_acdce = 33
			goto _bfeaf
		_fbbaf:
			_acdce = 34
			goto _afgfd
		_ffccbd:
			_acdce = 35
			goto _gagg
		_adde:
			_acdce = 36
			goto _gagg
		_agcgf:
			_acdce = 37
			goto _gagg
		_ddeee:
			_acdce = 38
			goto _afgfd
		_dafbf:
			_acdce = 39
			goto _afgfd
		_edfgd:
			_acdce = 40
			goto _ggea
		_aggcd:
			_acdce = 41
			goto _afgfd
		_febab:
			_acdce = 42
			goto _ggea
		_ecbbd:
			_acdce = 43
			goto _bfeaf
		_fgce:
			_acdce = 44
			goto _ggea
		_cbgdc:
			_acdce = 44
			goto _ecaa
		_dgee:
			_acdce = 44
			goto _ffbfg
		_fdgbg:
			_acdce = 45
			goto _ggea
		_bfedf:
			_acdce = 46
			goto _ggea
		_fcead:
			_acdce = 47
			goto _ggea
		_bfbaf:
			_acdce = 48
			goto _ggea
		_dcbdb:
			_acdce = 49
			goto _ggea
		_aafe:
			_acdce = 50
			goto _ggea
		_ddcc:
			_acdce = 51
			goto _ggea
		_begag:
			_acdce = 52
			goto _ggea
		_gacd:
			_acdce = 53
			goto _ggea
		_bfafg:
			_acdce = 54
			goto _ggea
		_fbbb:
			_acdce = 55
			goto _ggea
		_cfcec:
			_acdce = 56
			goto _ggea
		_dbfdf:
			_acdce = 57
			goto _ggea
		_ffbb:
			_acdce = 58
			goto _ggea
		_egfca:
			_acdce = 59
			goto _ggea
		_faddb:
			_acdce = 59
			goto _bdded
		_dbbc:
			_befd = 3
			goto _ebgbf
		_bcafd:
			_befd = 5
			goto _ebgbf
		_gbcd:
			_befd = 7
			goto _ebgbf
		_aggddc:
			_befd = 9
			goto _ebgbf
		_edeeb:
			_befd = 11
			goto _ebgbf
		_dddbg:
			_befd = 13
			goto _ebgbf
		_ffgb:
			_befd = 15
			goto _ebgbf
		_deab:
			_befd = 17
			goto _ebgbf
		_ffbfe:
			_befd = 19
			goto _ebgbf
		_cafa:
			_befd = 21
			goto _ebgbf
		_bgadg:
			_befd = 23
			goto _ebgbf
		_afeaf:
			_befd = 25
			goto _ebgbf
		_gcfb:
			_befd = 27
			goto _ebgbf
		_dadb:
			_befd = 29
			goto _ebgbf
		_eaef:
			_befd = 31
			goto _ebgbf
		_fcfcd:
			_befd = 33
			goto _ebgbf
		_gfca:
			_befd = 35
			goto _ebgbf
		_ccfeb:
			_befd = 37
			goto _ebgbf
		_fggae:
			_befd = 39
			goto _ebgbf
		_bageb:
			_befd = 41
			goto _ebgbf
		_eddgf:
			_befd = 43
			goto _ebgbf
		_adca:
			_befd = 45
			goto _ebgbf
		_bcggc:
			_befd = 47
			goto _ebgbf
		_fbed:
			_befd = 49
			goto _ebgbf
		_dfgf:
			_befd = 51
			goto _ebgbf
		_ddfce:
			_befd = 53
			goto _ebgbf
		_dfefd:
			_befd = 55
			goto _ebgbf
		_afad:
			_befd = 57
			goto _ebgbf
		_egfb:
			_befd = 59
			goto _ebgbf
		_afcgg:
			_befd = 61
			goto _ebgbf
		_geece:
			_befd = 63
			goto _ebgbf
		_bdca:
			_befd = 65
			goto _ebgbf
		_ccggfe:
			_befd = 67
			goto _ebgbf
		_ecaa:
			_befd = 72
			goto _ebgbf
		_gagg:
			_befd = 75
			goto _ebgbf
		_bfeaf:
			_befd = 78
			goto _ebgbf
		_ffbfg:
			_befd = 81
			goto _ebgbf
		_bdded:
			_befd = 84
			goto _ebgbf
		_ggea:
			_befd = 87
			goto _ebgbf
		_gbfa:
			_befd = 90
			goto _ebgbf
		_ebgbf:
			_eegg = uint(_ffdbc[_befd])
			_befd++
			for ; _eegg > 0; _eegg-- {
				_befd++
				switch _ffdbc[_befd-1] {
				case 3:
					_gecbd = _ceab + 1
				case 4:
					_bafe = 1
				case 5:
					_bafe = 2
				case 6:
					_bafe = 3
				case 7:
					_bafe = 4
				case 8:
					_bafe = 11
				case 9:
					_bafe = 14
				case 10:
					_bafe = 15
				case 11:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_efegf, _efdb[_dage:_gecbd])
					}
				case 12:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_ffccc, _efdb[_dage:_gecbd])
					}
				case 13:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_fgfdf, _efdb[_dage:_gecbd-1])
					}
				case 14:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_fgfdf, _efdb[_dage+1:_gecbd-2])
					}
				case 15:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_aegg, _efdb[_dage:_gecbd-1])
					}
				case 16:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_aegg, _efdb[_dage:_gecbd-1])
					}
				case 17:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_bbec, _efdb[_dage:_gecbd])
					}
				case 18:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_fabec, _efdb[_dage:_gecbd])
					}
				case 19:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_eacgg, _efdb[_dage:_gecbd])
					}
				case 20:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_cbbe, _efdb[_dage:_gecbd])
					}
				case 21:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_ggba, _efdb[_dage:_gecbd])
					}
				case 22:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_fecgd, _efdb[_dage:_gecbd])
					}
				case 23:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_caea, _efdb[_dage:_gecbd])
					}
				case 24:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_egeed, _efdb[_dage:_gecbd])
					}
				case 25:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_fagg, _efdb[_dage:_gecbd])
					}
				case 26:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_cggedc, _efdb[_dage:_gecbd])
					}
				case 27:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_egce, _efdb[_dage:_gecbd])
					}
				case 28:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_fefbd, _efdb[_dage:_gecbd])
					}
				case 29:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_gdbf, _efdb[_dage:_gecbd])
					}
				case 30:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_gfccf, _efdb[_dage:_gecbd])
					}
				case 31:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_eabg, _efdb[_dage:_gecbd])
					}
				case 32:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_edagc, _efdb[_dage:_gecbd])
					}
				case 33:
					_gecbd = _ceab + 1
					{
						_ddafa.emit(_fdcf, _efdb[_dage:_gecbd])
					}
				case 34:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_gafee, _efdb[_dage:_gecbd])
					}
				case 35:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_gecde, _efdb[_dage:_gecbd])
					}
				case 36:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_eead, _efdb[_dage:_gecbd])
					}
				case 37:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_cecg, _efdb[_dage:_gecbd])
					}
				case 38:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_ggdfe, _efdb[_dage:_gecbd])
					}
				case 39:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_ggff, _efdb[_dage+1:_gecbd-1])
					}
				case 40:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_cefca, _efdb[_dage:_gecbd])
					}
				case 41:
					_gecbd = _ceab
					_ceab--
					{
						_ddafa.emit(_bdaada, _efdb[_dage:_gecbd])
					}
				case 42:
					_ceab = (_gecbd) - 1
					{
						_ddafa.emit(_gafee, _efdb[_dage:_gecbd])
					}
				case 43:
					switch _bafe {
					case 0:
						{
							_acdce = 0
							goto _afgfd
						}
					case 1:
						{
							_ceab = (_gecbd) - 1
							_ddafa.emit(_agdac, _efdb[_dage:_gecbd])
						}
					case 2:
						{
							_ceab = (_gecbd) - 1
							_ddafa.emit(_gafee, _efdb[_dage:_gecbd])
						}
					case 3:
						{
							_ceab = (_gecbd) - 1
							_ddafa.emit(_gecde, _efdb[_dage:_gecbd])
						}
					case 4:
						{
							_ceab = (_gecbd) - 1
							_ddafa.emit(_efgag, _efdb[_dage:_gecbd])
						}
					case 11:
						{
							_ceab = (_gecbd) - 1
							_ddafa.emit(_fage, _efdb[_dage:_gecbd])
						}
					case 14:
						{
							_ceab = (_gecbd) - 1
							_ddafa.emit(_ggdfe, _efdb[_dage:_gecbd])
						}
					case 15:
						{
							_ceab = (_gecbd) - 1
							_ddafa.emit(_ggff, _efdb[_dage+1:_gecbd-1])
						}
					}
				}
			}
			goto _afgfd
		_afgfd:
			_befd = int(_bgab[_acdce])
			_eegg = uint(_ffdbc[_befd])
			_befd++
			for ; _eegg > 0; _eegg-- {
				_befd++
				switch _ffdbc[_befd-1] {
				case 0:
					_dage = 0
				case 1:
					_bafe = 0
				}
			}
			if _acdce == 0 {
				goto _gffea
			}
			if _ceab++; _ceab != _fecae {
				goto _bfgcb
			}
		_aaecg:
			{
			}
			if _ceab == _defcd {
				switch _acdce {
				case 1:
					goto _caedcd
				case 2:
					goto _caedcd
				case 31:
					goto _feee
				case 14:
					goto _caedcd
				case 15:
					goto _caedcd
				case 32:
					goto _fdgb
				case 17:
					goto _caedcd
				case 33:
					goto _dbeae
				case 18:
					goto _caedcd
				case 19:
					goto _caedcd
				case 34:
					goto _efbf
				case 35:
					goto _gddgb
				case 36:
					goto _gddgb
				case 23:
					goto _gfgea
				case 37:
					goto _gddgb
				case 38:
					goto _bdbb
				case 39:
					goto _fffc
				case 40:
					goto _dcfcg
				case 41:
					goto _dcfcg
				case 42:
					goto _dcfcg
				case 43:
					goto _dbeae
				case 44:
					goto _caedcd
				case 45:
					goto _dcfcg
				case 46:
					goto _dcfcg
				case 47:
					goto _dcfcg
				case 48:
					goto _dcfcg
				case 49:
					goto _dcfcg
				case 50:
					goto _dcfcg
				case 51:
					goto _dcfcg
				case 52:
					goto _dcfcg
				case 53:
					goto _dcfcg
				case 54:
					goto _dcfcg
				case 55:
					goto _dcfcg
				case 56:
					goto _dcfcg
				case 57:
					goto _dcfcg
				case 58:
					goto _dcfcg
				case 59:
					goto _caedcd
				}
			}
		_gffea:
			{
			}
		}
		if _dage > 0 {
			copy(_efdb[0:], _efdb[_dage:])
		}
	}
	_ = _defcd
	if _acdce == _dcdbb {
		_ddafa.emit(_fcff, nil)
	}
	close(_ddafa._fggf)
}

// Reference returns an invalid reference for EmptyExpr.
func (_gcd EmptyExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

const _eabg = 57375

type rangeIndex struct {
	_bgdb int
	_afcc int
}

// Date is an implementation of the Excel DATE() function.
func Date(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0041TE\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0068re\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_cgfe := int(args[0].ValueNumber)
	if _cgfe < 0 || _cgfe >= 10000 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074 \u0064\u0061\u0074\u0065")
	} else if _cgfe <= 1899 {
		_cgfe += 1900
	}
	_dfb := _ea.Month(args[1].ValueNumber)
	_bfce := int(args[2].ValueNumber)
	_cdg := _ddcf(_cgfe, _dfb, _bfce)
	_ddf := _fdc(_ecf, _cdg) + 1
	if _ddf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074 \u0064\u0061\u0074\u0065")
	}
	return MakeNumberResult(_ddf)
}

// MinIfs implements the MINIFS function.
func MinIfs(args []Result) Result {
	_fgcga := _ddaa(args, true, "\u004d\u0049\u004e\u0049\u0046\u0053")
	if _fgcga.Type != ResultTypeEmpty {
		return _fgcga
	}
	_faccb := _agge(args[1:])
	_eadef := _gg.MaxFloat64
	_ccfd := _aefda(args[0])
	for _, _fcbe := range _faccb {
		_edbd := _ccfd[_fcbe._bgdb][_fcbe._afcc].ValueNumber
		if _eadef > _edbd {
			_eadef = _edbd
		}
	}
	if _eadef == _gg.MaxFloat64 {
		_eadef = 0
	}
	return MakeNumberResult(float64(_eadef))
}

type couponArgs struct {
	_eebf float64
	_edge float64
	_eda  int
	_ceca int
}

// String returns a string representation of a vertical range.
func (_ccbb VerticalRange) String() string { return _ccbb.verticalRangeReference() }

// Range is a range expression that when evaluated returns a list of Results.
type Range struct{ _ecgg, _bgfde Expression }

func _aa(_gcb BinOpType, _bf, _ae []Result) Result {
	_ge := []Result{}
	for _edf := range _bf {
		_fca := _bf[_edf].AsNumber()
		_cd := _ae[_edf].AsNumber()
		if _fca.Type != ResultTypeNumber || _cd.Type != ResultTypeNumber {
			return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
		}
		switch _gcb {
		case BinOpTypePlus:
			_ge = append(_ge, MakeNumberResult(_fca.ValueNumber+_cd.ValueNumber))
		case BinOpTypeMinus:
			_ge = append(_ge, MakeNumberResult(_fca.ValueNumber-_cd.ValueNumber))
		case BinOpTypeMult:
			_ge = append(_ge, MakeNumberResult(_fca.ValueNumber*_cd.ValueNumber))
		case BinOpTypeDiv:
			if _cd.ValueNumber == 0 {
				return MakeErrorResultType(ErrorTypeDivideByZero, "")
			}
			_ge = append(_ge, MakeNumberResult(_fca.ValueNumber/_cd.ValueNumber))
		case BinOpTypeExp:
			_ge = append(_ge, MakeNumberResult(_gg.Pow(_fca.ValueNumber, _cd.ValueNumber)))
		case BinOpTypeLT:
			_ge = append(_ge, MakeBoolResult(_fca.ValueNumber < _cd.ValueNumber))
		case BinOpTypeGT:
			_ge = append(_ge, MakeBoolResult(_fca.ValueNumber > _cd.ValueNumber))
		case BinOpTypeEQ:
			_ge = append(_ge, MakeBoolResult(_fca.ValueNumber == _cd.ValueNumber))
		case BinOpTypeLEQ:
			_ge = append(_ge, MakeBoolResult(_fca.ValueNumber <= _cd.ValueNumber))
		case BinOpTypeGEQ:
			_ge = append(_ge, MakeBoolResult(_fca.ValueNumber >= _cd.ValueNumber))
		case BinOpTypeNE:
			_ge = append(_ge, MakeBoolResult(_fca.ValueNumber != _cd.ValueNumber))
		default:
			return MakeErrorResult(_b.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _gcb))
		}
	}
	return MakeListResult(_ge)
}
func _aaeb(_dbfb []Result) []float64 {
	_gdec := make([]float64, 0)
	for _, _gfef := range _dbfb {
		if _gfef.Type == ResultTypeEmpty {
			continue
		}
		_gfef = _gfef.AsNumber()
		switch _gfef.Type {
		case ResultTypeNumber:
			if !_gfef.IsBoolean {
				_gdec = append(_gdec, _gfef.ValueNumber)
			}
		case ResultTypeList, ResultTypeArray:
			_gdec = append(_gdec, _aaeb(_gfef.ListValues())...)
		case ResultTypeString:
		default:
			_cg.Log("\u0075\u006e\u0068\u0061\u006ed\u006c\u0065\u0064\u0020\u0065\u0078\u0074\u0072\u0061\u0063\u0074\u004e\u0075m\u0062\u0065\u0072\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _gfef.Type)
		}
	}
	return _gdec
}
func _eccgb(_ggfef string, _gede _ea.Time) (_ea.Time, error) {
	_bdfg, _, _ceeb := _ac.ParseFloat(_ggfef, 10, 128, _ac.ToNearestEven)
	if _ceeb != nil {
		return _ea.Time{}, _ceeb
	}
	_eeba := new(_ac.Float)
	_eeba.SetUint64(uint64(24 * _ea.Hour))
	_bdfg.Mul(_bdfg, _eeba)
	_fafg, _ := _bdfg.Uint64()
	_dbee := _gede.Add(_ea.Duration(_fafg))
	return _fgag(_dbee), nil
}

var _gcc = map[string]*_af.Regexp{}

// Value is an implementation of the Excel VALUE function.
func Value(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0056\u0041\u004c\u0055\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020a\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_beda := args[0]
	if _beda.Type == ResultTypeNumber {
		return _beda
	}
	if _beda.Type == ResultTypeString {
		_acbb, _gdcbc := _ga.ParseFloat(_beda.Value(), 64)
		if _gdcbc == nil {
			return MakeNumberResult(_acbb)
		}
	}
	return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0056\u0041L\u0055\u0045")
}
func _cdcfb(_cef, _gfbc, _ffd, _decg, _dcce float64) float64 {
	var _aacd float64
	_dcdb := _dcce / _ffd
	if _dcdb >= 1 {
		_dcdb = 1
		if _decg == 1 {
			_aacd = _cef
		} else {
			_aacd = 0
		}
	} else {
		_aacd = _cef * _gg.Pow(1-_dcdb, _decg-1)
	}
	_fcc := _cef * _gg.Pow(1-_dcdb, _decg)
	var _bdga float64
	if _fcc < _gfbc {
		_bdga = _aacd - _gfbc
	} else {
		_bdga = _aacd - _fcc
	}
	if _bdga < 0 {
		_bdga = 0
	}
	return _bdga
}
func _gbac(_cfdd, _bcbf _ea.Time) bool {
	_agac := _cfdd.Unix()
	_dadd := _bcbf.Unix()
	_egda := _cfdd.Year()
	_abf := _ddcf(_egda, _ea.March, 1)
	if _dbfd(_egda) && _agac < _abf && _dadd >= _abf {
		return true
	}
	var _cbfae = _bcbf.Year()
	var _bgfbf = _ddcf(_cbfae, _ea.March, 1)
	return (_dbfd(_cbfae) && _dadd >= _bgfbf && _agac < _bgfbf)
}

var _bgfcf, _bcae, _ffeeg, _ecffc, _adeg, _fcbg *_af.Regexp

// Eval evaluates the binary expression using the context given.
func (_ccd BinaryExpr) String() string {
	_fcf := ""
	switch _ccd._bc {
	case BinOpTypePlus:
		_fcf = "\u002b"
	case BinOpTypeMinus:
		_fcf = "\u002d"
	case BinOpTypeMult:
		_fcf = "\u002a"
	case BinOpTypeDiv:
		_fcf = "\u002f"
	case BinOpTypeExp:
		_fcf = "\u005e"
	case BinOpTypeLT:
		_fcf = "\u003c"
	case BinOpTypeGT:
		_fcf = "\u003e"
	case BinOpTypeEQ:
		_fcf = "\u003d"
	case BinOpTypeLEQ:
		_fcf = "\u003c\u003d"
	case BinOpTypeGEQ:
		_fcf = "\u003e\u003d"
	case BinOpTypeNE:
		_fcf = "\u003c\u003e"
	case BinOpTypeConcat:
		_fcf = "\u0026"
	}
	return _ccd._ag.String() + _fcf + _ccd._bd.String()
}
func (_gged PrefixVerticalRange) verticalRangeReference(_ffdc string) string {
	return _b.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _ffdc, _gged._fbedd, _gged._gacbg)
}

// Substitute is an implementation of the Excel SUBSTITUTE function.
func Substitute(args []Result) Result {
	_edef := len(args)
	if _edef != 3 && _edef != 4 {
		return MakeErrorResult("\u0053\u0055\u0042\u0053\u0054\u0049\u0054U\u0054\u0045\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_egcdf, _afgfg := _fdffc(args[0], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u0074\u0065\u0078\u0074")
	if _afgfg.Type == ResultTypeError {
		return _afgfg
	}
	_gdff, _afgfg := _fdffc(args[1], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u006f\u006c\u0064\u0020\u0074\u0065\u0078\u0074")
	if _afgfg.Type == ResultTypeError {
		return _afgfg
	}
	_cfcf, _afgfg := _fdffc(args[2], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u006e\u0065\u0077\u0020\u0074\u0065\u0078\u0074")
	if _afgfg.Type == ResultTypeError {
		return _afgfg
	}
	_gbcbc := 0
	if _edef == 3 {
		return MakeStringResult(_fa.Replace(_egcdf, _gdff, _cfcf, -1))
	} else {
		_fcee, _ffccb := _gdb(args[3], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u0069\u006e\u0073t\u0061\u006e\u0063\u0065\u005f\u006e\u0075\u006d")
		if _ffccb.Type == ResultTypeError {
			return _ffccb
		}
		_gbcbc = int(_fcee)
		if _gbcbc < 1 {
			return MakeErrorResult("\u0069\u006es\u0074\u0061\u006e\u0063e\u005f\u006eu\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e \u007a\u0065\u0072\u006f")
		}
		_gcce := _egcdf
		_dfbc := _gbcbc
		_beaf := -1
		_cbeg := len(_gdff)
		_begcb := 0
		for {
			_dfbc--
			_geff := _fa.Index(_gcce, _gdff)
			if _geff == -1 {
				_beaf = -1
				break
			} else {
				_beaf = _geff + _begcb
				if _dfbc == 0 {
					break
				}
				_ecfb := _cbeg + _geff
				_begcb += _ecfb
				_gcce = _gcce[_ecfb:]
			}
		}
		if _beaf == -1 {
			return MakeStringResult(_egcdf)
		} else {
			_cggda := _egcdf[:_beaf]
			_ffeeb := _egcdf[_beaf+_cbeg:]
			return MakeStringResult(_cggda + _cfcf + _ffeeb)
		}
	}
}
func _ffbba(_ebcag Context, _fabed, _gafgf string) (string, string) {
	_aagdc := _fabed + "\u0031"
	_gddb := _ebcag.LastRow(_fabed)
	_fgbga := _gafgf + _ga.Itoa(_gddb)
	return _aagdc, _fgbga
}

// LCM implements the Excel LCM() function which returns the least common
// multiple of a range of numbers.
func LCM(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004c\u0043M(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0061t \u006c\u0065\u0061\u0073\u0074\u0020\u006fne\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_fbdae := []float64{}
	for _, _dcdef := range args {
		switch _dcdef.Type {
		case ResultTypeString:
			_dbeg := _dcdef.AsNumber()
			if _dbeg.Type != ResultTypeNumber {
				return MakeErrorResult("\u004c\u0043M(\u0029\u0020\u006fn\u006c\u0079\u0020\u0061cce\u0070ts\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
			}
			_fbdae = append(_fbdae, _dbeg.ValueNumber)
		case ResultTypeList:
			_dabf := LCM(_dcdef.ValueList)
			if _dabf.Type != ResultTypeNumber {
				return _dabf
			}
			_fbdae = append(_fbdae, _dabf.ValueNumber)
		case ResultTypeNumber:
			_fbdae = append(_fbdae, _dcdef.ValueNumber)
		case ResultTypeError:
			return _dcdef
		}
	}
	if _fbdae[0] < 0 {
		return MakeErrorResult("\u004c\u0043M\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(_fbdae) == 1 {
		return MakeNumberResult(_fbdae[0])
	}
	_bbab := _fbdae[0]
	for _gade := 1; _gade < len(_fbdae); _gade++ {
		if _fbdae[_gade] < 0 {
			return MakeErrorResult("\u004c\u0043M\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
		}
		_bbab = _fgabe(_bbab, _fbdae[_gade])
	}
	return MakeNumberResult(_bbab)
}

// Product is an implementation of the Excel PRODUCT() function.
func Product(args []Result) Result {
	_gddc := 1.0
	for _, _ccad := range args {
		_ccad = _ccad.AsNumber()
		switch _ccad.Type {
		case ResultTypeNumber:
			_gddc *= _ccad.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_ccggg := Product(_ccad.ListValues())
			if _ccggg.Type != ResultTypeNumber {
				return _ccggg
			}
			_gddc *= _ccggg.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _ccad
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_b.Sprintf("\u0075\u006eha\u006e\u0064\u006ce\u0064\u0020\u0050\u0052ODU\u0043T(\u0029\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0020\u0074\u0079\u0070\u0065\u0020%\u0073", _ccad.Type))
		}
	}
	return MakeNumberResult(_gddc)
}

// Tbilleq implements the Excel TBILLEQ function.
func Tbilleq(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020t\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_caed, _ebad, _afdc := _daea(args[0], args[1], "\u0054B\u0049\u004c\u004c\u0045\u0051")
	if _afdc.Type == ResultTypeError {
		return _afdc
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0064is\u0063\u006f\u0075\u006et\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cgabc := _ebad - _caed
	if _cgabc > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020m\u006f\u0072e\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079\u0065\u0061r \u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074t\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_dac := args[2].ValueNumber
	if _dac <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0045Q\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074 \u0074\u006f\u0020\u0062\u0065 p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult((365 * _dac) / (360 - _dac*_cgabc))
}
func _fgabe(_dggaf, _efad float64) float64 {
	_dggaf = _gg.Trunc(_dggaf)
	_efad = _gg.Trunc(_efad)
	if _dggaf == 0 && _efad == 0 {
		return 0
	}
	return _dggaf * _efad / _ccgc(_dggaf, _efad)
}
func (_dbfcf *plex) Error(s string) {
	_cg.Log("\u0070a\u0072s\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", s)
}
func _cdaa(_abfc, _aae Result, _geba string) (*xargs, Result) {
	if _abfc.Type != ResultTypeList && _abfc.Type != ResultTypeArray {
		return nil, MakeErrorResult(_geba + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0076\u0061lue\u0073 t\u006f\u0020\u0062\u0065\u0020\u006f\u0066 a\u0072\u0072\u0061\u0079\u0020\u0074\u0079p\u0065")
	}
	_bedd := _aefda(_abfc)
	_dgcg := []float64{}
	for _, _ccbfb := range _bedd {
		for _, _gbga := range _ccbfb {
			if _gbga.Type == ResultTypeNumber && !_gbga.IsBoolean {
				_dgcg = append(_dgcg, _gbga.ValueNumber)
			} else {
				return nil, MakeErrorResult(_geba + "\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0073")
			}
		}
	}
	_aabg := len(_dgcg)
	if len(_dgcg) < 2 {
		return nil, MakeErrorResultType(ErrorTypeNum, "")
	}
	if _aae.Type != ResultTypeList && _aae.Type != ResultTypeArray {
		return nil, MakeErrorResult(_geba + " \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0064\u0061\u0074\u0065s\u0020\u0074\u006f\u0020\u0062\u0065\u0020o\u0066\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0074\u0079p\u0065")
	}
	_cgda := _aefda(_aae)
	_ggdbc := []float64{}
	_dgdc := 0.0
	for _, _dfgb := range _cgda {
		for _, _aeea := range _dfgb {
			if _aeea.Type == ResultTypeNumber && !_aeea.IsBoolean {
				_dfc := float64(int(_aeea.ValueNumber))
				if _dfc < _dgdc {
					return nil, MakeErrorResultType(ErrorTypeNum, _geba+" \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0061\u0074\u0065\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u0069\u006e\u0020\u0061\u0073\u0063\u0065\u006edi\u006e\u0067\u0020o\u0072d\u0065\u0072")
				}
				_ggdbc = append(_ggdbc, _dfc)
				_dgdc = _dfc
			} else {
				return nil, MakeErrorResult(_geba + "\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0064\u0061\u0074\u0065\u0073\u0020t\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0073")
			}
		}
	}
	if len(_ggdbc) != _aabg {
		return nil, MakeErrorResultType(ErrorTypeNum, "")
	}
	return &xargs{_dgcg, _ggdbc}, MakeEmptyResult()
}

// Reference returns an invalid reference for BinaryExpr.
func (_fcb BinaryExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }
func _acbag(_bfba string) *criteriaRegex {
	_adfgg := &criteriaRegex{}
	if _bfba == "" {
		return _adfgg
	}
	if _bbdbd := _bgfcf.FindStringSubmatch(_bfba); len(_bbdbd) > 1 {
		_adfgg._dgbebb = _cgbed
		_adfgg._cbcgcc = _bbdbd[1]
	} else if _ecbb := _bcae.FindStringSubmatch(_bfba); len(_ecbb) > 1 {
		_adfgg._dgbebb = _cgbed
		_adfgg._cbcgcc = _ecbb[1]
	} else if _cdag := _fcbg.FindStringSubmatch(_bfba); len(_cdag) > 1 {
		_adfgg._dgbebb = _eacfe
		_adfgg._cbcgcc = _cdag[1]
	} else if _dcedc := _adeg.FindStringSubmatch(_bfba); len(_dcedc) > 1 {
		_adfgg._dgbebb = _fbafb
		_adfgg._cbcgcc = _dcedc[1]
	} else if _fcbda := _ecffc.FindStringSubmatch(_bfba); len(_fcbda) > 1 {
		_adfgg._dgbebb = _eabe
		_adfgg._cbcgcc = _fcbda[1]
	} else if _bbbe := _ffeeg.FindStringSubmatch(_bfba); len(_bbbe) > 1 {
		_adfgg._dgbebb = _efeg
		_adfgg._cbcgcc = _bbbe[1]
	}
	return _adfgg
}

// Column implements the Excel COLUMN function.
func Column(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0043\u004f\u004c\u0055M\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_bcabb := args[0].Ref
	if _bcabb.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0043\u004f\u004c\u0055\u004dN\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e")
	}
	_daaf, _fafc := _df.ParseCellReference(_bcabb.Value)
	if _fafc != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _bcabb.Value)
	}
	return MakeNumberResult(float64(_daaf.ColumnIdx + 1))
}

// Days is an implementation of the Excel DAYS() function.
func Days(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("D\u0041\u0059\u0053\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	var _bee, _ged float64
	switch args[0].Type {
	case ResultTypeNumber:
		_ged = args[0].ValueNumber
	case ResultTypeString:
		_ecg := DateValue([]Result{args[0]})
		if _ecg.Type == ResultTypeError {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0065\u006e\u0064\u0020\u0064\u0061\u0074e\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
		}
		_ged = _ecg.ValueNumber
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
	}
	switch args[1].Type {
	case ResultTypeNumber:
		_bee = args[1].ValueNumber
		if _bee < 62 && _ged >= 62 {
			_bee--
		}
	case ResultTypeString:
		_cae := DateValue([]Result{args[1]})
		if _cae.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u0020DA\u0059\u0053")
		}
		_bee = _cae.ValueNumber
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
	}
	_bfeg := float64(int(_ged - _bee))
	return MakeNumberResult(_bfeg)
}

// Fvschedule implements the Excel FVSCHEDULE function.
func Fvschedule(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045D\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048E\u0044\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0070\u0072\u0069\u006e\u0063\u0069\u0070\u0061\u006c\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_cdcg := args[0].ValueNumber
	switch args[1].Type {
	case ResultTypeNumber:
		return MakeNumberResult(_cdcg * (args[1].ValueNumber + 1))
	case ResultTypeList, ResultTypeArray:
		_gaeab := _aefda(args[1])
		for _, _fec := range _gaeab {
			for _, _fdaa := range _fec {
				if _fdaa.Type != ResultTypeNumber || _fdaa.IsBoolean {
					return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0073")
				}
				_cdcg *= 1.0 + _fdaa.ValueNumber
			}
		}
		return MakeNumberResult(_cdcg)
	default:
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0063\u0068\u0065\u0064\u0075\u006c\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0072\u0020\u0061\u0072\u0072a\u0079\u0020\u0074y\u0070\u0065")
	}
}

const _fcff = 57350

// Reference returns a string reference value to a named range.
func (_gcac NamedRangeRef) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeNamedRange, Value: _gcac._daega}
}
func _eedd(_gggad int) string {
	if _gggad >= 0 && _gggad < len(_ecfag) {
		if _ecfag[_gggad] != "" {
			return _ecfag[_gggad]
		}
	}
	return _b.Sprintf("\u0073\u0074\u0061\u0074\u0065\u002d\u0025\u0076", _gggad)
}
func _ccgc(_dcfcd, _adfd float64) float64 {
	_dcfcd = _gg.Trunc(_dcfcd)
	_adfd = _gg.Trunc(_adfd)
	if _dcfcd == 0 {
		return _adfd
	}
	if _adfd == 0 {
		return _dcfcd
	}
	for _dcfcd != _adfd {
		if _dcfcd > _adfd {
			_dcfcd = _dcfcd - _adfd
		} else {
			_adfd = _adfd - _dcfcd
		}
	}
	return _dcfcd
}

const _fage = 57348

func _aefe(_ddbg Result, _gbdff *criteriaParsed) bool {
	if _ddbg.IsBoolean {
		return false
	}
	_eebe := _ddbg.Type
	if _gbdff._bfabd {
		return _eebe == ResultTypeNumber && _ddbg.ValueNumber == _gbdff._cbaa
	} else if _eebe == ResultTypeNumber {
		return _bcfg(_ddbg.ValueNumber, _gbdff._edbfb)
	}
	return _gbbg(_ddbg, _gbdff)
}
func _dgfg(_gbb, _dag, _ebaf, _cecae float64, _aafc int) float64 {
	var _agd float64
	if _gbb == 0 {
		_agd = (_ebaf + _cecae) / _dag
	} else {
		_fddd := _gg.Pow(1+_gbb, _dag)
		if _aafc == 1 {
			_agd = (_cecae*_gbb/(_fddd-1) + _ebaf*_gbb/(1-1/_fddd)) / (1 + _gbb)
		} else {
			_agd = _cecae*_gbb/(_fddd-1) + _ebaf*_gbb/(1-1/_fddd)
		}
	}
	return -_agd
}

// Tbillyield implements the Excel TBILLYIELD function.
func Tbillyield(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0059\u0049E\u004c\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_feec, _bfef, _ffcg := _daea(args[0], args[1], "\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044")
	if _ffcg.Type == ResultTypeError {
		return _ffcg
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0064\u0069\u0073\u0063\u006f\u0075n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bfdbb := _bfef - _feec
	if _bfdbb > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004cY\u0049\u0045\u004c\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020t\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079e\u0061\u0072\u0020\u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_edbg := args[2].ValueNumber
	if _edbg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020p\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ecba := (100 - _edbg) / _edbg
	_fbbe := 360 / _bfdbb
	return MakeNumberResult(_ecba * _fbbe)
}

type evCache struct {
	_fe  map[string]Result
	_adc *_eg.Mutex
}

var _faac string = string([]byte{92})
var ReferenceInvalid = Reference{Type: ReferenceTypeInvalid}

// ISODD is an implementation of the Excel ISODD() function.
func IsOdd(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u004f\u0044\u0044\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u004f\u0044\u0044\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061 \u006eu\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_egac := int(args[0].ValueNumber)
	return MakeBoolResult(_egac != _egac/2*2)
}

// EmptyExpr is an empty expression.
type EmptyExpr struct{}

// Fact is an implementation of the excel FACT function which returns the
// factorial of a positive numeric input.
func Fact(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("F\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_bdac := args[0].AsNumber()
	if _bdac.Type != ResultTypeNumber {
		return MakeErrorResult("F\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	if _bdac.ValueNumber < 0 {
		return MakeErrorResult("\u0046\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006f\u006e\u006c\u0079\u0020\u0070\u006f\u0073\u0069t\u0069\u0076\u0065\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	return MakeNumberResult(_fgbg(_bdac.ValueNumber))
}
func _edc() {
	_gcc["\u006d\u006d\u002f\u0064\u0064\u002f\u0079\u0079"] = _af.MustCompile("\u005e" + _geb + _cac)
	_gcc["\u006dm\u0020\u0064\u0064\u002c\u0020\u0079y"] = _af.MustCompile("\u005e" + _bcg + _cac)
	_gcc["\u0079\u0079\u002d\u006d\u006d\u002d\u0064\u0064"] = _af.MustCompile("\u005e" + _gfd + _cac)
	_gcc["y\u0079\u002d\u006d\u006d\u0053\u0074\u0072\u002d\u0064\u0064"] = _af.MustCompile("\u005e" + _fgd + _cac)
	_fbgf["\u0068\u0068"] = _af.MustCompile(_gba + _dbfc + "\u0024")
	_fbgf["\u0068\u0068\u003am\u006d"] = _af.MustCompile(_gba + _gcgc + "\u0024")
	_fbgf["\u006d\u006d\u003as\u0073"] = _af.MustCompile(_gba + _dbdd + "\u0024")
	_fbgf["\u0068\u0068\u003a\u006d\u006d\u003a\u0073\u0073"] = _af.MustCompile(_gba + _ddaf + "\u0024")
	_bfa = []*_af.Regexp{_af.MustCompile("\u005e" + _geb + "\u0024"), _af.MustCompile("\u005e" + _bcg + "\u0024"), _af.MustCompile("\u005e" + _gfd + "\u0024"), _af.MustCompile("\u005e" + _fgd + "\u0024")}
	_ggd = []*_af.Regexp{_af.MustCompile("\u005e" + _dbfc + "\u0024"), _af.MustCompile("\u005e" + _gcgc + "\u0024"), _af.MustCompile("\u005e" + _dbdd + "\u0024"), _af.MustCompile("\u005e" + _ddaf + "\u0024")}
}

// Exact is an implementation of the Excel EXACT() which compares two strings.
func Exact(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041\u0054\u0045N\u0041\u0054\u0045(\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_afeb := args[0].AsString()
	_eddga := args[1].AsString()
	if _afeb.Type != ResultTypeString || _eddga.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041\u0054\u0045N\u0041\u0054\u0045(\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(_afeb.ValueString == _eddga.ValueString)
}
func _add(_cdeaa []Result, _efgb bool) Result {
	_bade := "\u004d\u0041\u0058"
	if _efgb {
		_bade = "\u004d\u0041\u0058\u0041"
	}
	if len(_cdeaa) == 0 {
		return MakeErrorResult(_bade + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061s\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gedge := -_gg.MaxFloat64
	for _, _ebgg := range _cdeaa {
		switch _ebgg.Type {
		case ResultTypeNumber:
			if (_efgb || !_ebgg.IsBoolean) && _ebgg.ValueNumber > _gedge {
				_gedge = _ebgg.ValueNumber
			}
		case ResultTypeList, ResultTypeArray:
			_debea := _add(_ebgg.ListValues(), _efgb)
			if _debea.ValueNumber > _gedge {
				_gedge = _debea.ValueNumber
			}
		case ResultTypeEmpty:
		case ResultTypeString:
			_bgcdf := 0.0
			if _efgb {
				_bgcdf = _ebgg.AsNumber().ValueNumber
			}
			if _bgcdf > _gedge {
				_gedge = _bgcdf
			}
		default:
			_cg.Log("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020"+_bade+"\u0028\u0029\u0020\u0061rg\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _ebgg.Type)
		}
	}
	if _gedge == -_gg.MaxFloat64 {
		_gedge = 0
	}
	return MakeNumberResult(_gedge)
}

//go:generate ragel -G2 -Z lexer.rl
//go:generate goimports -w lexer.go
type Lexer struct {
	_fggf  chan *node
	_cfdcd _eg.Mutex
	_dedgf []chan *node
	_egfc  []*node
}

// NewVerticalRange constructs a new full columns range.
func NewVerticalRange(v string) Expression {
	_cdab := _fa.Split(v, "\u003a")
	if len(_cdab) != 2 {
		return nil
	}
	return VerticalRange{_cdab[0], _cdab[1]}
}
func init() {
	RegisterFunction("\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d", Accrintm)
	RegisterFunction("\u0041M\u004f\u0052\u0044\u0045\u0047\u0052C", Amordegrc)
	RegisterFunction("\u0041\u004d\u004f\u0052\u004c\u0049\u004e\u0043", Amorlinc)
	RegisterFunction("\u0043O\u0055\u0050\u0044\u0041\u0059\u0042S", Coupdaybs)
	RegisterFunction("\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053", Coupdays)
	RegisterFunction("\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053\u004e\u0043", Coupdaysnc)
	RegisterFunction("\u0043O\u0055\u0050\u004e\u0055\u004d", Coupnum)
	RegisterFunction("\u0043O\u0055\u0050\u004e\u0043\u0044", Coupncd)
	RegisterFunction("\u0043O\u0055\u0050\u0050\u0043\u0044", Couppcd)
	RegisterFunction("\u0043U\u004d\u0049\u0050\u004d\u0054", Cumipmt)
	RegisterFunction("\u0043\u0055\u004d\u0050\u0052\u0049\u004e\u0043", Cumprinc)
	RegisterFunction("\u0044\u0042", Db)
	RegisterFunction("\u0044\u0044\u0042", Ddb)
	RegisterFunction("\u0044\u0049\u0053\u0043", Disc)
	RegisterFunction("\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045", Dollarde)
	RegisterFunction("\u0044\u004f\u004c\u004c\u0041\u0052\u0046\u0052", Dollarfr)
	RegisterFunction("\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e", Duration)
	RegisterFunction("\u0045\u0046\u0046\u0045\u0043\u0054", Effect)
	RegisterFunction("\u0046\u0056", Fv)
	RegisterFunction("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045", Fvschedule)
	RegisterFunction("\u0049N\u0054\u0052\u0041\u0054\u0045", Intrate)
	RegisterFunction("\u0049\u0050\u004d\u0054", Ipmt)
	RegisterFunction("\u0049\u0052\u0052", Irr)
	RegisterFunction("\u0049\u0053\u0050M\u0054", Ispmt)
	RegisterFunction("\u004dD\u0055\u0052\u0041\u0054\u0049\u004fN", Mduration)
	RegisterFunction("\u004d\u0049\u0052\u0052", Mirr)
	RegisterFunction("\u004eO\u004d\u0049\u004e\u0041\u004c", Nominal)
	RegisterFunction("\u004e\u0050\u0045\u0052", Nper)
	RegisterFunction("\u004e\u0050\u0056", Npv)
	RegisterFunction("\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E", Oddlprice)
	RegisterFunction("\u004fD\u0044\u004c\u0059\u0049\u0045\u004cD", Oddlyield)
	RegisterFunction("\u0050D\u0055\u0052\u0041\u0054\u0049\u004fN", Pduration)
	RegisterFunction("\u005fx\u006cf\u006e\u002e\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e", Pduration)
	RegisterFunction("\u0050\u004d\u0054", Pmt)
	RegisterFunction("\u0050\u0050\u004d\u0054", Ppmt)
	RegisterFunction("\u0050\u0052\u0049C\u0045", Price)
	RegisterFunction("\u0050R\u0049\u0043\u0045\u0044\u0049\u0053C", Pricedisc)
	RegisterFunction("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054", Pricemat)
	RegisterFunction("\u0050\u0056", Pv)
	RegisterFunction("\u0052\u0041\u0054\u0045", Rate)
	RegisterFunction("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044", Received)
	RegisterFunction("\u0052\u0052\u0049", Rri)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0052\u0052I", Rri)
	RegisterFunction("\u0053\u004c\u004e", Sln)
	RegisterFunction("\u0053\u0059\u0044", Syd)
	RegisterFunction("\u0054B\u0049\u004c\u004c\u0045\u0051", Tbilleq)
	RegisterFunction("\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045", Tbillprice)
	RegisterFunction("\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044", Tbillyield)
	RegisterFunction("\u0056\u0044\u0042", Vdb)
	RegisterFunction("\u0058\u0049\u0052\u0052", Xirr)
	RegisterFunction("\u0058\u004e\u0050\u0056", Xnpv)
	RegisterFunction("\u0059\u0049\u0045L\u0044", Yield)
	RegisterFunction("\u0059I\u0045\u004c\u0044\u0044\u0049\u0053C", Yielddisc)
	RegisterFunction("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054", Yieldmat)
}

// Pricedisc implements the Excel PRICEDISC function.
func Pricedisc(args []Result) Result {
	_egab := len(args)
	if _egab != 4 && _egab != 5 {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_egdfd, _bffb, _egca := _daea(args[0], args[1], "\u0050R\u0049\u0043\u0045\u0044\u0049\u0053C")
	if _egca.Type == ResultTypeError {
		return _egca
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049C\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ccfb := args[2].ValueNumber
	if _ccfb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049C\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_ccacc := args[3].ValueNumber
	if _ccacc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006fs\u0069\u0074i\u0076\u0065")
	}
	_cecf := 0
	if _egab == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0052I\u0043\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_cecf = int(args[4].ValueNumber)
		if !_efb(_cecf) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043")
		}
	}
	_gdfd, _egca := _cbfa(_egdfd, _bffb, _cecf)
	if _egca.Type == ResultTypeError {
		return _egca
	}
	return MakeNumberResult(_ccacc * (1 - _ccfb*_gdfd))
}
func _eagf(_cdfaf Result, _befee *criteriaParsed) bool {
	if _cdfaf.Type == ResultTypeEmpty {
		return false
	}
	if _befee._bfabd {
		return _cdfaf.ValueNumber == _befee._cbaa
	} else {
		_dbgd := _fa.ToLower(_cdfaf.ValueString)
		return _befee._ffcbg == _dbgd || _d.Match(_befee._ffcbg, _dbgd)
	}
}
func _ddcf(_cfc int, _cgab _ea.Month, _bgcd int) int64 {
	if _cfc == 1900 && int(_cgab) <= 2 {
		_bgcd--
	}
	_fcgd := _ea.Date(_cfc, _cgab, _bgcd, 0, 0, 0, 0, _ea.UTC)
	return _fcgd.Unix()
}

// Counta implements the COUNTA function.
func Counta(args []Result) Result { return MakeNumberResult(_gcfe(args, _fffb)) }

var _bfa = []*_af.Regexp{}

func _efab(_egbf, _edb []float64, _agfa float64) float64 {
	_ggca := _agfa + 1
	_fcabg := _egbf[0]
	_gaef := len(_egbf)
	_dafb := _edb[0]
	for _ccgg := 1; _ccgg < _gaef; _ccgg++ {
		_fcabg += _egbf[_ccgg] / _gg.Pow(_ggca, (_edb[_ccgg]-_dafb)/365)
	}
	return _fcabg
}
func _daea(_gda, _edeg Result, _gga string) (float64, float64, Result) {
	_edda, _bbe := _dddb(_gda, "\u0073e\u0074t\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065", _gga)
	if _bbe.Type == ResultTypeError {
		return 0, 0, _bbe
	}
	_cgea, _bbe := _dddb(_edeg, "\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065", _gga)
	if _bbe.Type == ResultTypeError {
		return 0, 0, _bbe
	}
	if _edda >= _cgea {
		return 0, 0, MakeErrorResultType(ErrorTypeNum, _gga+"\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u006cat\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	return _edda, _cgea, _aaa
}

// YearFrac is an implementation of the Excel YEARFRAC() function.
func YearFrac(args []Result) Result {
	_ddg := len(args)
	if (_ddg != 2 && _ddg != 3) || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber {
		return MakeErrorResult("Y\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006f\u0072 \u0074\u0068\u0072\u0065\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_cbcg := 0
	if _ddg == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("Y\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020ba\u0073\u0069\u0073\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074o \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_cbcg = int(args[2].ValueNumber)
		if !_efb(_cbcg) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0059\u0045\u0041R\u0046\u0052\u0041\u0043")
		}
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0074\u0061\u0072\u0074\u0020\u0064\u0061t\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dccd := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043 \u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0065\u006ed\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_eefg := args[1].ValueNumber
	_gce, _fdg := _cbfa(_dccd, _eefg, _cbcg)
	if _fdg.Type == ResultTypeError {
		return _fdg
	}
	return MakeNumberResult(_gce)
}

type cmpResult int8

func (_eca *evCache) SetCache(key string, value Result) {
	_eca._adc.Lock()
	_eca._fe[key] = value
	_eca._adc.Unlock()
}

var _ecfcd = map[string]Function{}

// Lower is an implementation of the Excel LOWER function that returns a lower
// case version of a string.
func Lower(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004c\u004f\u0057\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_eecg := args[0]
	switch _eecg.Type {
	case ResultTypeError:
		return _eecg
	case ResultTypeNumber, ResultTypeString:
		return _dfga(args[0])
	case ResultTypeList:
		_eedb := _eecg.ValueList
		_eacga := []Result{}
		for _, _feef := range _eedb {
			_beeb := _dfga(_feef)
			if _beeb.Type == ResultTypeError {
				return _beeb
			}
			_eacga = append(_eacga, _beeb)
		}
		return MakeListResult(_eacga)
	case ResultTypeArray:
		_aaec := _eecg.ValueArray
		_ecbbb := [][]Result{}
		for _, _deea := range _aaec {
			_gcbdc := []Result{}
			for _, _dfae := range _deea {
				_edce := _dfga(_dfae)
				if _edce.Type == ResultTypeError {
					return _edce
				}
				_gcbdc = append(_gcbdc, _edce)
			}
			_ecbbb = append(_ecbbb, _gcbdc)
		}
		return MakeArrayResult(_ecbbb)
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004c\u004fW\u0045\u0052")
	}
}

// ReferenceType is a type of reference
//go:generate stringer -type=ReferenceType
type ReferenceType byte

// Cell is an implementation of the Excel CELL function that returns information
// about the formatting, location, or contents of a cell.
func Cell(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 && len(args) != 2 {
		return MakeErrorResult("\u0043\u0045\u004cL \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gfcb := args[0].AsString()
	if _gfcb.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u0045\u004c\u004c\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065 \u0073t\u0072\u0069\u006e\u0067")
	}
	_bdaeb := args[1].Ref
	if _bdaeb.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0043\u0045\u004c\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064 \u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	_bagbb := _bdaeb.Value
	switch _gfcb.ValueString {
	case "\u0061d\u0064\u0072\u0065\u0073\u0073":
		_dddd, _efgg := _df.ParseCellReference(_bagbb)
		if _efgg != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _bagbb)
		}
		_eebb := "\u0024" + _dddd.Column + "\u0024" + _ga.Itoa(int(_dddd.RowIdx))
		if _dddd.SheetName != "" {
			_eebb = _dddd.SheetName + "\u0021" + _eebb
		}
		return MakeStringResult(_eebb)
	case "\u0063\u006f\u006c":
		_ebag, _ggfb := _df.ParseCellReference(_bagbb)
		if _ggfb != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _bagbb)
		}
		return MakeNumberResult(float64(_ebag.ColumnIdx + 1))
	case "\u0063\u006f\u006co\u0072":
		_bdcc := _fa.Contains(ctx.GetFormat(_bagbb), "\u005b\u0052\u0045D\u005d")
		return MakeBoolResult(_bdcc)
	case "\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0073":
		return args[1]
	case "\u0066\u0069\u006c\u0065\u006e\u0061\u006d\u0065":
		return MakeStringResult(ctx.GetFilename())
	case "\u0066\u006f\u0072\u006d\u0061\u0074":
		_ggbd := "\u0047"
		_abfb := ctx.GetFormat(_bagbb)
		if _abfb == "\u0047e\u006e\u0065\u0072\u0061\u006c" || _dbgcd.MatchString(_abfb) {
			_ggbd = "\u0046\u0030"
		} else if _abfb == "\u0030\u0025" {
			_ggbd = "\u0050\u0030"
		} else if _abfb == "\u004d\u004d\u004d\u0020\u0044\u0044" {
			_ggbd = "\u0044\u0032"
		} else if _abfb == "\u004d\u004d\u002fY\u0059" {
			_ggbd = "\u0044\u0033"
		} else if _abfb == "\u004d\u004d\u002f\u0044D/\u0059\u0059\u005c\u0020\u0048\u0048\u003a\u004d\u004d\u005c\u0020\u0041\u004d\u002fP\u004d" || _abfb == "M\u004d/\u0044\u0044\u002f\u0059\u0059\u0059\u0059\u005c \u0048\u0048\u003a\u004dM:\u0053\u0053" {
			_ggbd = "\u0044\u0034"
		} else if _abfb == "\u004d\u004d\u005c\u002d\u0044\u0044" {
			_ggbd = "\u0044\u0035"
		} else if _abfb == "\u0048H\u003aM\u004d\u003a\u0053\u0053\u005c\u0020\u0041\u004d\u002f\u0050\u004d" {
			_ggbd = "\u0044\u0036"
		} else if _abfb == "\u0048\u0048\u003aM\u004d\u005c\u0020\u0041\u004d\u002f\u0050\u004d" {
			_ggbd = "\u0044\u0037"
		} else if _abfb == "\u0048\u0048\u003a\u004d\u004d\u003a\u0053\u0053" {
			_ggbd = "\u0044\u0038"
		} else if _abfb == "\u0048\u0048\u003aM\u004d" {
			_ggbd = "\u0044\u0039"
		} else if _cgaed.MatchString(_abfb) {
			_ggbd = "\u002e\u0030"
		} else if _bdbaf.MatchString(_abfb) {
			_ggbd = "\u002e\u0030\u0028\u0029"
		} else if _gcdc.MatchString(_abfb) {
			_ggbd = "\u0043\u0030"
		} else if _cdeg.MatchString(_abfb) || _egfdg.MatchString(_abfb) {
			_ggbd = "\u0044\u0031"
		} else if _dbfe := _eddg.FindStringSubmatch(_abfb); len(_dbfe) > 1 {
			_ggbd = "\u0046" + _ga.Itoa(len(_dbfe[1]))
		} else if _ecef := _aeac.FindStringSubmatch(_abfb); len(_ecef) > 1 {
			_ggbd = "\u002e" + _ga.Itoa(len(_ecef[2]))
		} else if _egade := _adcf.FindStringSubmatch(_abfb); len(_egade) > 1 {
			_ggbd = "\u0050" + _ga.Itoa(len(_egade[2]))
		} else if _bbga := _fbdc.FindStringSubmatch(_abfb); len(_bbga) > 1 {
			_ggbd = "\u0043" + _bfage(_bbga, 1)
		} else if _cgbf := _gfge.FindStringSubmatch(_abfb); len(_cgbf) > 1 {
			_ggbd = "\u0043" + _bfage(_cgbf, 1)
		} else if _ecff := _gdaf.FindStringSubmatch(_abfb); len(_ecff) > 1 {
			_ggbd = "\u002e" + _bfage(_ecff, 1) + "\u0028\u0029"
		} else if _efbeg := _aace.FindStringSubmatch(_abfb); len(_efbeg) > 1 {
			_ggbd = "\u002e" + _bfage(_efbeg, 1)
		} else if _baea := _bfaf.FindStringSubmatch(_abfb); len(_baea) > 1 {
			_ggbd = "\u0053" + _bfage(_baea, 3)
		}
		if _ggbd != "\u0047" && _fa.Contains(_abfb, "\u005b\u0052\u0045D\u005d") {
			_ggbd += "\u002d"
		}
		return MakeStringResult(_ggbd)
	case "p\u0061\u0072\u0065\u006e\u0074\u0068\u0065\u0073\u0065\u0073":
		_egbd := ctx.GetFormat(_bagbb)
		if _gbcb.MatchString(_egbd) {
			return MakeNumberResult(1)
		} else {
			return MakeNumberResult(0)
		}
	case "\u0070\u0072\u0065\u0066\u0069\u0078":
		return MakeStringResult(ctx.GetLabelPrefix(_bagbb))
	case "\u0070r\u006f\u0074\u0065\u0063\u0074":
		_gbge := 0.0
		if ctx.GetLocked(_bagbb) {
			_gbge = 1.0
		}
		return MakeNumberResult(_gbge)
	case "\u0072\u006f\u0077":
		_eege, _dgff := _df.ParseCellReference(_bagbb)
		if _dgff != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _bagbb)
		}
		return MakeNumberResult(float64(_eege.RowIdx))
	case "\u0074\u0079\u0070\u0065":
		switch args[1].Type {
		case ResultTypeEmpty:
			return MakeStringResult("\u0062")
		case ResultTypeString:
			return MakeStringResult("\u006c")
		default:
			return MakeStringResult("\u0076")
		}
	case "\u0077\u0069\u0064t\u0068":
		_gbae, _gcbd := _df.ParseCellReference(_bagbb)
		if _gcbd != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _bagbb)
		}
		if _gbae.SheetName == "" {
			return MakeNumberResult(ctx.GetWidth(int(_gbae.ColumnIdx)))
		} else {
			return MakeNumberResult(ctx.Sheet(_gbae.SheetName).GetWidth(int(_gbae.ColumnIdx)))
		}
	}
	return MakeErrorResult("\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072g\u0075m\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0043\u0045\u004c\u004c\u003a\u0020" + _gfcb.ValueString)
}

// T is an implementation of the Excel T function that returns whether the
// argument is text.
func T(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("T\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_bfcd := args[0]
	if _bfcd.Type == ResultTypeError || _bfcd.Type == ResultTypeString {
		return _bfcd
	}
	return _aaa
}

// Pv implements the Excel PV function.
func Pv(args []Result) Result {
	_befe := len(args)
	if _befe < 3 || _befe > 5 {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u00205")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_befb := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_dfec := args[1].ValueNumber
	if _dfec != float64(int(_dfec)) {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0061\u0079\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cbbg := args[2].ValueNumber
	_bbbb := 0.0
	if _befe >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0056 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0075\u0074\u0075\u0072\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_bbbb = args[3].ValueNumber
	}
	_ggfe := 0.0
	if _befe == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_ggfe = args[4].ValueNumber
		if _ggfe != 0 {
			_ggfe = 1
		}
	}
	if _befb == 0 {
		return MakeNumberResult(-_cbbg*_dfec - _bbbb)
	} else {
		return MakeNumberResult((((1-_gg.Pow(1+_befb, _dfec))/_befb)*_cbbg*(1+_befb*_ggfe) - _bbbb) / _gg.Pow(1+_befb, _dfec))
	}
}

// Pmt implements the Excel PMT function.
func Pmt(args []Result) Result {
	_aaaf := len(args)
	if _aaaf < 3 || _aaaf > 5 {
		return MakeErrorResult("\u0050\u004dT\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u0020\u0035")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fcaea := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004dT\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cabc := args[1].ValueNumber
	if _cabc == 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u00200")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065\u006e\u0074 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_gccg := args[2].ValueNumber
	_gbgf := 0.0
	if _aaaf >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("P\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0075\u0074\u0075\u0072e \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gbgf = args[3].ValueNumber
	}
	_ffge := 0.0
	if _aaaf == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0079\u0070\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_ffge = args[4].ValueNumber
		if _ffge != 0 {
			_ffge = 1
		}
	}
	var _gffd float64
	if _fcaea == 0 {
		_gffd = (_gccg + _gbgf) / _cabc
	} else {
		_eacb := _gg.Pow(1+_fcaea, _cabc)
		if _ffge == 1 {
			_gffd = (_gbgf*_fcaea/(_eacb-1) + _gccg*_fcaea/(1-1/_eacb)) / (1 + _fcaea)
		} else {
			_gffd = _gbgf*_fcaea/(_eacb-1) + _gccg*_fcaea/(1-1/_eacb)
		}
	}
	return MakeNumberResult(-_gffd)
}

var _edagf = []ri{{1000, "\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

func _bdgac(_baeba Context, _cebd Evaluator, _cgaag, _aebgc string) Result {
	_ggeac, _fbccf := _df.ParseCellReference(_cgaag)
	if _fbccf != nil {
		return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073e\u0020r\u0061n\u0067e\u0020\u0025\u0073\u003a\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _cgaag, _fbccf.Error()))
	}
	_cage, _eefad := _ggeac.ColumnIdx, _ggeac.RowIdx
	_ebdge, _fdbg := _df.ParseCellReference(_aebgc)
	if _fdbg != nil {
		return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073e\u0020r\u0061n\u0067e\u0020\u0025\u0073\u003a\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _aebgc, _fdbg.Error()))
	}
	_aagbe, _eccec := _ebdge.ColumnIdx, _ebdge.RowIdx
	_abeb := [][]Result{}
	for _defga := _eefad; _defga <= _eccec; _defga++ {
		_fdfc := []Result{}
		for _ebaac := _cage; _ebaac <= _aagbe; _ebaac++ {
			_abcc := _baeba.Cell(_b.Sprintf("\u0025\u0073\u0025\u0064", _df.IndexToColumn(_ebaac), _defga), _cebd)
			_fdfc = append(_fdfc, _abcc)
		}
		_abeb = append(_abeb, _fdfc)
	}
	if len(_abeb) == 1 {
		if len(_abeb[0]) == 1 {
			return _abeb[0][0]
		}
		return MakeListResult(_abeb[0])
	}
	return MakeArrayResult(_abeb)
}
func (_eefgf *Lexer) Next() *node {
	_eefgf._cfdcd.Lock()
	defer _eefgf._cfdcd.Unlock()
	if len(_eefgf._egfc) > 0 {
		_gbba := _eefgf._egfc[0]
		_eefgf._egfc = _eefgf._egfc[1:]
		return _gbba
	}
	return _eefgf.nextRaw()
}

// HorizontalRange is a range expression that when evaluated returns a list of Results from references like 1:4 (all cells from rows 1 to 4).
type HorizontalRange struct{ _adac, _gfea int }

// NewPrefixHorizontalRange constructs a new full rows range with prefix.
func NewPrefixHorizontalRange(pfx Expression, v string) Expression {
	_cbdg := _fa.Split(v, "\u003a")
	if len(_cbdg) != 2 {
		return nil
	}
	_aegfe, _ := _ga.Atoi(_cbdg[0])
	_ggfcf, _ := _ga.Atoi(_cbdg[1])
	return PrefixHorizontalRange{pfx, _aegfe, _ggfcf}
}

// Ipmt implements the Excel IPMT function.
func Ipmt(args []Result) Result {
	_edegb := len(args)
	if _edegb < 4 || _edegb > 6 {
		return MakeErrorResult("\u0049P\u004d\u0054\u0020\u0072\u0065\u0071\u0075ir\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074s\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0062\u0065\u0074\u0077\u0065\u0065n\u0020\u0066ou\u0072\u0020\u0061n\u0064\u0020\u0073\u0069\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("I\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_deeb := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004dT\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_caef := args[1].ValueNumber
	if _caef <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0050\u004d\u0054\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_efda := args[2].ValueNumber
	if _efda <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062er\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_fcbf := args[3].ValueNumber
	_fcgg := 0.0
	if _edegb > 4 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_fcgg = args[4].ValueNumber
	}
	_edcc := 0
	if _edegb == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("I\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_edcc = int(args[5].ValueNumber)
		if _edcc != 0 {
			_edcc = 1
		}
	}
	return MakeNumberResult(_aacfa(_deeb, _caef, _efda, _fcbf, _fcgg, _edcc))
}

// ISERR is an implementation of the Excel ISERR() function.
func IsErr(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0045\u0052\u0052\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError && args[0].ValueString != "\u0023\u004e\u002f\u0041")
}

// Coupdays implements the Excel COUPDAYS function.
func Coupdays(args []Result) Result {
	_adcba, _ccdc := _gdgb(args, "\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053")
	if _ccdc.Type == ResultTypeError {
		return _ccdc
	}
	return MakeNumberResult(_efcg(_adcba._eebf, _adcba._edge, _adcba._eda, _adcba._ceca))
}
func _abdg(_faea, _fgcd, _bag int) int {
	if _faea > _fgcd {
		return 0
	}
	if _ggc(_bag) {
		return (_fgcd - _faea + 1) * 360
	}
	_dccb := 0
	for _gfbg := _faea; _gfbg <= _fgcd; _gfbg++ {
		_cgdbd := 365
		if _dbfd(_gfbg) {
			_cgdbd = 366
		}
		_dccb += _cgdbd
	}
	return _dccb
}

var _gcfac = [...]int{-1000, -7, -3, -1, 27, 18, 22, 23, -2, -8, -4, -9, 20, -14, 10, 11, 12, 13, -5, -13, -6, -12, 17, 16, 15, 9, 4, 5, 22, 23, 24, 25, 26, 28, 29, 30, 31, 27, 32, 35, -1, 18, 27, -15, -17, -1, -1, -1, -1, 33, -5, 4, 5, 21, -16, -11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 36, 34, 21, -5, 33, 21, 34, 19, -17, -1, -5, -10, -1}

// Eval evaluates a vertical range with prefix returning a list of results or an error.
func (_decb PrefixVerticalRange) Eval(ctx Context, ev Evaluator) Result {
	_bgaf := _decb._ccea.Reference(ctx, ev)
	switch _bgaf.Type {
	case ReferenceTypeSheet:
		_cdga := _decb.verticalRangeReference(_bgaf.Value)
		if _eagga, _dfeg := ev.GetFromCache(_cdga); _dfeg {
			return _eagga
		}
		_dfcf := ctx.Sheet(_bgaf.Value)
		_dgbaf, _gdbc := _ffbba(_dfcf, _decb._fbedd, _decb._gacbg)
		_deda := _bdgac(_dfcf, ev, _dgbaf, _gdbc)
		ev.SetCache(_cdga, _deda)
		return _deda
	default:
		return MakeErrorResult(_b.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _bgaf.Type))
	}
}

// Reference returns an invalid reference for Number.
func (_ggebg Number) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

const _fagg = 57367

func (_ecgc Result) AsString() Result {
	switch _ecgc.Type {
	case ResultTypeNumber:
		return MakeStringResult(_ecgc.Value())
	default:
		return _ecgc
	}
}
func MakeRangeReference(ref string) Reference { return Reference{Type: ReferenceTypeRange, Value: ref} }
func (_cdf *evCache) GetFromCache(key string) (Result, bool) {
	_cdf._adc.Lock()
	_cgdb, _dfg := _cdf._fe[key]
	_cdf._adc.Unlock()
	return _cgdb, _dfg
}

var _dfeac = [...]int{0}

// ISBLANK is an implementation of the Excel ISBLANK() function.
func IsBlank(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("I\u0053\u0042\u004c\u0041\u004e\u004b(\u0029\u0020\u0061\u0063\u0063\u0065p\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeEmpty)
}

var _afbef []byte = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

const _aaeab int = 30

// Cumprinc implements the Excel CUMPRINC function.
func Cumprinc(args []Result) Result {
	_dec, _bbfg := _bea(args, "\u0043\u0055\u004d\u0050\u0052\u0049\u004e\u0043")
	if _bbfg.Type == ResultTypeError {
		return _bbfg
	}
	_afed := _dec._ebca
	_bbdg := _dec._deb
	_daa := _dec._fcad
	_agf := _dec._bgff
	_eaff := _dec._eccd
	_dgfd := _dec._aaac
	_dfa := _dgfg(_afed, _bbdg, _daa, 0, _dgfd)
	_gbcf := 0.0
	if _agf == 1 {
		if _dgfd == 0 {
			_gbcf = _dfa + _daa*_afed
		} else {
			_gbcf = _dfa
		}
		_agf++
	}
	for _gfgf := _agf; _gfgf <= _eaff; _gfgf++ {
		if _dgfd == 1 {
			_gbcf += _dfa - (_facb(_afed, _gfgf-2, _dfa, _daa, 1)-_dfa)*_afed
		} else {
			_gbcf += _dfa - _facb(_afed, _gfgf-1, _dfa, _daa, 0)*_afed
		}
	}
	return MakeNumberResult(_gbcf)
}

// NewRange constructs a new range.
func NewRange(from, to Expression) Expression { return Range{from, to} }

// Cumipmt implements the Excel CUMIPMT function.
func Cumipmt(args []Result) Result {
	_ccdf, _dbg := _bea(args, "\u0043U\u004d\u0049\u0050\u004d\u0054")
	if _dbg.Type == ResultTypeError {
		return _dbg
	}
	_eceb := _ccdf._ebca
	_gedg := _ccdf._deb
	_ebcb := _ccdf._fcad
	_gdaa := _ccdf._bgff
	_fbbaa := _ccdf._eccd
	_afba := _ccdf._aaac
	_cgcf := _dgfg(_eceb, _gedg, _ebcb, 0, _afba)
	_efcgc := 0.0
	if _gdaa == 1 {
		if _afba == 0 {
			_efcgc = -_ebcb
			_gdaa++
		}
	}
	for _cedc := _gdaa; _cedc <= _fbbaa; _cedc++ {
		if _afba == 1 {
			_efcgc += _facb(_eceb, _cedc-2, _cgcf, _ebcb, 1) - _cgcf
		} else {
			_efcgc += _facb(_eceb, _cedc-1, _cgcf, _ebcb, 0)
		}
	}
	_efcgc *= _eceb
	return MakeNumberResult(_efcgc)
}

// Oddlprice implements the Excel ODDLPRICE function.
func Oddlprice(args []Result) Result {
	if len(args) != 8 && len(args) != 9 {
		return MakeErrorResult("\u004f\u0044\u0044L\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u006e\u0069\u006e\u0065\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_ccde, _gfbb, _fgdc := _daea(args[0], args[1], "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _fgdc.Type == ResultTypeError {
		return _fgdc
	}
	_bbba, _fgdc := _dddb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _fgdc.Type == ResultTypeError {
		return _fgdc
	}
	if _bbba >= _ccde {
		return MakeErrorResultType(ErrorTypeNum, "\u004c\u0061\u0073\u0074\u0020i\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0064\u0061\u0074\u0065\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074e")
	}
	_cede := args[3]
	if _cede.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cgbc := _cede.ValueNumber
	if _cgbc < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	_bgfbg := args[4]
	if _bgfbg.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0079i\u0065\u006c\u0064\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_ffce := _bgfbg.ValueNumber
	if _ffce < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_gfa := args[5]
	if _gfa.Type != ResultTypeNumber {
		return MakeErrorResult("\u004fD\u0044\u004cP\u0052\u0049\u0043\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_bdfc := _gfa.ValueNumber
	if _bdfc < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_fcbd := args[6]
	if _fcbd.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049C\u0045\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_babd := float64(int(_fcbd.ValueNumber))
	if !_degc(_babd) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_gfad := 0
	if len(args) == 8 && args[7].Type != ResultTypeEmpty {
		_gbgb := args[7]
		if _gbgb.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0062a\u0073\u0069\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
		}
		_gfad = int(_gbgb.ValueNumber)
		if !_efb(_gfad) {
			return MakeErrorResultType(ErrorTypeNum, "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0062\u0061\u0073\u0069s\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020\u004f\u0044\u0044\u004c\u0050\u0052\u0049C\u0045")
		}
	}
	_ffg, _fgdc := _cbfa(_bbba, _gfbb, _gfad)
	if _fgdc.Type == ResultTypeError {
		return _fgdc
	}
	_ffg *= _babd
	_decd, _fgdc := _cbfa(_ccde, _gfbb, _gfad)
	if _fgdc.Type == ResultTypeError {
		return _fgdc
	}
	_decd *= _babd
	_fdbcc, _fgdc := _cbfa(_bbba, _ccde, _gfad)
	if _fgdc.Type == ResultTypeError {
		return _fgdc
	}
	_fdbcc *= _babd
	_egfd := _bdfc + _ffg*100*_cgbc/_babd
	_egfd /= _decd*_ffce/_babd + 1
	_egfd -= _fdbcc * 100 * _cgbc / _babd
	return MakeNumberResult(_egfd)
}

// Averagea implements the AVERAGEA function, AVERAGEA counts cells that contain
// text as a zero where AVERAGE ignores them entirely.
func Averagea(args []Result) Result {
	_gfdff, _eddd := _dfaca(args, true)
	if _eddd == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0041\u0056\u0045\u0052AG\u0045\u0020\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065r\u006f")
	}
	return MakeNumberResult(_gfdff / _eddd)
}

// MakeStringResult constructs a string result.
func MakeStringResult(s string) Result { return Result{Type: ResultTypeString, ValueString: s} }
func _cc(_cge, _ca [][]Result) bool {
	if len(_cge) != len(_ca) {
		return false
	}
	for _afd := range _cge {
		if len(_cge[_afd]) != len(_ca[_afd]) {
			return false
		}
	}
	return true
}
func _fab(_cag BinOpType, _gca [][]Result, _egd Result) Result {
	_bb := [][]Result{}
	for _age := range _gca {
		_fd := _cgc(_cag, _gca[_age], _egd)
		if _fd.Type == ResultTypeError {
			return _fd
		}
		_bb = append(_bb, _fd.ValueList)
	}
	return MakeArrayResult(_bb)
}

// FloorMath implements _xlfn.FLOOR.MATH which rounds numbers down to the
// nearest multiple of the second argument, toward or away from zero as
// specified by the third argument.
func FloorMath(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u002e\u004dA\u0054\u0048\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u002e\u004dA\u0054\u0048\u0028)\u0020\u0061\u006c\u006co\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_fecg := args[0].AsNumber()
	if _fecg.Type != ResultTypeNumber {
		return MakeErrorResult("f\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020FL\u004f\u004f\u0052\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073t \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_efbc := float64(1)
	if _fecg.ValueNumber < 0 {
		_efbc = -1
	}
	if len(args) > 1 {
		_dgbc := args[1].AsNumber()
		if _dgbc.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061r\u0067\u0075\u006den\u0074\u0020\u0074\u006f\u0020\u0046L\u004f\u004f\u0052\u002e\u004d\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006db\u0065\u0072")
		}
		_efbc = _dgbc.ValueNumber
	}
	_feaf := float64(1)
	if len(args) > 2 {
		_bcga := args[2].AsNumber()
		if _bcga.Type != ResultTypeNumber {
			return MakeErrorResult("t\u0068\u0069\u0072\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020FL\u004f\u004f\u0052\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073t \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_feaf = _bcga.ValueNumber
	}
	if len(args) == 1 {
		return MakeNumberResult(_gg.Floor(_fecg.ValueNumber))
	}
	_abfaf := _fecg.ValueNumber
	_abfaf, _gced := _gg.Modf(_abfaf / _efbc)
	if _gced != 0 && _fecg.ValueNumber < 0 && _feaf > 0 {
		_abfaf++
	}
	return MakeNumberResult(_abfaf * _efbc)
}

// Clean is an implementation of the Excel CLEAN function that removes
// unprintable characters.
func Clean(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u004c\u0045\u0041\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gdcdd := args[0].AsString()
	if _gdcdd.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_afbca := _bg.Buffer{}
	for _, _aebe := range _gdcdd.ValueString {
		if _g.IsPrint(_aebe) {
			_afbca.WriteRune(_aebe)
		}
	}
	return MakeStringResult(_afbca.String())
}

// ISERROR is an implementation of the Excel ISERROR() function.
func IsError(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("I\u0053\u0045\u0052\u0052\u004f\u0052(\u0029\u0020\u0061\u0063\u0063\u0065p\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError)
}
func _dfga(_dacgc Result) Result {
	if _dacgc.Type == ResultTypeEmpty {
		return _dacgc
	}
	_cbggf := _dacgc.AsString()
	if _cbggf.Type != ResultTypeString {
		return MakeErrorResult("\u004c\u004f\u0057\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if _dacgc.IsBoolean {
		if _cbggf.ValueString == "\u0031" {
			return MakeStringResult("\u0074\u0072\u0075\u0065")
		} else if _cbggf.ValueString == "\u0030" {
			return MakeStringResult("\u0066\u0061\u006cs\u0065")
		} else {
			return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004c\u004fW\u0045\u0052")
		}
	} else {
		return MakeStringResult(_fa.ToLower(_cbggf.ValueString))
	}
}
func _gfbga(_fgca []Result) Result {
	_cddb := _fgca[0].ValueArray
	if len(_fgca) == 1 {
		_bdfe := [][]Result{}
		for _, _abbgb := range _cddb {
			_bdfe = append(_bdfe, _bdgdb([]Result{MakeListResult(_abbgb)}).ValueList)
		}
		return MakeArrayResult(_bdfe)
	} else if len(_fgca) == 2 {
		_cgaeb := len(_cddb)
		_beea := len(_cddb[0])
		_aege := _aedf(_fgca[1], _cgaeb, _beea)
		_bfgf := len(_aege)
		_bdfb := [][]Result{}
		var _dfcd []Result
		for _gded, _baee := range _cddb {
			if _gded < _bfgf {
				_dfcd = _aege[_gded]
			} else {
				_dfcd = _cfff(MakeErrorResultType(ErrorTypeNA, ""), _beea)
			}
			_bdfb = append(_bdfb, _bdgdb([]Result{MakeListResult(_baee), MakeListResult(_dfcd)}).ValueList)
		}
		return MakeArrayResult(_bdfb)
	} else if len(_fgca) == 3 {
		_cgbcb := len(_cddb)
		_ffdab := len(_cddb[0])
		_fbaeg := _aedf(_fgca[1], _cgbcb, _ffdab)
		_dbabb := _aedf(_fgca[2], _cgbcb, _ffdab)
		_ffbg := len(_fbaeg)
		_eada := len(_dbabb)
		_cabd := [][]Result{}
		var _dabeb, _edag []Result
		for _ggdc, _gaaf := range _cddb {
			if _ggdc < _ffbg {
				_dabeb = _fbaeg[_ggdc]
			} else {
				_dabeb = _cfff(MakeErrorResultType(ErrorTypeNA, ""), _ffdab)
			}
			if _ggdc < _eada {
				_edag = _dbabb[_ggdc]
			} else {
				_edag = _cfff(MakeErrorResultType(ErrorTypeNA, ""), _ffdab)
			}
			_cabd = append(_cabd, _bdgdb([]Result{MakeListResult(_gaaf), MakeListResult(_dabeb), MakeListResult(_edag)}).ValueList)
		}
		return MakeArrayResult(_cabd)
	}
	return MakeErrorResultType(ErrorTypeValue, "")
}

// If is an implementation of the Excel IF() function. It takes one, two or
// three arguments.
func If(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0049\u0046\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0049\u0046\u0020ac\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0074\u0020m\u006fs\u0074 \u0074h\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gbdf := args[0]
	switch _gbdf.Type {
	case ResultTypeError:
		return _gbdf
	case ResultTypeNumber:
		if len(args) == 1 {
			return MakeBoolResult(_gbdf.ValueNumber != 0)
		}
		if _gbdf.ValueNumber != 0 {
			return args[1]
		}
		if len(args) == 3 {
			return args[2]
		} else {
			return MakeBoolResult(false)
		}
	case ResultTypeList:
		return _bdgdb(args)
	case ResultTypeArray:
		return _gfbga(args)
	default:
		return MakeErrorResult("\u0049F\u0020\u0069n\u0069\u0074\u0069\u0061l\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u006d\u0075\u0073t \u0062\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u006f\u0072 \u0061\u0072r\u0061\u0079")
	}
}

var _dda = map[string]int{"\u006aa\u006e\u0075\u0061\u0072\u0079": 1, "\u0066\u0065\u0062\u0072\u0075\u0061\u0072\u0079": 2, "\u006d\u0061\u0072c\u0068": 3, "\u0061\u0070\u0072i\u006c": 4, "\u006d\u0061\u0079": 5, "\u006a\u0075\u006e\u0065": 6, "\u006a\u0075\u006c\u0079": 7, "\u0061\u0075\u0067\u0075\u0073\u0074": 8, "\u0073e\u0070\u0074\u0065\u006d\u0070\u0065r": 9, "\u006fc\u0074\u006f\u0062\u0065\u0072": 10, "\u006e\u006f\u0076\u0065\u006d\u0062\u0065\u0072": 11, "\u0064\u0065\u0063\u0065\u006d\u0062\u0065\u0072": 12, "\u006a\u0061\u006e": 1, "\u0066\u0065\u0062": 2, "\u006d\u0061\u0072": 3, "\u0061\u0070\u0072": 4, "\u006a\u0075\u006e": 6, "\u006a\u0075\u006c": 7, "\u0061\u0075\u0067": 8, "\u0073\u0065\u0070": 9, "\u006f\u0063\u0074": 10, "\u006e\u006f\u0076": 11, "\u0064\u0065\u0063": 12}

// Rept is an implementation of the Excel REPT function that returns n copies of
// a string.
func Rept(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("R\u0045\u0050\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	_efaa := args[0].AsString()
	if _efaa.Type != ResultTypeString {
		return MakeErrorResult("\u0050R\u004f\u0050E\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_fead := args[1].AsNumber()
	if _fead.Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052O\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	if _fead.ValueNumber < 0 {
		return MakeErrorResult("\u0050\u0052\u004fP\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074o\u0020\u0062\u0065\u0020\u003e\u003d\u0020\u0030")
	}
	if _fead.ValueNumber == 0 {
		return MakeStringResult("")
	}
	_bbdd := _bg.Buffer{}
	for _cffa := 0; _cffa < int(_fead.ValueNumber); _cffa++ {
		_bbdd.WriteString(_efaa.ValueString)
	}
	return MakeStringResult(_bbdd.String())
}

var _dddab = [...]struct {
	_ecbfe int
	_gcfcb int
	_fcbgd string
}{}

// PrefixRangeExpr is a range expression that when evaluated returns a list of Results from a given sheet like Sheet1!A1:B4 (all cells from A1 to B4 from a sheet 'Sheet1').
type PrefixRangeExpr struct{ _cbcc, _dgcf, _ccefe Expression }

const _gbecc int = 30

func _efb(_cged int) bool { return _cged >= 0 && _cged <= 4 }

type amorArgs struct {
	_fgb   float64
	_bggd  float64
	_gagfe float64
	_cggf  float64
	_cdgcc int
	_baca  float64
	_fcfd  int
}

var _dbgcd, _eddg, _cgaed, _bdbaf, _aace, _aeac, _gdaf, _gbcb, _adcf, _gcdc, _fbdc, _gfge, _cdeg, _egfdg, _bfaf *_af.Regexp

// ISREF is an implementation of the Excel ISREF() function.
func IsRef(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0052\u0045\u0046\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(ev.LastEvalIsRef())
}

// String returns a string representation of a range with prefix.
func (_eadg PrefixRangeExpr) String() string {
	return _b.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _eadg._cbcc.String(), _eadg._dgcf.String(), _eadg._ccefe.String())
}
func _fbge(_eedcc string, _acba func(_cecac float64) float64) Function {
	return func(_acff []Result) Result {
		if len(_acff) != 1 {
			return MakeErrorResult(_eedcc + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_fgafd := _acff[0].AsNumber()
		switch _fgafd.Type {
		case ResultTypeNumber:
			_baeb := _acba(_fgafd.ValueNumber)
			if _gg.IsNaN(_baeb) {
				return MakeErrorResult(_eedcc + "\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0065\u0064\u0020\u004e\u0061\u004e")
			}
			if _gg.IsInf(_baeb, 0) {
				return MakeErrorResult(_eedcc + "\u0020r\u0065t\u0075\u0072\u006e\u0065\u0064 \u0069\u006ef\u0069\u006e\u0069\u0074\u0079")
			}
			if _baeb == 0 {
				return MakeErrorResultType(ErrorTypeDivideByZero, _eedcc+"\u0020d\u0069v\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065\u0072\u006f")
			}
			return MakeNumberResult(1 / _baeb)
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult(_eedcc + "\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072i\u0063\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		case ResultTypeError:
			return _fgafd
		default:
			return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0068a\u006e\u0064\u006c\u0065d\u0020\u0025\u0073\u0028\u0029\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _eedcc, _fgafd.Type))
		}
	}
}

// FloorPrecise is an implementation of the FlOOR.PRECISE function.
func FloorPrecise(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0046\u004cO\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0046L\u004f\u004fR\u002e\u0050\u0052\u0045C\u0049\u0053\u0045(\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020at\u0020\u006d\u006fs\u0074\u0020t\u0077\u006f\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_cfab := args[0].AsNumber()
	if _cfab.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020F\u004c\u004f\u004f\u0052\u002e\u0050\u0052E\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_fegg := float64(1)
	if _cfab.ValueNumber < 0 {
		_fegg = -1
	}
	if len(args) > 1 {
		_fdgca := args[1].AsNumber()
		if _fdgca.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006ed\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020F\u004c\u004f\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065r")
		}
		_fegg = _gg.Abs(_fdgca.ValueNumber)
	}
	if len(args) == 1 {
		return MakeNumberResult(_gg.Floor(_cfab.ValueNumber))
	}
	_acbf := _cfab.ValueNumber
	_acbf, _abdf := _gg.Modf(_acbf / _fegg)
	if _abdf != 0 {
		if _cfab.ValueNumber < 0 {
			_acbf--
		}
	}
	return MakeNumberResult(_acbf * _fegg)
}

// String returns an empty string for EmptyExpr.
func (_bfc EmptyExpr) String() string { return "" }

// Rand is an implementation of the Excel RAND() function that returns random
// numbers in the range [0,1).
func Rand(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("R\u0041\u004e\u0044\u0028\u0029\u0020a\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006e\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	return MakeNumberResult(_gbca.Float64())
}

// Reference returns an invalid reference for String.
func (_ggbeg String) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Mirr implements the Excel MIRR function.
func Mirr(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u004d\u0049R\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeList && args[0].Type != ResultTypeArray {
		return MakeErrorResult("M\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0076\u0061\u006c\u0075\u0065s\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020ar\u0072\u0061\u0079 \u0074y\u0070\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049\u0052\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0069\u006e\u0061\u006e\u0063e\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_aacg := args[1].ValueNumber + 1
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049\u0052\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0069\u006e\u0076\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_bfed := args[2].ValueNumber + 1
	if _bfed == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_bab := _aefda(args[0])
	_abbb := float64(len(_bab))
	_gbee, _efga := 0.0, 0.0
	_fcfc, _gbea := 1.0, 1.0
	_fcdc, _faafc := false, false
	for _, _ffbc := range _bab {
		for _, _fdec := range _ffbc {
			if _fdec.Type == ResultTypeNumber && !_fdec.IsBoolean {
				_baad := _fdec.ValueNumber
				if _baad == 0 {
					continue
				} else {
					if _baad > 0 {
						_fcdc = true
						_efga += _fdec.ValueNumber * _gbea
					} else {
						_faafc = true
						_gbee += _fdec.ValueNumber * _fcfc
					}
					_fcfc /= _aacg
					_gbea /= _bfed
				}
			}
		}
	}
	if !_fcdc || !_faafc {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_eaee := -_efga / _gbee
	_eaee *= _gg.Pow(_bfed, _abbb-1)
	_eaee = _gg.Pow(_eaee, 1/(_abbb-1))
	return MakeNumberResult(_eaee - 1)
}

// False is an implementation of the Excel FALSE() function. It takes no
// arguments.
func False(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0046A\u004c\u0053\u0045\u0020\u0074\u0061\u006b\u0065\u0073\u0020\u006eo\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(false)
}
func _dgc(_bae, _dcge, _acb float64) float64 { return (_bae*3600 + _dcge*60 + _acb) / 86400 }
func _gfag(_cfce string, _ebbbf []Result) (*parsedSearchObject, Result) {
	_faec := len(_ebbbf)
	if _faec != 2 && _faec != 3 {
		return nil, MakeErrorResult(_cfce + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006fr\u0020t\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gddg := _ebbbf[0]
	if _gddg.Type == ResultTypeError {
		return nil, _gddg
	}
	if _gddg.Type != ResultTypeString && _gddg.Type != ResultTypeNumber {
		return nil, MakeErrorResult("\u0054\u0068e\u0020\u0066\u0069\u0072s\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_adbfc := _ebbbf[1]
	if _adbfc.Type == ResultTypeError {
		return nil, _adbfc
	}
	if _adbfc.Type != ResultTypeString && _adbfc.Type != ResultTypeNumber {
		return nil, MakeErrorResult("\u0054\u0068\u0065\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020a\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_ceea := _adbfc.Value()
	_gdea := _gddg.Value()
	_fdega := 1
	if _faec == 3 && _ebbbf[2].Type != ResultTypeEmpty {
		_bgeea := _ebbbf[2]
		if _bgeea.Type != ResultTypeNumber {
			return nil, MakeErrorResult("P\u006f\u0073\u0069\u0074\u0069\u006fn\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0061\u0020n\u0075m\u0062\u0065\u0072")
		}
		_fdega = int(_bgeea.ValueNumber)
		if _fdega < 1 {
			return nil, MakeErrorResultType(ErrorTypeValue, "\u0050\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u0061 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074h\u0061\u006e\u0020\u0030")
		}
		if _fdega > len(_ceea) {
			return nil, MakeErrorResultType(ErrorTypeValue, "\u0050\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u0061 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074h\u0061\u006e\u0020\u0030")
		}
	}
	return &parsedSearchObject{_gdea, _ceea, _fdega}, _aaa
}

// Odd is an implementation of the Excel ODD() that rounds a number to the
// nearest odd integer.
func Odd(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("O\u0044\u0044\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006ee\u0020\u0061\u0072g\u0075m\u0065\u006e\u0074")
	}
	_agdb := args[0].AsNumber()
	if _agdb.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cbce := _gg.Signbit(_agdb.ValueNumber)
	_eefb, _aebf := _gg.Modf((_agdb.ValueNumber - 1) / 2)
	_gfbcg := _eefb*2 + 1
	if _aebf != 0 {
		if !_cbce {
			_gfbcg += 2
		} else {
			_gfbcg -= 2
		}
	}
	return MakeNumberResult(_gfbcg)
}

const _cgbfg = 2

// SupportedFunctions returns a list of supported functions.
func SupportedFunctions() []string {
	_adbe := []string{}
	for _beff := range _ecfcd {
		_adbe = append(_adbe, _beff)
	}
	for _eagec := range _ddebg {
		_adbe = append(_adbe, _eagec)
	}
	_f.Strings(_adbe)
	return _adbe
}
func _bea(_cgfd []Result, _daed string) (*cumulArgs, Result) {
	if len(_cgfd) != 6 {
		return nil, MakeErrorResult(_daed + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _cgfd[0].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_daed + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0072\u0061te \u0074o \u0062\u0065\u0020\u006e\u0075\u006d\u0062er\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_bagf := _cgfd[0].ValueNumber
	if _bagf <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+"\u0020r\u0065\u0071u\u0069\u0072\u0065s\u0020\u0072\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006fs\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _cgfd[1].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_daed + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_gbgc := _cgfd[1].ValueNumber
	if _gbgc <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	if _cgfd[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_daed + "\u0020r\u0065\u0071u\u0069\u0072\u0065s\u0020\u0070\u0072\u0065\u0073\u0065\u006et\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bcdf := _cgfd[2].ValueNumber
	if _bcdf <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _cgfd[3].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_daed + "\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073 \u0073\u0074\u0061r\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_fff := _cgfd[3].ValueNumber
	if _fff <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073t\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069o\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _cgfd[4].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_daed + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aggdd := _cgfd[4].ValueNumber
	if _aggdd <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+"\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020\u0070\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	if _aggdd < _fff {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+"\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020p\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0061\u0074\u0065\u0072\u0020o\u0072\u0020\u0065\u0071\u0075a\u006c\u0020\u0074\u006f\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064")
	}
	if _aggdd > _gbgc {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+" \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074o\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0070\u0065\u0072io\u0064\u0073\u0020r\u0061n\u0067\u0065")
	}
	_gbf := int(_cgfd[5].ValueNumber)
	if _gbf != 0 && _gbf != 1 {
		return nil, MakeErrorResultType(ErrorTypeNum, _daed+" \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f \u0062\u0065\u00200\u0020o\u0072\u0020\u0031")
	}
	return &cumulArgs{_bagf, _gbgc, _bcdf, _fff, _aggdd, _gbf}, _aaa
}

const _agaaf = 57344

type node struct {
	_ccfcc tokenType
	_bacgg string
}

// Findb is an implementation of the Excel FINDB().
func Findb(ctx Context, ev Evaluator, args []Result) Result {
	if !ctx.IsDBCS() {
		return Find(args)
	}
	_ffcec, _ffcce := _gfag("\u0046\u0049\u004e\u0044", args)
	if _ffcce.Type != ResultTypeEmpty {
		return _ffcce
	}
	_deba := _ffcec._fcac
	if _deba == "" {
		return MakeNumberResult(1.0)
	}
	_gccca := _ffcec._edegc
	_fgbde := _ffcec._edafc - 1
	_ddge := 1
	_feca := 0
	for _bdafb := range _gccca {
		if _bdafb != 0 {
			_abade := 1
			if _bdafb-_feca > 1 {
				_abade = 2
			}
			_ddge += _abade
		}
		if _ddge > _fgbde {
			_caedc := _fa.Index(_gccca[_bdafb:], _deba)
			if _caedc == 0 {
				return MakeNumberResult(float64(_ddge))
			}
		}
		_feca = _bdafb
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// RandBetween is an implementation of the Excel RANDBETWEEN() function that returns a random
// integer in the range specified.
func RandBetween(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0052A\u004e\u0044B\u0045\u0054\u0057\u0045E\u004e\u0028\u0029 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006eu\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_caaba := args[0].AsNumber()
	_bcbbf := args[1].AsNumber()
	if _caaba.Type != ResultTypeNumber || _bcbbf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052A\u004e\u0044B\u0045\u0054\u0057\u0045E\u004e\u0028\u0029 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006eu\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	if _bcbbf.ValueNumber < _caaba.ValueNumber {
		return MakeErrorResult("\u0052\u0041\u004e\u0044\u0042E\u0054\u0057\u0045\u0045\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065r")
	}
	_cgca := int64(_caaba.ValueNumber)
	_dbec := int64(_bcbbf.ValueNumber)
	return MakeNumberResult(float64(_gbca.Int63n(_dbec-_cgca+1) + _cgca))
}
func _ffed(_ecb []Result, _defc string) (*amorArgs, Result) {
	_bbea := len(_ecb)
	if _bbea != 6 && _bbea != 7 {
		return nil, MakeErrorResult(_defc + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020\u006fr\u0020s\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _ecb[0].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_defc + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0063\u006fst \u0074o \u0062\u0065\u0020\u006e\u0075\u006d\u0062er\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_aacfb := _ecb[0].ValueNumber
	if _aacfb < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _defc+"\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0063\u006f\u0073\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	_acbe, _gggab := _dddb(_ecb[1], "\u0064\u0061\u0074\u0065\u0020\u0070\u0075\u0072\u0063h\u0061\u0073\u0065\u0064", _defc)
	if _gggab.Type == ResultTypeError {
		return nil, _gggab
	}
	_fgfb, _gggab := _dddb(_ecb[2], "\u0066\u0069\u0072s\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064", _defc)
	if _gggab.Type == ResultTypeError {
		return nil, _gggab
	}
	if _fgfb < _acbe {
		return nil, MakeErrorResultType(ErrorTypeNum, _defc+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074 \u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020l\u0061\u0074\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061te\u0020\u0070\u0075\u0072\u0063\u0068\u0061\u0073\u0065\u0064")
	}
	if _ecb[3].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_defc + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006cv\u0061\u0067\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fgab := _ecb[3].ValueNumber
	if _fgab < 0 || _fgab > _aacfb {
		return nil, MakeErrorResultType(ErrorTypeNum, _defc+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061g\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0062\u0065\u0074\u0077\u0065e\u006e\u0020\u0030\u0020\u0061\u006e\u0064\u0020\u0074\u0068\u0065\u0020in\u0069\u0074\u0069\u0061\u006c\u0020\u0063\u006f\u0073\u0074")
	}
	if _ecb[4].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_defc + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cggfd := int(_ecb[4].ValueNumber)
	if _cggfd < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _defc+" \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0070\u0065\u0072\u0069o\u0064\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u002d\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if _ecb[5].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_defc + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0064\u0065\u0070\u0072\u0065\u0063\u0069\u0061\u0074\u0069\u006f\u006e\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_fbeb := _ecb[5].ValueNumber
	if _fbeb < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _defc+"\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 d\u0065\u0070\u0072\u0065\u0063\u0069\u0061\u0074\u0069\u006f\u006e\u0020\u0072\u0061t\u0065\u0020t\u006f\u0020\u0062e\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030\u0020\u0061\u006e\u0064 \u006c\u0065ss\u0020\u0074\u0068a\u006e\u0020\u0030\u002e\u0035")
	}
	_ecgf := 0
	if _bbea == 7 && _ecb[6].Type != ResultTypeEmpty {
		if _ecb[6].Type != ResultTypeNumber {
			return nil, MakeErrorResult(_defc + "\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_ecgf = int(_ecb[6].ValueNumber)
		if !_efb(_ecgf) || _ecgf == 2 {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020"+_defc)
		}
	}
	return &amorArgs{_aacfb, _acbe, _fgfb, _fgab, _cggfd, _fbeb, _ecgf}, _aaa
}

// Update returns the same object as updating sheet references does not affect ConstArrayExpr.
func (_ccdaa ConstArrayExpr) Update(q *_egg.UpdateQuery) Expression { return _ccdaa }
func _abad(_fcae int) int {
	if _fcae < 1900 {
		if _fcae < 30 {
			_fcae += 2000
		} else {
			_fcae += 1900
		}
	}
	return _fcae
}

type criteriaParsed struct {
	_bfabd bool
	_cbaa  float64
	_ffcbg string
	_edbfb *criteriaRegex
}

const (
	_egee rmode = iota
	_bdfce
	_fdddb
)
const _efegf = 57355

func init() {
	RegisterFunction("\u0043\u0048\u004f\u004f\u0053\u0045", Choose)
	RegisterFunction("\u0043\u004f\u004c\u0055\u004d\u004e", Column)
	RegisterFunction("\u0043O\u004c\u0055\u004d\u004e\u0053", Columns)
	RegisterFunction("\u0049\u004e\u0044E\u0058", Index)
	RegisterFunctionComplex("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054", Indirect)
	RegisterFunctionComplex("\u004f\u0046\u0046\u0053\u0045\u0054", Offset)
	RegisterFunction("\u004d\u0041\u0054C\u0048", Match)
	RegisterFunction("\u0048L\u004f\u004f\u004b\u0055\u0050", HLookup)
	RegisterFunction("\u004c\u0041\u0052G\u0045", Large)
	RegisterFunction("\u004c\u004f\u004f\u004b\u0055\u0050", Lookup)
	RegisterFunction("\u0052\u004f\u0057", Row)
	RegisterFunction("\u0052\u004f\u0057\u0053", Rows)
	RegisterFunction("\u0053\u004d\u0041L\u004c", Small)
	RegisterFunction("\u0056L\u004f\u004f\u004b\u0055\u0050", VLookup)
	RegisterFunction("\u0054R\u0041\u004e\u0053\u0050\u004f\u0053E", Transpose)
}

// Dollarfr implements the Excel DOLLARFR function.
func Dollarfr(args []Result) Result {
	_cdda, _ageg, _cbgg := _dcggb(args, "\u0044\u004f\u004c\u004c\u0041\u0052\u0046\u0052")
	if _cbgg.Type == ResultTypeError {
		return _cbgg
	}
	if _cdda == 0 {
		return MakeNumberResult(0)
	}
	_fbc := _cdda < 0
	if _fbc {
		_cdda = -_cdda
	}
	_eacg := float64(int(_cdda))
	_dbaf := args[0].Value()
	_ccgf := _fa.Split(_dbaf, "\u002e")
	_faad := _ccgf[1]
	_daege, _eaebe := _ga.ParseFloat(_faad, 64)
	if _eaebe != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006fr \u0044\u004f\u004cL\u0041R\u0046\u0052")
	}
	_bdeg := float64(len(_faad))
	_daege /= _gg.Pow(10, _bdeg)
	_beb := _daege*_ageg/_gg.Pow(10, float64(int(_gg.Log10(_ageg)))+1) + _eacg
	if _fbc {
		_beb = -_beb
	}
	return MakeNumberResult(_beb)
}

// Reference returns an invalid reference for Error.
func (_aec Error) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Even is an implementation of the Excel EVEN() that rounds a number to the
// nearest even integer.
func Even(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0045\u0056\u0045\u004e(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_adgb := args[0].AsNumber()
	if _adgb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0056\u0045N\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ffbcf := _gg.Signbit(_adgb.ValueNumber)
	_bacd, _decge := _gg.Modf(_adgb.ValueNumber / 2)
	_dbafb := _bacd * 2
	if _decge != 0 {
		if !_ffbcf {
			_dbafb += 2
		} else {
			_dbafb -= 2
		}
	}
	return MakeNumberResult(_dbafb)
}
func _ggfc() {
	_bgfcf = _af.MustCompile("\u005e\u0028\u005b\u0030\u002d\u0039\u005d\u002b\u0029\u0024")
	_bcae = _af.MustCompile("\u005e=\u0028\u002e\u002a\u0029\u0024")
	_ecffc = _af.MustCompile("\u005e<\u0028\u002e\u002a\u0029\u0024")
	_ffeeg = _af.MustCompile("\u005e>\u0028\u002e\u002a\u0029\u0024")
	_fcbg = _af.MustCompile("\u005e\u003c\u003d\u0028\u002e\u002a\u0029\u0024")
	_adeg = _af.MustCompile("\u005e\u003e\u003d\u0028\u002e\u002a\u0029\u0024")
}

// NewPrefixVerticalRange constructs a new full columns range with prefix.
func NewPrefixVerticalRange(pfx Expression, v string) Expression {
	_addea := _fa.Split(v, "\u003a")
	if len(_addea) != 2 {
		return nil
	}
	return PrefixVerticalRange{pfx, _addea[0], _addea[1]}
}

// Year is an implementation of the Excel YEAR() function.
func Year(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_deg := ctx.GetEpoch()
	_aadb, _aagc := _eccgb(args[0].Value(), _deg)
	if _aagc != nil {
		return MakeErrorResult("\u0059\u0045AR\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s a\u0020si\u006e\u0067\u006c\u0065\u0020\u0064\u0061te\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeNumberResult(float64(_aadb.Year()))
}

// Base is an implementation of the Excel BASE function that returns a string
// form of an integer in a specified base and of a minimum length with padded
// zeros.
func Base(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0042\u0041\u0053\u0045\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0042\u0041S\u0045\u0028\u0029\u0020a\u006c\u006co\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006fs\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_gbec := args[0].AsNumber()
	if _gbec.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042A\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_gcgfe := args[1].AsNumber()
	if _gcgfe.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063o\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042\u0041\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_cdafb := int(_gcgfe.ValueNumber)
	if _cdafb < 0 || _cdafb > 36 {
		return MakeErrorResult("\u0072\u0061\u0064\u0069\u0078\u0020m\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065 \u0072\u0061\u006e\u0067\u0065\u0020\u005b0\u002c\u0033\u0036\u005d")
	}
	_agaae := 0
	if len(args) > 2 {
		_fegb := args[2].AsNumber()
		if _fegb.Type != ResultTypeNumber {
			return MakeErrorResult("\u0074\u0068\u0069\u0072\u0064 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042A\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_agaae = int(_fegb.ValueNumber)
	}
	_bgeb := _ga.FormatInt(int64(_gbec.ValueNumber), _cdafb)
	if len(_bgeb) < _agaae {
		_bgeb = _fa.Repeat("\u0030", _agaae-len(_bgeb)) + _bgeb
	}
	return MakeStringResult(_bgeb)
}

var _edbb = [...]int{45, 3, 44, 32, 18, 40, 72, 46, 47, 30, 31, 32, 39, 48, 28, 29, 30, 31, 32, 75, 39, 49, 32, 56, 50, 70, 23, 39, 76, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 77, 71, 69, 54, 43, 13, 19, 21, 55, 82, 11, 78, 9, 74, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 1, 20, 39, 10, 2, 8, 0, 80, 79, 0, 0, 0, 83, 0, 81, 73, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 0, 0, 39, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 26, 27, 39, 51, 52, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 23, 12, 0, 6, 7, 26, 27, 0, 42, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 5, 0, 12, 0, 6, 7, 26, 27, 0, 4, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 0, 12, 53, 6, 7, 26, 27, 0, 0, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 0, 12, 0, 6, 7}

func _faafa(_fdga int) string {
	if _fdga >= 1 && _fdga-1 < len(_ebade) {
		if _ebade[_fdga-1] != "" {
			return _ebade[_fdga-1]
		}
	}
	return _b.Sprintf("\u0074\u006f\u006b\u002d\u0025\u0076", _fdga)
}

// HasFormula returns FALSE for the invalid reference context.
func (_cgebd *ivr) HasFormula(cellRef string) bool { return false }

// Reference returns a string reference value to a range with prefix.
func (_ceff PrefixRangeExpr) Reference(ctx Context, ev Evaluator) Reference {
	_dbbd := _ceff._cbcc.Reference(ctx, ev)
	_fbce := _ceff._dgcf.Reference(ctx, ev)
	_fbde := _ceff._ccefe.Reference(ctx, ev)
	if _dbbd.Type == ReferenceTypeSheet && _fbce.Type == ReferenceTypeCell && _fbde.Type == ReferenceTypeCell {
		return MakeRangeReference(_dcef(_dbbd, _fbce, _fbde))
	}
	return ReferenceInvalid
}
func _aefda(_bbac Result) [][]Result {
	switch _bbac.Type {
	case ResultTypeArray:
		return _bbac.ValueArray
	case ResultTypeList:
		return [][]Result{_bbac.ValueList}
	default:
		return [][]Result{}
	}
}

// RegisterFunction registers a standard function.
func RegisterFunction(name string, fn Function) {
	_agccd.Lock()
	defer _agccd.Unlock()
	if _, _cbffe := _ecfcd[name]; _cbffe {
		_cg.Log("\u0064\u0075p\u006c\u0069\u0063\u0061t\u0065\u0020r\u0065\u0067\u0069\u0073\u0074\u0072\u0061\u0074i\u006f\u006e\u0020\u006f\u0066\u0020\u0066\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0025\u0073", name)
	}
	_ecfcd[name] = fn
}

// Nominal implements the Excel NOMINAL function.
func Nominal(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("NO\u004d\u0049N\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u006f\u006d\u0069\u006e\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072g\u0075m\u0065\u006et")
	}
	_cdgb := args[0].ValueNumber
	if _cdgb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u004e\u004fM\u0049\u004e\u0041\u004c\u0020r\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0065\u0066\u0066\u0065\u0063\u0074\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066\u0020\u0063\u006f\u006d\u0070\u006f\u0075\u006e\u0064\u0069\u006e\u0067\u0020\u0070\u0065\u0072i\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bgaa := float64(int(args[1].ValueNumber))
	if _bgaa < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006eum\u0062e\u0072\u0020\u006f\u0066\u0020\u0063\u006f\u006d\u0070\u006f\u0075\u006ed\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065 \u0031\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065")
	}
	return MakeNumberResult((_gg.Pow(_cdgb+1, 1/_bgaa) - 1) * _bgaa)
}

// Update makes a reference to point to one of the neighboring cells after removing a row/column with respect to the update type.
func (_dfd CellRef) Update(q *_egg.UpdateQuery) Expression {
	if q.UpdateCurrentSheet {
		_dfd._dgd = _ggb(_dfd._dgd, q)
	}
	return _dfd
}

var _bfaebg = [...]int{0, 0, 71, 70, 69, 4, 67, 66, 53, 51, 50, 49, 48, 47, 46, 45, 44, 2}

// BinaryExpr is a binary expression.
type BinaryExpr struct {
	_ag, _bd Expression
	_bc      BinOpType
}

func _dceg(_fbee, _ccaf, _adbf, _cgfbe, _befg, _edccf float64) float64 {
	var _gbgcg, _fdcg float64
	_cbcfc := 0.0
	_bfgc := _gg.Ceil(_befg)
	_bbcc := _fbee - _ccaf
	_eadc := false
	_cead := 0.0
	for _bggf := 1.0; _bggf <= _bfgc; _bggf++ {
		if !_eadc {
			_gbgcg = _cdcfb(_fbee, _ccaf, _adbf, _bggf, _edccf)
			_cead = _bbcc / (_adbf - _bggf + 1)
			if _cead > _gbgcg {
				_fdcg = _cead
				_eadc = true
			} else {
				_fdcg = _gbgcg
				_bbcc -= _gbgcg
			}
		} else {
			_fdcg = _cead
		}
		if _bggf == _bfgc {
			_fdcg *= _befg + 1 - _bfgc
		}
		_cbcfc += _fdcg
	}
	return _cbcfc
}

// NewNamedRangeRef constructs a new named range reference.
func NewNamedRangeRef(v string) Expression { return NamedRangeRef{v} }
func (_ecd *defEval) checkLastEvalIsRef(_cga Context, _acea Expression) {
	switch _acea.(type) {
	case FunctionCall:
		switch _acea.(FunctionCall)._eadcc {
		case "\u0049\u0053\u0052E\u0046":
			for _, _fga := range _acea.(FunctionCall)._aeef {
				switch _fga.(type) {
				case CellRef, Range, HorizontalRange, VerticalRange, NamedRangeRef, PrefixExpr, PrefixRangeExpr, PrefixHorizontalRange, PrefixVerticalRange:
					_aaf := _fga.Eval(_cga, _ecd)
					_ecd._ccf = !(_aaf.Type == ResultTypeError && _aaf.ValueString == "\u0023\u004e\u0041\u004d\u0045\u003f")
				default:
					_ecd._ccf = false
				}
			}
		}
	}
}
func _bdgdb(_edac []Result) Result {
	_fabf := _edac[0].ValueList
	_cfbc := len(_fabf)
	switch len(_edac) {
	case 1:
		_ffged := []Result{}
		for _, _dfee := range _fabf {
			_ffged = append(_ffged, MakeBoolResult(_dfee.ValueNumber != 0))
		}
		return MakeListResult(_ffged)
	case 2:
		_aegb := _edac[1]
		switch _aegb.Type {
		case ResultTypeNumber, ResultTypeString, ResultTypeEmpty:
			_dgdd := []Result{}
			for _, _cabce := range _fabf {
				var _dfbgb Result
				if _cabce.ValueNumber == 0 {
					_dfbgb = MakeBoolResult(false)
				} else {
					_dfbgb = _aegb
				}
				_dgdd = append(_dgdd, _dfbgb)
			}
			return MakeListResult(_dgdd)
		case ResultTypeList:
			_dabc := _cfff(_aegb, _cfbc)
			_efac := []Result{}
			for _aggc, _bdbgd := range _fabf {
				var _abdcf Result
				if _bdbgd.ValueNumber == 0 {
					_abdcf = MakeBoolResult(false)
				} else {
					_abdcf = _dabc[_aggc]
				}
				_efac = append(_efac, _abdcf)
			}
			return MakeListResult(_efac)
		case ResultTypeArray:
			_gdcb := _aedf(_aegb, len(_aegb.ValueArray), _cfbc)
			_edbf := [][]Result{}
			for _, _cfeca := range _gdcb {
				_gaedb := []Result{}
				for _ecga, _ebeb := range _fabf {
					var _dfac Result
					if _ebeb.ValueNumber == 0 {
						_dfac = MakeBoolResult(false)
					} else {
						_dfac = _cfeca[_ecga]
					}
					_gaedb = append(_gaedb, _dfac)
				}
				_edbf = append(_edbf, _gaedb)
			}
			return MakeArrayResult(_edbf)
		}
	case 3:
		_ffceb := _edac[1]
		_dbea := _edac[2]
		_gbfd := _geccb(_ffceb)
		_ffdg := _geccb(_dbea)
		if _gbfd && _ffdg {
			_dgbb := []Result{}
			for _, _gfce := range _fabf {
				var _faaff Result
				if _gfce.ValueNumber == 0 {
					_faaff = _dbea
				} else {
					_faaff = _ffceb
				}
				_dgbb = append(_dgbb, _faaff)
			}
			return MakeListResult(_dgbb)
		}
		if _ffceb.Type != ResultTypeArray && _dbea.Type != ResultTypeArray {
			_deegc := _cfff(_ffceb, _cfbc)
			_adec := _cfff(_dbea, _cfbc)
			_eede := []Result{}
			for _agagg, _geef := range _fabf {
				var _gfgfa Result
				if _geef.ValueNumber == 0 {
					_gfgfa = _adec[_agagg]
				} else {
					_gfgfa = _deegc[_agagg]
				}
				_eede = append(_eede, _gfgfa)
			}
			return MakeListResult(_eede)
		}
		_acf := len(_ffceb.ValueArray)
		if len(_dbea.ValueArray) > _acf {
			_acf = len(_dbea.ValueArray)
		}
		_ebffb := _aedf(_ffceb, _acf, _cfbc)
		_facbb := _aedf(_dbea, _acf, _cfbc)
		_agddf := [][]Result{}
		for _fcgb := 0; _fcgb < _acf; _fcgb++ {
			_fbcg := []Result{}
			for _caad, _agdg := range _fabf {
				var _gdca Result
				if _agdg.ValueNumber == 0 {
					_gdca = _facbb[_fcgb][_caad]
				} else {
					_gdca = _ebffb[_fcgb][_caad]
				}
				_fbcg = append(_fbcg, _gdca)
			}
			_agddf = append(_agddf, _fbcg)
		}
		return MakeArrayResult(_agddf)
	}
	return MakeErrorResult("")
}
func init() {
	_fddc()
	RegisterFunction("\u004e\u0041", NA)
	RegisterFunction("\u0049S\u0042\u004c\u0041\u004e\u004b", IsBlank)
	RegisterFunction("\u0049\u0053\u0045R\u0052", IsErr)
	RegisterFunction("\u0049S\u0045\u0052\u0052\u004f\u0052", IsError)
	RegisterFunction("\u0049\u0053\u0045\u0056\u0045\u004e", IsEven)
	RegisterFunctionComplex("\u005fx\u006cf\u006e\u002e\u0049\u0053\u0046\u004f\u0052\u004d\u0055\u004c\u0041", IsFormula)
	RegisterFunctionComplex("\u004fR\u0047\u002e\u004f\u0050E\u004e\u004f\u0046\u0046\u0049C\u0045.\u0049S\u004c\u0045\u0041\u0050\u0059\u0045\u0041R", IsLeapYear)
	RegisterFunctionComplex("\u0049S\u004c\u004f\u0047\u0049\u0043\u0041L", IsLogical)
	RegisterFunction("\u0049\u0053\u004e\u0041", IsNA)
	RegisterFunction("\u0049S\u004e\u004f\u004e\u0054\u0045\u0058T", IsNonText)
	RegisterFunction("\u0049\u0053\u004e\u0055\u004d\u0042\u0045\u0052", IsNumber)
	RegisterFunction("\u0049\u0053\u004fD\u0044", IsOdd)
	RegisterFunctionComplex("\u0049\u0053\u0052E\u0046", IsRef)
	RegisterFunction("\u0049\u0053\u0054\u0045\u0058\u0054", IsText)
	RegisterFunctionComplex("\u0043\u0045\u004c\u004c", Cell)
}
func _fdf(_gaa, _ccge float64, _dgaa, _fadb int) float64 {
	_ccac := _ddef(_gaa)
	_cbcf := _ddef(_ccge)
	_agcf := _efe(_ccac, _cbcf, _dgaa, _fadb)
	return _bdeb(_agcf, _ccac, _fadb)
}
func (_agacb *ivr) Cell(ref string, ev Evaluator) Result {
	return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065")
}

// String returns a string representation for Bool.
func (_fg Bool) String() string {
	if _fg._ccda {
		return "\u0054\u0052\u0055\u0045"
	} else {
		return "\u0046\u0041\u004cS\u0045"
	}
}

// PrefixExpr is an expression containing reference to another sheet like Sheet1!A1 (the value of the cell A1 from sheet 'Sheet1').
type PrefixExpr struct {
	_cafc Expression
	_adda Expression
}

// Index implements the Excel INDEX function.
func Index(args []Result) Result {
	_dcfc := len(args)
	if _dcfc < 2 || _dcfc > 3 {
		return MakeErrorResult("\u0049\u004e\u0044E\u0058\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u006e\u0065\u0020\u0074\u006f\u0020\u0074\u0068\u0072\u0065\u0065\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_acae := args[0]
	if _acae.Type != ResultTypeArray && _acae.Type != ResultTypeList {
		return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0066i\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_bgfc := args[1].AsNumber()
	if _bgfc.Type != ResultTypeNumber {
		return MakeErrorResult("I\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u006e\u0075\u006d\u0065\u0072\u0069\u0063 \u0072\u006f\u0077\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_gcdd := int(_bgfc.ValueNumber) - 1
	_ecgd := -1
	if _dcfc == 3 && args[2].Type != ResultTypeEmpty {
		_bgae := args[2].AsNumber()
		if _bgae.Type != ResultTypeNumber {
			return MakeErrorResult("I\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u006e\u0075\u006d\u0065\u0072\u0069\u0063 \u0063\u006f\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_ecgd = int(_bgae.ValueNumber) - 1
	}
	if _gcdd == -1 && _ecgd == -1 {
		return MakeErrorResult("\u0049\u004e\u0044EX\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072o\u0077 \u006fr\u0020\u0063\u006f\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	var _agfad []Result
	if _acae.Type == ResultTypeArray {
		_gfbf := _acae.ValueArray
		if _gcdd < -1 || _gcdd >= len(_gfbf) {
			return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0072o\u0077\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
		}
		if _gcdd == -1 {
			if _ecgd >= len(_gfbf[0]) {
				return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
			}
			_cefc := [][]Result{}
			for _, _face := range _gfbf {
				_cbfg := _face[_ecgd]
				if _cbfg.Type == ResultTypeEmpty {
					_cbfg = MakeNumberResult(0)
				}
				_cefc = append(_cefc, []Result{_cbfg})
			}
			return MakeArrayResult(_cefc)
		}
		_agfad = _gfbf[_gcdd]
	} else {
		_cacgd := _acae.ValueList
		if _gcdd < -1 || _gcdd >= 1 {
			return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0072o\u0077\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
		}
		if _gcdd == -1 {
			if _ecgd >= len(_cacgd) {
				return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
			}
			_cbee := _cacgd[_ecgd]
			if _cbee.Type == ResultTypeEmpty {
				_cbee = MakeNumberResult(0)
			}
			return _cbee
		}
		_agfad = _cacgd
	}
	if _ecgd < -1 || _ecgd > len(_agfad) {
		return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
	}
	if _ecgd == -1 {
		_ccgag := []Result{}
		for _, _aede := range _agfad {
			if _aede.Type == ResultTypeEmpty {
				_ccgag = append(_ccgag, MakeNumberResult(0))
			} else {
				_ccgag = append(_ccgag, _aede)
			}
		}
		return MakeArrayResult([][]Result{_ccgag})
	}
	_befa := _agfad[_ecgd]
	if _befa.Type == ResultTypeEmpty {
		return MakeNumberResult(0)
	}
	return _befa
}

const _cefca = 57370

// Month is an implementation of the Excel MONTH() function.
func Month(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("M\u004f\u004e\u0054\u0048\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006ee\u0020\u0061\u0072g\u0075m\u0065\u006e\u0074")
	}
	_fadg := args[0]
	switch _fadg.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(1)
	case ResultTypeNumber:
		_gecc := _ddef(_fadg.ValueNumber)
		return MakeNumberResult(float64(_gecc.Month()))
	case ResultTypeString:
		_aeda := _fa.ToLower(_fadg.ValueString)
		if !_ede(_aeda) {
			_, _, _, _, _ebd, _dad := _cgfb(_aeda)
			if _dad.Type == ResultTypeError {
				_dad.ErrorMessage = "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u004dON\u0054\u0048"
				return _dad
			}
			if _ebd {
				return MakeNumberResult(1)
			}
		}
		_, _ccba, _, _, _dbc := _dbbf(_aeda)
		if _dbc.Type == ResultTypeError {
			return _dbc
		}
		return MakeNumberResult(float64(_ccba))
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004d\u004fN\u0054\u0048")
	}
}

// IfNA is an implementation of the Excel IFNA() function. It takes two arguments.
func IfNA(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("I\u0046\u004e\u0041\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeError && args[0].ValueString == "\u0023\u004e\u002f\u0041" {
		return args[1]
	}
	return args[0]
}

// Floor is an implementation of the FlOOR function.
func Floor(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_beba := args[0].AsNumber()
	if _beba.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	var _acfc float64
	_dfaa := args[1].AsNumber()
	if _dfaa.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_acfc = _dfaa.ValueNumber
	if _acfc < 0 && _beba.ValueNumber >= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0046L\u004f\u004f\u0052")
	}
	_dbgcg := _beba.ValueNumber
	_dbgcg, _aefdd := _gg.Modf(_dbgcg / _acfc)
	if _aefdd != 0 {
		if _beba.ValueNumber < 0 && _aefdd < 0 {
			_dbgcg--
		}
	}
	return MakeNumberResult(_dbgcg * _acfc)
}
func _bcadb(_dced [][]Result) float64 {
	if len(_dced) == 2 {
		_feffe := _dced[0][0].AsNumber()
		_aefg := _dced[0][1].AsNumber()
		_acbg := _dced[1][0].AsNumber()
		_eccgbe := _dced[1][1].AsNumber()
		if _feffe.Type != ResultTypeNumber || _aefg.Type != ResultTypeNumber || _acbg.Type != ResultTypeNumber || _eccgbe.Type != ResultTypeNumber {
			return _gg.NaN()
		}
		return _feffe.ValueNumber*_eccgbe.ValueNumber - _acbg.ValueNumber*_aefg.ValueNumber
	}
	_dgaab := float64(0)
	_ffgee := float64(1)
	for _dggc := range _dced {
		_dgaab += _ffgee * _dced[0][_dggc].ValueNumber * _bcadb(_agaea(_dced, _dggc))
		_ffgee *= -1
	}
	return _dgaab
}
func (_dffge ResultType) String() string {
	if _dffge >= ResultType(len(_egdd)-1) {
		return _b.Sprintf("\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _dffge)
	}
	return _eggdg[_egdd[_dffge]:_egdd[_dffge+1]]
}

const _cdee = 1
const _cecg = 57347
const _fgfdf = 57357

// Decimal is an implementation of the Excel function DECIMAL() that parses a string
// in a given base and returns the numeric result.
func Decimal(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0044\u0045\u0043\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065s\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_aadbag := args[0].AsString()
	if _aadbag.Type != ResultTypeString {
		return MakeErrorResult("D\u0045\u0043\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u0072\u0073t \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_bfcf := args[1].AsNumber()
	if _bfcf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0045\u0043\u0049\u004dA\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dafg := _aadbag.ValueString
	if len(_dafg) > 2 && (_fa.HasPrefix(_dafg, "\u0030\u0078") || _fa.HasPrefix(_dafg, "\u0030\u0058")) {
		_dafg = _dafg[2:]
	}
	_cbeb, _edcb := _ga.ParseInt(_dafg, int(_bfcf.ValueNumber), 64)
	if _edcb != nil {
		return MakeErrorResult("\u0044\u0045C\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0069\u006e\u0020\u0063\u006f\u006e\u0076\u0065\u0072si\u006f\u006e")
	}
	return MakeNumberResult(float64(_cbeb))
}
func _fdba() evCache {
	_agab := evCache{}
	_agab._fe = make(map[string]Result)
	_agab._adc = &_eg.Mutex{}
	return _agab
}

// Ceiling is an implementation of the CEILING function which
// returns the ceiling of a number.
func Ceiling(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("C\u0045\u0049\u004c\u0049\u004e\u0047\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020a\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006ee \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u0028\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_cggdc := args[0].AsNumber()
	if _cggdc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066i\u0072\u0073t\u0020\u0061\u0072\u0067u\u006d\u0065\u006et\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049NG\u0028\u0029\u0020m\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006db\u0065\u0072")
	}
	_bba := float64(1)
	if _cggdc.ValueNumber < 0 {
		_bba = -1
	}
	if len(args) > 1 {
		_ccdb := args[1].AsNumber()
		if _ccdb.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073e\u0063\u006fn\u0064\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020t\u006f\u0020\u0043\u0045\u0049\u004cI\u004e\u0047\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062e\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_bba = _ccdb.ValueNumber
	}
	if _bba < 0 && _cggdc.ValueNumber > 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u006e\u0065\u0067\u0061\u0074\u0069v\u0065\u0020\u0073\u0069\u0067\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004cI\u004e\u0047\u0028\u0029\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if len(args) == 1 {
		return MakeNumberResult(_gg.Ceil(_cggdc.ValueNumber))
	}
	_gbaee := _cggdc.ValueNumber
	_gbaee, _cggc := _gg.Modf(_gbaee / _bba)
	if _cggc > 0 {
		_gbaee++
	}
	return MakeNumberResult(_gbaee * _bba)
}

// SheetPrefixExpr is a reference to a sheet like Sheet1! (reference to sheet 'Sheet1').
type SheetPrefixExpr struct{ _fdcd string }

// MaxIfs implements the MAXIFS function.
func MaxIfs(args []Result) Result {
	_egag := _ddaa(args, true, "\u004d\u0041\u0058\u0049\u0046\u0053")
	if _egag.Type != ResultTypeEmpty {
		return _egag
	}
	_accdb := _agge(args[1:])
	_fedcg := -_gg.MaxFloat64
	_efff := _aefda(args[0])
	for _, _dbfdd := range _accdb {
		_fcfca := _efff[_dbfdd._bgdb][_dbfdd._afcc].ValueNumber
		if _fedcg < _fcfca {
			_fedcg = _fcfca
		}
	}
	if _fedcg == -_gg.MaxFloat64 {
		_fedcg = 0
	}
	return MakeNumberResult(float64(_fedcg))
}

// ErrorType is a formula evaluation error type.
type ErrorType byte

// Now is an implementation of the Excel NOW() function.
func Now(args []Result) Result {
	if len(args) > 0 {
		return MakeErrorResult("\u004e\u004fW\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_geae := _ea.Now()
	_, _ggbc := _geae.Zone()
	_cba := _dcc + float64(_geae.Unix()+int64(_ggbc))/86400
	return MakeNumberResult(_cba)
}
func init() {
	RegisterFunction("\u0041\u004e\u0044", And)
	RegisterFunction("\u0046\u0041\u004cS\u0045", False)
	RegisterFunction("\u0049\u0046", If)
	RegisterFunction("\u0049F\u0045\u0052\u0052\u004f\u0052", IfError)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0049\u0046\u004e\u0041", IfNA)
	RegisterFunction("\u0049\u0046\u0053", Ifs)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0049\u0046S", Ifs)
	RegisterFunction("\u004e\u004f\u0054", Not)
	RegisterFunction("\u004f\u0052", Or)
	RegisterFunction("\u0054\u0052\u0055\u0045", True)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0058\u004fR", Xor)
}

// Fv implements the Excel FV function.
func Fv(args []Result) Result {
	_bagdg := len(args)
	if _bagdg < 3 || _bagdg > 5 {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u00205")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ebcg := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_cagg := args[1].ValueNumber
	if _cagg != float64(int(_cagg)) {
		return MakeErrorResultType(ErrorTypeNum, "\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0061\u0079\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bce := args[2].ValueNumber
	_cfdc := 0.0
	if _bagdg >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("F\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0070\u0072\u0065\u0073\u0065\u006et \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_cfdc = args[3].ValueNumber
	}
	_eccge := 0
	if _bagdg == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_eccge = int(args[4].ValueNumber)
		if _eccge != 0 {
			_eccge = 1
		}
	}
	return MakeNumberResult(_facb(_ebcg, _cagg, _bce, _cfdc, _eccge))
}

const _ggba = 57363

func (_cbbdf *noCache) SetCache(key string, value Result) {}

// Eval evaluates a horizontal range returning a list of results or an error.
func (_fggad HorizontalRange) Eval(ctx Context, ev Evaluator) Result {
	_cacee := _fggad.horizontalRangeReference()
	if _fbdd, _bagdb := ev.GetFromCache(_cacee); _bagdb {
		return _fbdd
	}
	_fdedb, _fcecg := _cfbd(ctx, _fggad._adac, _fggad._gfea)
	_aaaa := _bdgac(ctx, ev, _fdedb, _fcecg)
	ev.SetCache(_cacee, _aaaa)
	return _aaaa
}

// Mid is an implementation of the Excel MID function that returns a copy
// of the string with each word capitalized.
func Mid(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u004d\u0049\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	_efefd := args[0]
	if _efefd.Type == ResultTypeError {
		return _efefd
	}
	if _efefd.Type != ResultTypeString && _efefd.Type != ResultTypeNumber && _efefd.Type != ResultTypeEmpty {
		return MakeErrorResult("\u004d\u0049\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0065x\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_deeag := args[0].Value()
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049D\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u005fn\u0075\u006d\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_dbce := int(args[1].ValueNumber)
	if _dbce < 1 {
		return MakeErrorResult("M\u0049\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u005fn\u0075\u006d\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006dor\u0065\u0020\u0074h\u0061n\u0020\u0030")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049D\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u005f\u0063\u0068a\u0072\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_fbaege := int(args[2].ValueNumber)
	if _fbaege < 0 {
		return MakeErrorResult("\u004d\u0049\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u005f\u0063\u0068a\u0072\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_acdcd := len(_deeag)
	if _dbce > _acdcd {
		return MakeStringResult("")
	}
	_dbce--
	_bbae := _dbce + _fbaege
	if _bbae > _acdcd+1 {
		return MakeStringResult(_deeag[_dbce:])
	} else {
		return MakeStringResult(_deeag[_dbce:_bbae])
	}
}

// Len is an implementation of the Excel LEN function that returns length of a string
func Len(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004c\u0045N\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_afacd := args[0].AsString()
	if _afacd.Type != ResultTypeString {
		return MakeErrorResult("\u004c\u0045N\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(float64(len(_afacd.ValueString)))
}

// Pduration implements the Excel PDURATION function.
func Pduration(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0050\u0044\u0055RA\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u0074h\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050D\u0055\u0052A\u0054\u0049\u004fN\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_efaf := args[0].ValueNumber
	if _efaf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020p\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u0020\u0076\u0061l\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aaab := args[1].ValueNumber
	if _aaab <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "P\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 c\u0075\u0072\u0072\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074o \u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0044\u0055\u0052\u0041\u0054I\u004f\u004e\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0070\u0065\u0063\u0069\u0066i\u0065\u0064\u0020\u0076\u0061lu\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dab := args[2].ValueNumber
	if _dab <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0044\u0055\u0052\u0041\u0054I\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070o\u0073i\u0074\u0069\u0076\u0065")
	}
	return MakeNumberResult((_gg.Log10(_dab) - _gg.Log10(_aaab)) / _gg.Log10(1+_efaf))
}

// MakeNumberResult constructs a number result.
func MakeNumberResult(v float64) Result {
	if v == _gg.Copysign(0, -1) {
		v = 0
	}
	return Result{Type: ResultTypeNumber, ValueNumber: v}
}

const _dcdbb int = 0

// Atan2 implements the Excel ATAN2 function.  It accepts two numeric arguments,
// and the arguments are (x,y), reversed from normal to match Excel's behaviour.
func Atan2(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0041\u0054\u0041\u004e2\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077o\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	_abaec := args[0].AsNumber()
	_fgef := args[1].AsNumber()
	if _abaec.Type == ResultTypeNumber && _fgef.Type == ResultTypeNumber {
		_babda := _gg.Atan2(_fgef.ValueNumber, _abaec.ValueNumber)
		if _babda != _babda {
			return MakeErrorResult("\u0041T\u0041N\u0032\u0020\u0072\u0065\u0074u\u0072\u006ee\u0064\u0020\u004e\u0061\u004e")
		}
		return MakeNumberResult(_babda)
	}
	for _, _cfgee := range []ResultType{_abaec.Type, _fgef.Type} {
		switch _cfgee {
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult("\u0041\u0054\u0041\u004e\u0032\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		case ResultTypeError:
			return _abaec
		default:
			return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0068an\u0064\u006c\u0065\u0064\u0020\u0041\u0054\u0041\u004e2\u0028)\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cfgee))
		}
	}
	return MakeErrorResult("u\u006e\u0068\u0061\u006e\u0064\u006ce\u0064\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0066o\u0072\u0020\u0041T\u0041N\u0032\u0028\u0029")
}

// Context is a formula execution context.  Formula evaluation uses the context
// to retreive information from sheets.
type Context interface {

	// Cell returns the result of evaluating a cell.
	Cell(_gd string, _cbg Evaluator) Result

	// Sheet returns an evaluation context for a given sheet name.  This is used
	// when evaluating cells that pull data from other sheets (e.g. ='Sheet 2'!A1).
	Sheet(_ebf string) Context

	// GetEpoch returns the time epoch of the context's Workbook.
	GetEpoch() _ea.Time

	// GetFilename returns the full filename of the context's Workbook.
	GetFilename() string

	// GetWidth returns a worksheet's column width.
	GetWidth(_aag int) float64

	// GetFormat returns a cell's format.
	GetFormat(_ace string) string

	// GetLabelPrefix returns cell's label prefix dependent on cell horizontal alignment.
	GetLabelPrefix(_ec string) string

	// GetFormat returns if cell is protected.
	GetLocked(_gac string) bool

	// HasFormula returns if cell contains formula.
	HasFormula(_efg string) bool

	// IsBool returns if cell contains boolean value.
	IsBool(_cdc string) bool

	// IsDBCS returns if workbook default language is among DBCS.
	IsDBCS() bool

	// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
	LastColumn(_aba, _cde int) string

	// LastRow returns the name of last row which contains data in range of context sheet's given columns.
	LastRow(_dbf string) int

	// SetLocked returns sets cell's protected attribute.
	SetLocked(_cf string, _gfg bool)

	// NamedRange returns a named range.
	NamedRange(_ddc string) Reference

	// SetOffset is used so that the Context can evaluate cell references
	// differently when they are not absolute (e.g. not like '$A$5').  See the
	// shared formula support in Cell for usage.
	SetOffset(_fbb, _bdb uint32)
}

// Irr implements the Excel IRR function.
func Irr(args []Result) Result {
	_fecb := len(args)
	if _fecb > 2 {
		return MakeErrorResult("\u0049\u0052\u0052\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u006f\u0072\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeList && args[0].Type != ResultTypeArray {
		return MakeErrorResult("\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020v\u0061\u006c\u0075\u0065\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0061\u0072\u0072\u0061\u0079 \u0074\u0079\u0070\u0065")
	}
	_eggc := _aefda(args[0])
	_ggda := []float64{}
	for _, _bfga := range _eggc {
		for _, _feg := range _bfga {
			if _feg.Type == ResultTypeNumber && !_feg.IsBoolean {
				_ggda = append(_ggda, _feg.ValueNumber)
			}
		}
	}
	_dbfg := len(_ggda)
	if len(_ggda) < 2 {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	_bfcc := 0.1
	if _fecb == 2 && args[1].Type != ResultTypeEmpty {
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("I\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_bfcc = args[1].ValueNumber
		if _bfcc <= -1 {
			return MakeErrorResult("\u0049\u0052R\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068a\u006e\u0020\u002d\u0031")
		}
	}
	_abag := []float64{}
	for _cffcd := 0; _cffcd < _dbfg; _cffcd++ {
		if _cffcd == 0 {
			_abag = append(_abag, 0)
		} else {
			_abag = append(_abag, _abag[_cffcd-1]+365)
		}
	}
	return _afc(_ggda, _abag, _bfcc)
}

// CeilingPrecise is an implementation of the CEILING.PRECISE function which
// returns the ceiling of a number.
func CeilingPrecise(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002eP\u0052\u0045\u0043IS\u0045\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0043\u0045I\u004c\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_ecgef := args[0].AsNumber()
	if _ecgef.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069r\u0073\u0074\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_dfde := float64(1)
	if _ecgef.ValueNumber < 0 {
		_dfde = -1
	}
	if len(args) > 1 {
		_agdc := args[1].AsNumber()
		if _agdc.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043E\u0049L\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_dfde = _gg.Abs(_agdc.ValueNumber)
	}
	if len(args) == 1 {
		return MakeNumberResult(_gg.Ceil(_ecgef.ValueNumber))
	}
	_bfac := _ecgef.ValueNumber
	_bfac, _egcfg := _gg.Modf(_bfac / _dfde)
	if _egcfg != 0 {
		if _ecgef.ValueNumber > 0 {
			_bfac++
		}
	}
	return MakeNumberResult(_bfac * _dfde)
}
func (_aecd tokenType) String() string { return _faafa(int(_aecd)) }

// TextJoin is an implementation of the Excel TEXTJOIN function.
func TextJoin(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u004aO\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074h\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0054\u0045\u0058T\u004a\u004f\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0065\u006c\u0069\u006d\u0069\u0074\u0065\u0072\u0020\u0074\u006f\u0020\u0062\u0065 \u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_abaed := args[0].ValueString
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u004a\u004f\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065c\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0072 \u0062\u006f\u006f\u006c\u0065a\u006e")
	}
	_efeff := args[1].ValueNumber != 0
	_ceebb := _edea(args[2:], []string{}, _efeff)
	return MakeStringResult(_fa.Join(_ceebb, _abaed))
}

const _eff = "\u0042\u0069\u006e\u004f\u0070\u0054y\u0070\u0065\u0055\u006e\u006bn\u006fw\u006e\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0050\u006c\u0075\u0073\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u004d\u0069\u006e\u0075\u0073\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065M\u0075lt\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0044\u0069\u0076\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0045\u0078\u0070\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u004c\u0054\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065G\u0054B\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0045\u0051\u0042\u0069nO\u0070\u0054\u0079\u0070\u0065\u004c\u0045\u0051\u0042i\u006eO\u0070\u0054\u0079\u0070\u0065\u0047\u0045\u0051\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065N\u0045\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0043\u006f\u006e\u0063\u0061\u0074"

func init() {
	_gbca = _aca.New(_aca.NewSource(_ea.Now().UnixNano()))
	RegisterFunction("\u0041\u0042\u0053", _ecacb("\u0041\u0053\u0049\u004e", _gg.Abs))
	RegisterFunction("\u0041\u0043\u004f\u0053", _ecacb("\u0041\u0053\u0049\u004e", _gg.Acos))
	RegisterFunction("\u0041\u0043\u004fS\u0048", _ecacb("\u0041\u0053\u0049\u004e", _gg.Acosh))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0041\u0043\u004f\u0054", _ecacb("\u0041\u0043\u004f\u0054", func(_dgbeb float64) float64 { return _gg.Pi/2 - _gg.Atan(_dgbeb) }))
	RegisterFunction("_\u0078\u006c\u0066\u006e\u002e\u0041\u0043\u004f\u0054\u0048", _ecacb("\u0041\u0043\u004fT\u0048", func(_geeb float64) float64 { return _gg.Atanh(1 / _geeb) }))
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u0041\u0052\u0041\u0042\u0049\u0043", Arabic)
	RegisterFunction("\u0041\u0053\u0049\u004e", _ecacb("\u0041\u0053\u0049\u004e", _gg.Asin))
	RegisterFunction("\u0041\u0053\u0049N\u0048", _ecacb("\u0041\u0053\u0049N\u0048", _gg.Asinh))
	RegisterFunction("\u0041\u0054\u0041\u004e", _ecacb("\u0041\u0054\u0041\u004e", _gg.Atan))
	RegisterFunction("\u0041\u0054\u0041N\u0048", _ecacb("\u0041\u0054\u0041N\u0048", _gg.Atanh))
	RegisterFunction("\u0041\u0054\u0041N\u0032", Atan2)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0042\u0041\u0053\u0045", Base)
	RegisterFunction("\u0043E\u0049\u004c\u0049\u004e\u0047", Ceiling)
	RegisterFunction("\u005fx\u006cf\u006e\u002e\u0043\u0045\u0049L\u0049\u004eG\u002e\u004d\u0041\u0054\u0048", CeilingMath)
	RegisterFunction("_\u0078\u006c\u0066\u006e.C\u0045I\u004c\u0049\u004e\u0047\u002eP\u0052\u0045\u0043\u0049\u0053\u0045", CeilingPrecise)
	RegisterFunction("\u0043\u004f\u004d\u0042\u0049\u004e", Combin)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u004f\u004d\u0042\u0049\u004e\u0041", Combina)
	RegisterFunction("\u0043\u004f\u0053", _ecacb("\u0043\u004f\u0053", _gg.Cos))
	RegisterFunction("\u0043\u004f\u0053\u0048", _ecacb("\u0043\u004f\u0053\u0048", _gg.Cosh))
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0043\u004fT", _fbge("\u0043\u004f\u0054", _gg.Tan))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u004f\u0054\u0048", _fbge("\u0043\u004f\u0054\u0048", _gg.Tanh))
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0043\u0053C", _fbge("\u0043\u0053\u0043", _gg.Sin))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u0053\u0043\u0048", _fbge("\u0043\u0053\u0043", _gg.Sinh))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0044\u0045\u0043\u0049\u004d\u0041\u004c", Decimal)
	RegisterFunction("\u0044E\u0047\u0052\u0045\u0045\u0053", Degrees)
	RegisterFunction("\u0045\u0056\u0045\u004e", Even)
	RegisterFunction("\u0045\u0058\u0050", _ecacb("\u0045\u0058\u0050", _gg.Exp))
	RegisterFunction("\u0046\u0041\u0043\u0054", Fact)
	RegisterFunction("\u0046\u0041\u0043\u0054\u0044\u004f\u0055\u0042\u004c\u0045", FactDouble)
	RegisterFunction("\u0046\u004c\u004fO\u0052", Floor)
	RegisterFunction("\u005f\u0078l\u0066\u006e\u002eF\u004c\u004f\u004f\u0052\u002e\u004d\u0041\u0054\u0048", FloorMath)
	RegisterFunction("\u005f\u0078\u006c\u0066n.\u0046\u004c\u004f\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045", FloorPrecise)
	RegisterFunction("\u0047\u0043\u0044", GCD)
	RegisterFunction("\u0049\u004e\u0054", Int)
	RegisterFunction("I\u0053\u004f\u002e\u0043\u0045\u0049\u004c\u0049\u004e\u0047", CeilingPrecise)
	RegisterFunction("\u004c\u0043\u004d", LCM)
	RegisterFunction("\u004c\u004e", _ecacb("\u004c\u004e", _gg.Log))
	RegisterFunction("\u004c\u004f\u0047", Log)
	RegisterFunction("\u004c\u004f\u00471\u0030", _ecacb("\u004c\u004f\u00471\u0030", _gg.Log10))
	RegisterFunction("\u004dD\u0045\u0054\u0045\u0052\u004d", MDeterm)
	RegisterFunction("\u004d\u004f\u0044", Mod)
	RegisterFunction("\u004d\u0052\u004f\u0055\u004e\u0044", Mround)
	RegisterFunction("M\u0055\u004c\u0054\u0049\u004e\u004f\u004d\u0049\u0041\u004c", Multinomial)
	RegisterFunction("_\u0078\u006c\u0066\u006e\u002e\u004d\u0055\u004e\u0049\u0054", Munit)
	RegisterFunction("\u004f\u0044\u0044", Odd)
	RegisterFunction("\u0050\u0049", Pi)
	RegisterFunction("\u0050\u004f\u0057E\u0052", Power)
	RegisterFunction("\u0050R\u004f\u0044\u0055\u0043\u0054", Product)
	RegisterFunction("\u0051\u0055\u004f\u0054\u0049\u0045\u004e\u0054", Quotient)
	RegisterFunction("\u0052A\u0044\u0049\u0041\u004e\u0053", Radians)
	RegisterFunction("\u0052\u0041\u004e\u0044", Rand)
	RegisterFunction("R\u0041\u004e\u0044\u0042\u0045\u0054\u0057\u0045\u0045\u004e", RandBetween)
	RegisterFunction("\u0052\u004f\u004dA\u004e", Roman)
	RegisterFunction("\u0052\u004f\u0055N\u0044", Round)
	RegisterFunction("\u0052O\u0055\u004e\u0044\u0044\u004f\u0057N", RoundDown)
	RegisterFunction("\u0052O\u0055\u004e\u0044\u0055\u0050", RoundUp)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0053\u0045C", _fbge("\u0053\u0045\u0043", _gg.Cos))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0053\u0045\u0043\u0048", _fbge("\u0053\u0045\u0043\u0048", _gg.Cosh))
	RegisterFunction("\u0053E\u0052\u0049\u0045\u0053\u0053\u0055M", SeriesSum)
	RegisterFunction("\u0053\u0049\u0047\u004e", Sign)
	RegisterFunction("\u0053\u0049\u004e", _ecacb("\u0053\u0049\u004e", _gg.Sin))
	RegisterFunction("\u0053\u0049\u004e\u0048", _ecacb("\u0053\u0049\u004e\u0048", _gg.Sinh))
	RegisterFunction("\u0053\u0051\u0052\u0054", _ecacb("\u0053\u0051\u0052\u0054", _gg.Sqrt))
	RegisterFunction("\u0053\u0051\u0052\u0054\u0050\u0049", _ecacb("\u0053\u0051\u0052\u0054\u0050\u0049", func(_egbc float64) float64 { return _gg.Sqrt(_egbc * _gg.Pi) }))
	RegisterFunction("\u0053\u0055\u004d", Sum)
	RegisterFunction("\u0053\u0055\u004dI\u0046", SumIf)
	RegisterFunction("\u0053\u0055\u004d\u0049\u0046\u0053", SumIfs)
	RegisterFunction("\u0053\u0055\u004d\u0050\u0052\u004f\u0044\u0055\u0043\u0054", SumProduct)
	RegisterFunction("\u0053\u0055\u004dS\u0051", SumSquares)
	RegisterFunction("\u0054\u0041\u004e", _ecacb("\u0054\u0041\u004e", _gg.Tan))
	RegisterFunction("\u0054\u0041\u004e\u0048", _ecacb("\u0054\u0041\u004e\u0048", _gg.Tanh))
	RegisterFunction("\u0054\u0052\u0055N\u0043", Trunc)
}

// NewNumber constructs a new number expression.
func NewNumber(v string) Expression {
	_bbfc, _aaffb := _ga.ParseFloat(v, 64)
	if _aaffb != nil {
		_cg.Log("e\u0072\u0072\u006f\u0072\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020f\u006f\u0072\u006d\u0075\u006c\u0061\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0025\u0073\u003a\u0020%\u0073", v, _aaffb)
	}
	return Number{_bbfc}
}

var _ecf int64 = _ddcf(1900, _ea.January, 1)

// SeriesSum implements the Excel SERIESSUM function.
func SeriesSum(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("\u0053\u0045\u0052\u0049\u0045\u0053\u0053\u0055\u004d\u0028\u0029\u0020\u0072\u0065\u0071u\u0069r\u0065\u0073\u0020\u0034\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dafa := args[0].AsNumber()
	_ggac := args[1].AsNumber()
	_fabd := args[2].AsNumber()
	_egggg := args[3].ListValues()
	if _dafa.Type != ResultTypeNumber || _ggac.Type != ResultTypeNumber || _fabd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0045\u0052\u0049\u0045\u0053S\u0055\u004d\u0028)\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073t\u0020\u0074\u0068\u0072\u0065e \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063")
	}
	_cdfg := float64(0)
	for _fbcf, _fdbb := range _egggg {
		_cdfg += _fdbb.ValueNumber * _gg.Pow(_dafa.ValueNumber, _ggac.ValueNumber+float64(_fbcf)*_fabd.ValueNumber)
	}
	return MakeNumberResult(_cdfg)
}
func _cgbd() yyParser { return &yyParserImpl{} }

// Update returns the same object as updating sheet references does not affect EmptyExpr.
func (_gab EmptyExpr) Update(q *_egg.UpdateQuery) Expression { return _gab }

const _ddda = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0044\u0041\u0054\u0045\u0056\u0041\u004c\u0055\u0045"
const _gdbf = 57373

// IsDBCS returns false for the invalid reference context.
func (_bfgfd *ivr) IsDBCS() bool { return false }
func _gdb(_gabcc Result, _bbccb, _bdede string) (float64, Result) {
	switch _gabcc.Type {
	case ResultTypeEmpty:
		return 0, _aaa
	case ResultTypeNumber:
		return _gabcc.ValueNumber, _aaa
	case ResultTypeString:
		_fabgg, _cfddg := _ga.ParseFloat(_gabcc.ValueString, 64)
		if _cfddg != nil {
			return 0, MakeErrorResult(_bdede + "\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020" + _bbccb)
		}
		return _fabgg, _aaa
	default:
		return 0, MakeErrorResult(_bbccb + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _bdede + "\u0020t\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0065\u006d\u0070\u0074\u0079")
	}
}

// CellRef is a reference to a single cell
type CellRef struct{ _dgd string }

const _ggff = 57354

var _ecbfc = [...]int{-1, 1, 1, -1, -2, 0}

// MaxA is an implementation of the Excel MAXA() function.
func MaxA(args []Result) Result { return _add(args, true) }

// IfError is an implementation of the Excel IFERROR() function. It takes two arguments.
func IfError(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0049\u0046\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeError {
		if args[0].Type == ResultTypeEmpty {
			return MakeNumberResult(0)
		}
		return args[0]
	}
	return args[1]
}

const _fecgd = 57364

// DateDif is an implementation of the Excel DATEDIF() function.
func DateDif(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeString {
		return MakeErrorResult("\u0044\u0041\u0054\u0045\u0044I\u0046\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077o\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u006e\u0064\u0020\u006f\u006e\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_de := args[0].ValueNumber
	_fcg := args[1].ValueNumber
	if _fcg < _de {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0068\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0064a\u0074\u0065\u0020\u0069s\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u0065\u006e\u0064\u0020\u0064\u0061\u0074\u0065")
	}
	if _fcg == _de {
		return MakeNumberResult(0)
	}
	_fae := _fa.ToLower(args[2].ValueString)
	if _fae == "\u0064" {
		return MakeNumberResult(_fcg - _de)
	}
	_fbf := _ddef(_de)
	_bfec := _ddef(_fcg)
	_dccg, _fed, _dbb := _fbf.Date()
	_ddbb, _da, _dbde := _bfec.Date()
	_bdf := int(_fed)
	_dee := int(_da)
	var _bbda float64
	switch _fae {
	case "\u0079":
		_bbda = float64(_ddbb - _dccg)
		if _dee < _bdf || (_dee == _bdf && _dbde < _dbb) {
			_bbda--
		}
	case "\u006d":
		_gbd := _ddbb - _dccg
		_ebef := _dee - _bdf
		if _dbde < _dbb {
			_ebef--
		}
		if _ebef < 0 {
			_gbd--
			_ebef += 12
		}
		_bbda = float64(_gbd*12 + _ebef)
	case "\u006d\u0064":
		_eaf := _dee
		if _dbde < _dbb {
			_eaf--
		}
		_bbda = float64(int(_fcg - _fag(_ddbb, _eaf, _dbb)))
	case "\u0079\u006d":
		_bbda = float64(_dee - _bdf)
		if _dbde < _dbb {
			_bbda--
		}
		if _bbda < 0 {
			_bbda += 12
		}
	case "\u0079\u0064":
		_gea := _ddbb
		if _dee < _bdf || (_dee == _bdf && _dbde < _dbb) {
			_gea--
		}
		_bbda = float64(int(_fcg - _fag(_gea, _bdf, _dbb)))
	default:
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0069\u006e\u0074e\u0072\u0076\u0061\u006c\u0020\u0076\u0061\u006c\u0075\u0065")
	}
	return MakeNumberResult(_bbda)
}

// FunctionCall is a function call expression.
type FunctionCall struct {
	_eadcc string
	_aeef  []Expression
}

func _bdd(_adf BinOpType, _eae, _gf [][]Result) Result {
	_gcg := [][]Result{}
	for _db := range _eae {
		_edd := _aa(_adf, _eae[_db], _gf[_db])
		if _edd.Type == ResultTypeError {
			return _edd
		}
		_gcg = append(_gcg, _edd.ValueList)
	}
	return MakeArrayResult(_gcg)
}
func _gcfe(_bfcca []Result, _bfaa countMode) float64 {
	_beee := 0.0
	for _, _bdab := range _bfcca {
		switch _bdab.Type {
		case ResultTypeNumber:
			if _bfaa == _fffb || (_bfaa == _baead && !_bdab.IsBoolean) {
				_beee++
			}
		case ResultTypeList, ResultTypeArray:
			_beee += _gcfe(_bdab.ListValues(), _bfaa)
		case ResultTypeString:
			if _bfaa == _fffb {
				_beee++
			}
		case ResultTypeEmpty:
			if _bfaa == _geaa {
				_beee++
			}
		}
	}
	return _beee
}
func _cgc(_aab BinOpType, _dg []Result, _aga Result) Result {
	_ef := []Result{}
	switch _aga.Type {
	case ResultTypeNumber:
		_cgb := _aga.ValueNumber
		for _agg := range _dg {
			_aed := _dg[_agg].AsNumber()
			if _aed.Type != ResultTypeNumber {
				return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
			}
			switch _aab {
			case BinOpTypePlus:
				_ef = append(_ef, MakeNumberResult(_aed.ValueNumber+_cgb))
			case BinOpTypeMinus:
				_ef = append(_ef, MakeNumberResult(_aed.ValueNumber-_cgb))
			case BinOpTypeMult:
				_ef = append(_ef, MakeNumberResult(_aed.ValueNumber*_cgb))
			case BinOpTypeDiv:
				if _cgb == 0 {
					return MakeErrorResultType(ErrorTypeDivideByZero, "")
				}
				_ef = append(_ef, MakeNumberResult(_aed.ValueNumber/_cgb))
			case BinOpTypeExp:
				_ef = append(_ef, MakeNumberResult(_gg.Pow(_aed.ValueNumber, _cgb)))
			case BinOpTypeLT:
				_ef = append(_ef, MakeBoolResult(_aed.ValueNumber < _cgb))
			case BinOpTypeGT:
				_ef = append(_ef, MakeBoolResult(_aed.ValueNumber > _cgb))
			case BinOpTypeEQ:
				_ef = append(_ef, MakeBoolResult(_aed.ValueNumber == _cgb))
			case BinOpTypeLEQ:
				_ef = append(_ef, MakeBoolResult(_aed.ValueNumber <= _cgb))
			case BinOpTypeGEQ:
				_ef = append(_ef, MakeBoolResult(_aed.ValueNumber >= _cgb))
			case BinOpTypeNE:
				_ef = append(_ef, MakeBoolResult(_aed.ValueNumber != _cgb))
			default:
				return MakeErrorResult(_b.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _aab))
			}
		}
	case ResultTypeString:
		_fb := _aga.ValueString
		for _edg := range _dg {
			_ba := _dg[_edg].AsString()
			if _ba.Type != ResultTypeString {
				return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
			}
			switch _aab {
			case BinOpTypeLT:
				_ef = append(_ef, MakeBoolResult(_ba.ValueString < _fb))
			case BinOpTypeGT:
				_ef = append(_ef, MakeBoolResult(_ba.ValueString > _fb))
			case BinOpTypeEQ:
				_ef = append(_ef, MakeBoolResult(_ba.ValueString == _fb))
			case BinOpTypeLEQ:
				_ef = append(_ef, MakeBoolResult(_ba.ValueString <= _fb))
			case BinOpTypeGEQ:
				_ef = append(_ef, MakeBoolResult(_ba.ValueString >= _fb))
			case BinOpTypeNE:
				_ef = append(_ef, MakeBoolResult(_ba.ValueString != _fb))
			default:
				return MakeErrorResult(_b.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _aab))
			}
		}
	default:
		return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069c\u0020\u0061\u006e\u0064\u0020\u006e\u006f\u006e-\u0073t\u0072\u0069\u006e\u0067\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069\u006e\u0061r\u0079\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u0069\u006f\u006e")
	}
	return MakeListResult(_ef)
}

// CountIf implements the COUNTIF function.
func CountIf(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0043\u004f\u0055N\u0054\u0049\u0046\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0073")
	}
	_gaae := args[0]
	if _gaae.Type != ResultTypeArray && _gaae.Type != ResultTypeList {
		return MakeErrorResult("\u0043O\u0055\u004eT\u0049\u0046\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_fgbdc := _adebe(args[1])
	_fedd := 0
	for _, _dffe := range _aefda(_gaae) {
		for _, _fdedd := range _dffe {
			if _aefe(_fdedd, _fgbdc) {
				_fedd++
			}
		}
	}
	return MakeNumberResult(float64(_fedd))
}

const (
	_gabde cmpResult = 0
	_fceaf cmpResult = -1
	_cdgg  cmpResult = 1
	_abef  cmpResult = 2
)

// HLookup implements the HLOOKUP function that returns a matching value from a
// row in an array.
func HLookup(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004bU\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if len(args) > 4 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0074\u0020m\u006f\u0073\u0074\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_ccgae := args[0]
	_eabf := args[1]
	if _eabf.Type != ResultTypeArray {
		return MakeErrorResult("\u0048\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_fega := args[2].AsNumber()
	if _fega.Type != ResultTypeNumber {
		return MakeErrorResult("\u0048\u004cO\u004f\u004b\u0055\u0050 \u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0072\u006f\u0077\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ggcc := false
	if len(args) == 4 {
		_egccg := args[3].AsNumber()
		if _egccg.Type != ResultTypeNumber {
			return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		if _egccg.ValueNumber == 0 {
			_ggcc = true
		}
	}
	_bbccc := -1
	_cabcf := false
	if len(_eabf.ValueArray) == 0 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u006f\u006e\u002d\u0065\u006d\u0070\u0074\u0079\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_abbc := _eabf.ValueArray[0]
_cadd:
	for _gafae, _acag := range _abbc {
		switch _fbae(_acag, _ccgae, false, _ggcc) {
		case _fceaf:
			_bbccc = _gafae
		case _gabde:
			_bbccc = _gafae
			_cabcf = true
			break _cadd
		}
	}
	if _bbccc == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u0048\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_agfe := int(_fega.ValueNumber) - 1
	if _agfe < 0 || _agfe > len(_eabf.ValueArray) {
		return MakeErrorResult("\u0048L\u004f\u004f\u004b\u0055P\u0020\u0068\u0061\u0064\u0020i\u006ev\u0061l\u0069\u0064\u0020\u0069\u006e\u0064\u0065x")
	}
	_abbc = _eabf.ValueArray[_agfe]
	if _bbccc < 0 || _bbccc >= len(_abbc) {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0063\u006f\u006c\u0075\u006d\u006e\u0020\u0069\u006e\u0064\u0065\u0078")
	}
	if _cabcf || !_ggcc {
		return _abbc[_bbccc]
	}
	return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
}

var _faacg = [...]int{0, 7, 3, 3, 3, 8, 8, 8, 8, 1, 1, 1, 2, 2, 2, 2, 2, 14, 15, 15, 17, 17, 4, 4, 4, 13, 5, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 9, 9, 16, 16, 11, 10, 10}

const _gfccf = 57374

// Roman is an implementation of the Excel ROMAN function that convers numbers
// to roman numerals in one of 5 formats.
func Roman(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_fafgg := args[0].AsNumber()
	if _fafgg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_abbga := 0
	if len(args) > 1 {
		_efbb := args[1]
		if _efbb.Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063")
		}
		_abbga = int(_efbb.ValueNumber)
		if _abbga < 0 {
			_abbga = 0
		} else if _abbga > 4 {
			_abbga = 4
		}
	}
	_dcgag := _abeg
	switch _abbga {
	case 1:
		_dcgag = _fgbbc
	case 2:
		_dcgag = _edagf
	case 3:
		_dcgag = _agdgd
	case 4:
		_dcgag = _ecceg
	}
	_gafba := _gg.Trunc(_fafgg.ValueNumber)
	_becf := _bg.Buffer{}
	for _, _acbeb := range _dcgag {
		for _gafba >= _acbeb._dgfgg {
			_becf.WriteString(_acbeb._faafcg)
			_gafba -= _acbeb._dgfgg
		}
	}
	return MakeStringResult(_becf.String())
}

// Right implements the Excel RIGHT(string,[n]) function which returns the
// rightmost n characters.
func Right(args []Result) Result {
	_dgbba := 1
	switch len(args) {
	case 1:
	case 2:
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0049\u0047\u0048\u0054\u0020\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_dgbba = int(args[1].ValueNumber)
		if _dgbba < 0 {
			return MakeErrorResult("R\u0049\u0047\u0048\u0054\u0020\u0065x\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u003e\u003d \u0030")
		}
		if _dgbba == 0 {
			return MakeStringResult("")
		}
	default:
		return MakeErrorResult("\u0052\u0049\u0047HT\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeList {
		return MakeErrorResult("\u0052\u0049\u0047\u0048\u0054\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020c\u0061l\u006c\u0065\u0064\u0020\u006f\u006e\u0020\u0061\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_gbdab := args[0].Value()
	_aedea := len(_gbdab)
	if _dgbba > _aedea {
		return MakeStringResult(_gbdab)
	}
	return MakeStringResult(_gbdab[_aedea-_dgbba : _aedea])
}

// Small implements the Excel SMALL function.
func Small(args []Result) Result { return _ddfe(args, false) }

// String returns a string representation of a horizontal range with prefix.
func (_afgb PrefixHorizontalRange) String() string {
	return _b.Sprintf("\u0025\u0073\u0021\u0025\u0064\u003a\u0025\u0064", _afgb._afcd.String(), _afgb._eadb, _afgb._abgg)
}

// Rri implements the Excel RRI function.
func Rri(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0052\u0052\u0049\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0052I\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ffgd := args[0].ValueNumber
	if _ffgd <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052R\u0049\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0052\u0049\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065\u006e\u0074 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_dccga := args[1].ValueNumber
	if _dccga <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0052\u0049\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006et\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("R\u0052\u0049\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0075\u0074\u0075\u0072e \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_abe := args[2].ValueNumber
	if _abe < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052R\u0049\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020f\u0075\u0074\u0075\u0072\u0065\u0020\u0076\u0061\u006cue\u0020\u0074\u006f \u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065g\u0061\u0074i\u0076\u0065")
	}
	return MakeNumberResult(_gg.Pow(_abe/_dccga, 1/_ffgd) - 1)
}
func _fddc() {
	_dbgcd = _af.MustCompile("\u005e\u0030\u002b\u0024")
	_cgaed = _af.MustCompile("\u005e\u0028\u0028\u0023|0\u0029\u002b\u002c\u0029\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u0028\u003b\u007c$\u0029")
	_bdbaf = _af.MustCompile("\u005e\u0028\u0023\u007c\u0030\u007c\u002c\u0029\u002a\u005f\u005c\u0029\u003b")
	_eddg = _af.MustCompile("\u005e\u0030\u002b\u005c\u002e\u0028\u0030\u002b\u0029\u0024")
	_aace = _af.MustCompile("\u005e\u0028\u0028\u0023\u007c\u0030\u0029\u002b\u002c\u0029+\u0028\u0023\u007c\u0030\u0029\u002b\u005c.\u0028\u0030\u002b\u0029\u002e\u002a\u0028\u003b\u007c\u0024\u0029")
	_aeac = _af.MustCompile("^\u0028\u005f\u007c\u002d\u007c\u0020)\u002b\u005c\u002a\u0020\u0023\u002b\u002c\u0023\u002b0\u005c\u002e\u00280\u002b)\u002e\u002a\u003b")
	_gdaf = _af.MustCompile("\u005e\u0028\u0028\u0023\u007c\u0030)\u002b\u002c\u0029\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u005c\u002e\u0028(\u0023\u007c\u0030\u0029\u002b\u0029\u005f\\\u0029\u002e\u002a\u003b")
	_adcf = _af.MustCompile("\u005e\u0028\u0023\u007c0)\u002b\u005c\u002e\u0028\u0028\u0023\u007c\u0030\u0029\u002b\u0029\u0025\u0024")
	_gcdc = _af.MustCompile("\u005c\u005b\u005c$\u005c\u0024\u002d\u002e+\u005c\u005d\u0028\u005c\u002a\u0020\u0029?\u0028\u0023\u007c\u0030\u0029\u002b\u002c\u0028\u0023\u007c\u0030\u0029\u002b\u003b")
	_fbdc = _af.MustCompile("\u005c[\u005c\u0024\\\u0024\u002d\u002e+\u005c\u005d\u0028\u005c\u002a\u0020\u0029?\u0028\u0023\u007c\u0030\u0029\u002b,\u0028\u0023\u007c\u0030\u0029\u002b\u005c\u002e\u0028\u0028\u0023|\u0030\u007c\u002d\u0029\u002b\u0029\u002e\u002a\u003b")
	_gfge = _af.MustCompile("\u005e(\u0028\u0023|\u0030\u0029\u002b,\u0029\u002b\u0028\u0023\u007c\u0030\u0029+\u0028\u005c\u002e\u0028\u0028\u0023|\u0030\u007c\u002d\u0029\u002b\u0029\u0029\u003f\u002e\u002b\u005c[\u005c\u0024\u002e\u002b\u005c\u005d\u002e\u002a\u003b")
	_cdeg = _af.MustCompile("\u005e\u004d\u002b(\u002f\u007c\u0020\u007c\u002c\u007c\u0022\u007c" + _faac + _faac + "\u0029\u002b\u0044\u002b\u0028\u002f\u007c\u0020\u007c\u002c\u007c\u0022\u007c" + _faac + _faac + "\u0029\u002b\u0059+\u0024")
	_egfdg = _af.MustCompile("\u005e\u0044\u002b\u0028\u002f\u007c\u0020\u007c\u005c\u002e\u007c\u0022\u007c" + _faac + _faac + "\u0029\u002b\u004d\u002b\u0028\u002f\u007c\u0020\u007c\\\u002e\u007c\u0022\u007c" + _faac + _faac + "\u0029\u002b\u0059+\u0024")
	_bfaf = _af.MustCompile("\u005e\u0028\u0023|\u0030\u0029\u002b\u005c.\u0028\u0028\u0023\u007c\u0030\u0029\u002a)\u0045\u005c\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u0028\u003b\u007c\u0024\u0029")
	_gbcb = _af.MustCompile("\u005e.\u002a\u005f\u005c\u0029\u002e\u002a;")
}

var _ecceg = []ri{{1000, "\u004d"}, {999, "\u0049\u004d"}, {995, "\u0056\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {499, "\u0049\u0044"}, {495, "\u0056\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// Result is the result of a formula or cell evaluation .
type Result struct {
	ValueNumber  float64
	ValueString  string
	ValueList    []Result
	ValueArray   [][]Result
	IsBoolean    bool
	ErrorMessage string
	Type         ResultType
	Ref          Reference
}

// Tbillprice implements the Excel TBILLPRICE function.
func Tbillprice(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0050\u0052I\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_gcagf, _dgga, _aeeb := _daea(args[0], args[1], "\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045")
	if _aeeb.Type == ResultTypeError {
		return _aeeb
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0064\u0069\u0073\u0063\u006f\u0075n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_afgf := _dgga - _gcagf
	if _afgf > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004cP\u0052\u0049\u0043\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020t\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079e\u0061\u0072\u0020\u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_fcea := args[2].ValueNumber
	if _fcea <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020d\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeNumberResult(100 * (1 - _fcea*_afgf/360))
}

var _abeg = []ri{{1000, "\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

const _fabec = 57360

func _ggb(_fdb string, _ff *_egg.UpdateQuery) string {
	_dba, _faa := _df.ParseCellReference(_fdb)
	if _faa != nil {
		return "\u0023\u0052\u0045F\u0021"
	}
	if _ff.UpdateType == _egg.UpdateActionRemoveColumn {
		_cb := _ff.ColumnIdx
		_bad := _dba.ColumnIdx
		if _bad < _cb {
			return _fdb
		} else if _bad == _cb {
			return "\u0023\u0052\u0045F\u0021"
		} else {
			return _dba.Update(_egg.UpdateActionRemoveColumn).String()
		}
	}
	return _fdb
}

// Choose implements the Excel CHOOSE function.
func Choose(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0043\u0048O\u004f\u0053\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_egfa := args[0]
	if _egfa.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043H\u004f\u004fS\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_aefd := int(_egfa.ValueNumber)
	if len(args) <= _aefd {
		return MakeErrorResult("\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0068\u006f\u0075\u006cd\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073 \u006fr\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0076\u0061\u006c\u0075\u0065\u0073")
	}
	return args[_aefd]
}

var InvalidReferenceContext = &ivr{}

// CountIfs implements the COUNTIFS function.
func CountIfs(args []Result) Result {
	_dccc := _ddaa(args, false, "\u0043\u004f\u0055\u004e\u0054\u0049\u0046\u0053")
	if _dccc.Type != ResultTypeEmpty {
		return _dccc
	}
	_debcd := _agge(args)
	return MakeNumberResult(float64(len(_debcd)))
}

// GetFormat returns an empty string for the invalid reference context.
func (_aegdd *ivr) GetFormat(cellRef string) string { return "" }
func _eccg(_def, _bdbg int) int {
	if _bdbg == 2 && _dbfd(_def) {
		return 29
	} else {
		return _be[_bdbg-1]
	}
}
func _adffc(_fddf, _aebff []string) []string {
	for _, _bdff := range _aebff {
		_fddf = append(_fddf, _bdff)
	}
	return _fddf
}

const _egeed = 57366
const _cbbe = 57362

// Reference returns a string reference value to a sheet.
func (_abbgg SheetPrefixExpr) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeSheet, Value: _abbgg._fdcd}
}
func _edgab(_dcdbd string) string {
	_dcdbd = _fa.Replace(_dcdbd, "\u000a", "\u005c\u006e", -1)
	_dcdbd = _fa.Replace(_dcdbd, "\u000d", "\u005c\u0072", -1)
	_dcdbd = _fa.Replace(_dcdbd, "\u0009", "\u005c\u0074", -1)
	return _dcdbd
}

// FunctionComplex is a function whose result  depends on its arguments and the
// context that it's in.  As an example, INDIRECT is a complex function so that
// INDIRECT("A1") which returns the value of the "A1" cell in a sheet can use
// the context to reach into the sheet and pull out required values.
type FunctionComplex func(_fdagb Context, _aebebb Evaluator, _ecfc []Result) Result

// Coupnum implements the Excel COUPNUM function.
func Coupnum(args []Result) Result {
	_eddb, _gebb := _gdgb(args, "\u0043O\u0055\u0050\u004e\u0055\u004d")
	if _gebb.Type == ResultTypeError {
		return _gebb
	}
	_bfaeb := _eddb._eda
	_daeae := _eddb._ceca
	_cdd, _gebb := _cbge(_eddb._eebf, _eddb._edge, _bfaeb, _daeae)
	if _gebb.Type == ResultTypeError {
		return _gebb
	}
	return MakeNumberResult(_cdd)
}

type tokenType int

// String returns a string of a range.
func (_fdabb Range) String() string {
	return _b.Sprintf("\u0025\u0073\u003a%\u0073", _fdabb._ecgg.String(), _fdabb._bgfde.String())
}

// IsLogical is an implementation of the Excel ISLOGICAL() function.
func IsLogical(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u004c\u004f\u0047\u0049\u0043A\u004c\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bgad := args[0].Ref
	if _bgad.Type != ReferenceTypeCell {
		return MakeErrorResult("I\u0053\u004c\u004f\u0047\u0049\u0043\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072\u0067\u0075\u006de\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	return MakeBoolResult(ctx.Cell(_bgad.Value, ev).IsBoolean)
}

const _gba = "\u005e\u0028\u0028" + _geb + "\u007c" + _bcg + "\u007c" + _gfd + "\u007c" + _fgd + "\u0029\u0020\u0029\u003f"

type noCache struct{}

func _efe(_fdeg, _bdgf _ea.Time, _eafa, _bca int) _ea.Time {
	_eaeb := _bdgf
	_bcbb := _fdeg.Year() - _bdgf.Year()
	_eaeb = _eaeb.AddDate(_bcbb, 0, 0)
	if _fdeg.After(_eaeb) {
		_eaeb = _eaeb.AddDate(1, 0, 0)
	}
	_bfdg := -12 / _eafa
	for _eaeb.After(_fdeg) {
		_eaeb = _eaeb.AddDate(0, _bfdg, 0)
	}
	return _eaeb
}

// String returns a string representation of PrefixExpr.
func (_dfbb PrefixExpr) String() string {
	return _b.Sprintf("\u0025\u0073\u0021%\u0073", _dfbb._cafc.String(), _dfbb._adda.String())
}

// Xnpv implements the Excel XNPV function.
func Xnpv(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0058\u004eP\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("X\u004e\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_bfdcb := args[0].ValueNumber
	if _bfdcb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0058\u004e\u0050\u0056\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	_aabc, _dffg := _cdaa(args[1], args[2], "\u0058\u004e\u0050\u0056")
	if _dffg.Type == ResultTypeError {
		return _dffg
	}
	_facc := _aabc._gaed
	_ccgb := _aabc._fbbee
	_dfgea := 0.0
	_fafa := _ccgb[0]
	for _gedc, _bbfb := range _facc {
		_dfgea += _bbfb / _gg.Pow(1+_bfdcb, (_ccgb[_gedc]-_fafa)/365)
	}
	return MakeNumberResult(_dfgea)
}

const _fgd = "(\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002d" + _abg + "-\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

var _gdfaa = [...]int{0, 1, 1, 2, 4, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 2, 1, 1, 1, 3, 4, 1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 2, 3, 1, 3, 1, 1, 0}

type Reference struct {
	Type  ReferenceType
	Value string
}

// VLookup implements the VLOOKUP function that returns a matching value from a
// column in an array.
func VLookup(args []Result) Result {
	_cgdfc := len(args)
	if _cgdfc < 3 {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004bU\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _cgdfc > 4 {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0074\u0020m\u006f\u0073\u0074\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_ecbdf := args[0]
	_deebgd := args[1]
	if _deebgd.Type != ResultTypeArray {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_aaed := args[2].AsNumber()
	if _aaed.Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050 \u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0063\u006f\u006c\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gafaa := false
	if _cgdfc == 4 && args[3].Type != ResultTypeEmpty {
		_aaea := args[3].AsNumber()
		if _aaea.Type != ResultTypeNumber {
			return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		if _aaea.ValueNumber == 0 {
			_gafaa = true
		}
	}
	_cggg := int(_aaed.ValueNumber) - 1
	_dbadc := -1
	_begf := false
_eegf:
	for _aaae, _fcfgf := range _deebgd.ValueArray {
		if len(_fcfgf) == 0 {
			continue
		}
		_fbef := _fcfgf[0]
		switch _fbae(_fbef, _ecbdf, false, _gafaa) {
		case _fceaf:
			_dbadc = _aaae
		case _gabde:
			_dbadc = _aaae
			_begf = true
			break _eegf
		}
	}
	if _dbadc == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_cdcb := _deebgd.ValueArray[_dbadc]
	if _cggg < 0 || _cggg >= len(_cdcb) {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0063\u006f\u006c\u0075\u006d\u006e\u0020\u0069\u006e\u0064\u0065\u0078")
	}
	if _begf || !_gafaa {
		return _cdcb[_cggg]
	}
	return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
}

// Round is an implementation of the Excel ROUND function that rounds a number
// to a specified number of digits.
func Round(args []Result) Result { return _bbge(args, _egee) }
func init() {
	_ggfc()
	RegisterFunction("\u0041V\u0045\u0052\u0041\u0047\u0045", Average)
	RegisterFunction("\u0041\u0056\u0045\u0052\u0041\u0047\u0045\u0041", Averagea)
	RegisterFunction("\u0043\u004f\u0055N\u0054", Count)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0041", Counta)
	RegisterFunction("\u0043O\u0055\u004e\u0054\u0049\u0046", CountIf)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0049\u0046\u0053", CountIfs)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0042\u004c\u0041\u004e\u004b", CountBlank)
	RegisterFunction("\u004d\u0041\u0058", Max)
	RegisterFunction("\u004d\u0041\u0058\u0041", MaxA)
	RegisterFunction("\u004d\u0041\u0058\u0049\u0046\u0053", MaxIfs)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u004d\u0041\u0058\u0049\u0046\u0053", MaxIfs)
	RegisterFunction("\u004d\u0045\u0044\u0049\u0041\u004e", Median)
	RegisterFunction("\u004d\u0049\u004e", Min)
	RegisterFunction("\u004d\u0049\u004e\u0041", MinA)
	RegisterFunction("\u004d\u0049\u004e\u0049\u0046\u0053", MinIfs)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u004d\u0049\u004e\u0049\u0046\u0053", MinIfs)
}

// Function is a standard function whose result only depends on its arguments.
type Function func(_eeaa []Result) Result

func _ed(_gc Result) bool {
	if _gc.Type == ResultTypeString {
		return _gc.ValueString == ""
	}
	return _gc.ValueNumber == 0
}
func _cfff(_dgedg Result, _gafe int) []Result {
	_dbfa := []Result{}
	switch _dgedg.Type {
	case ResultTypeList:
		_caafg := _dgedg.ValueList
		_afee := len(_caafg)
		for _ecedb := 0; _ecedb < _gafe; _ecedb++ {
			if _ecedb < _afee {
				_dbfa = append(_dbfa, _caafg[_ecedb])
			} else {
				_dbfa = append(_dbfa, MakeErrorResultType(ErrorTypeNA, ""))
			}
		}
	case ResultTypeNumber, ResultTypeString, ResultTypeError, ResultTypeEmpty:
		for _gccd := 0; _gccd < _gafe; _gccd++ {
			_dbfa = append(_dbfa, _dgedg)
		}
	}
	return _dbfa
}

type defEval struct {
	evCache
	_ccf bool
}

func _gffb(_aadg, _dgg, _dgf, _abb, _begee float64, _cfe int) Result {
	_eebc, _dgfb := _cbfa(_aadg, _dgg, _cfe)
	if _dgfb.Type == ResultTypeError {
		return _dgfb
	}
	_ffe, _dbabc := _cbge(_aadg, _dgg, int(_begee), _cfe)
	if _dbabc.Type == ResultTypeError {
		return _dbabc
	}
	_ced := 0.0
	_ggdb := 0.0
	_dgf *= 100 / _begee
	_abb /= _begee
	_abb++
	_dea := _eebc*_begee - _ffe
	for _faef := 1.0; _faef < _ffe; _faef++ {
		_ebc := _faef + _dea
		_gfdf := _dgf / _gg.Pow(_abb, _ebc)
		_ggdb += _gfdf
		_ced += _ebc * _gfdf
	}
	_deac := (_dgf + 100) / _gg.Pow(_abb, _ffe+_dea)
	_ggdb += _deac
	_ced += (_ffe + _dea) * _deac
	_ced /= _ggdb
	_ced /= _begee
	return MakeNumberResult(_ced)
}

// Reference returns a string reference value to a vertical range.
func (_fccd VerticalRange) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeVerticalRange, Value: _fccd.verticalRangeReference()}
}

// Update updates the FunctionCall references after removing a row/column.
func (_eaga FunctionCall) Update(q *_egg.UpdateQuery) Expression {
	_ccfef := []Expression{}
	for _, _cfba := range _eaga._aeef {
		_fbbae := _cfba.Update(q)
		_ccfef = append(_ccfef, _fbbae)
	}
	return FunctionCall{_eadcc: _eaga._eadcc, _aeef: _ccfef}
}

// Eval evaluates and returns the result of a Negate expression.
func (_adga Negate) Eval(ctx Context, ev Evaluator) Result {
	_fdfgc := _adga._bddff.Eval(ctx, ev)
	if _fdfgc.Type == ResultTypeNumber {
		return MakeNumberResult(-_fdfgc.ValueNumber)
	}
	return MakeErrorResult("\u004e\u0045\u0047A\u0054\u0045\u0020\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
}
func LexReader(r _e.Reader) chan *node { _caffc := NewLexer(); go _caffc.lex(r); return _caffc._fggf }
func _bcfa(_dbad, _baa, _aafg int) bool {
	if _baa < 1 || _baa > 12 {
		return false
	}
	if _aafg < 1 {
		return false
	}
	return _aafg <= _eccg(_dbad, _baa)
}

const _geb = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002f\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u002f\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

// Eval evaluates and returns an expression with prefix.
func (_bbbg PrefixExpr) Eval(ctx Context, ev Evaluator) Result {
	_dcad := _bbbg._cafc.Reference(ctx, ev)
	switch _dcad.Type {
	case ReferenceTypeSheet:
		_gdaaf := ctx.Sheet(_dcad.Value)
		return _bbbg._adda.Eval(_gdaaf, ev)
	default:
		return MakeErrorResult(_b.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _dcad.Type))
	}
}

const (
	ResultTypeUnknown ResultType = iota
	ResultTypeNumber
	ResultTypeString
	ResultTypeList
	ResultTypeArray
	ResultTypeError
	ResultTypeEmpty
)

// Update updates references in the Negate after removing a row/column.
func (_fbgc Negate) Update(q *_egg.UpdateQuery) Expression     { return Negate{_fbgc._bddff.Update(q)} }
func (_dccec *noCache) GetFromCache(key string) (Result, bool) { return _aaa, false }

// Int is an implementation of the Excel INT() function that rounds a number
// down to an integer.
func Int(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("I\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_bbfaa := args[0].AsNumber()
	if _bbfaa.Type != ResultTypeNumber {
		return MakeErrorResult("I\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_efgga, _bec := _gg.Modf(_bbfaa.ValueNumber)
	if _bec < 0 {
		_efgga--
	}
	return MakeNumberResult(_efgga)
}
func (_ddffa VerticalRange) verticalRangeReference() string {
	return _b.Sprintf("\u0025\u0073\u003a%\u0073", _ddffa._eabbc, _ddffa._cebb)
}

// Mduration implements the Excel MDURATION function.
func Mduration(args []Result) Result {
	_edgg, _ccfc := _aggbe(args, "\u004dD\u0055\u0052\u0041\u0054\u0049\u004fN")
	if _ccfc.Type == ResultTypeError {
		return _ccfc
	}
	_caab := _edgg._dade
	_fdfg := _edgg._ddfb
	_caeg := _edgg._egcd
	_agbf := _edgg._agabg
	_eece := _edgg._accf
	_ffac := _edgg._afbc
	_feeb := _gffb(_caab, _fdfg, _caeg, _agbf, _eece, _ffac)
	if _feeb.Type == ResultTypeError {
		return _feeb
	}
	_gdad := _feeb.ValueNumber / (1.0 + _agbf/_eece)
	return MakeNumberResult(_gdad)
}

// Concat is an implementation of the Excel CONCAT() and deprecated CONCATENATE() function.
func Concat(args []Result) Result {
	_fcggb := _bg.Buffer{}
	for _, _bdef := range args {
		switch _bdef.Type {
		case ResultTypeString:
			_fcggb.WriteString(_bdef.ValueString)
		case ResultTypeNumber:
			var _eggbe string
			if _bdef.IsBoolean {
				if _bdef.ValueNumber == 0 {
					_eggbe = "\u0046\u0041\u004cS\u0045"
				} else {
					_eggbe = "\u0054\u0052\u0055\u0045"
				}
			} else {
				_eggbe = _bdef.AsString().ValueString
			}
			_fcggb.WriteString(_eggbe)
		default:
			return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041T\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0073")
		}
	}
	return MakeStringResult(_fcggb.String())
}

type yySymType struct {
	_ffdb   int
	_ddcb   *node
	_bgfd   Expression
	_babdac []Expression
	_aaee   [][]Expression
}

// Proper is an implementation of the Excel PROPER function that returns a copy
// of the string with each word capitalized.
func Proper(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("P\u0052\u004f\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006eg \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_edecd := args[0].AsString()
	if _edecd.Type != ResultTypeString {
		return MakeErrorResult("P\u0052\u004f\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006eg \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_ebaag := _bg.Buffer{}
	_dega := false
	for _, _bbfbg := range _edecd.ValueString {
		if !_dega && _g.IsLetter(_bbfbg) {
			_ebaag.WriteRune(_g.ToUpper(_bbfbg))
		} else {
			_ebaag.WriteRune(_g.ToLower(_bbfbg))
		}
		_dega = _g.IsLetter(_bbfbg)
	}
	return MakeStringResult(_ebaag.String())
}
func _fgag(_fbff _ea.Time) _ea.Time {
	_fbff = _fbff.UTC()
	return _ea.Date(_fbff.Year(), _fbff.Month(), _fbff.Day(), _fbff.Hour(), _fbff.Minute(), _fbff.Second(), _fbff.Nanosecond(), _ea.Local)
}

// String returns a string representation of String.
func (_gdgagb String) String() string { return "\u0022" + _gdgagb._cabg + "\u0022" }

var _bgab []byte = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

const _abd = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0054\u0049\u004d\u0045\u0056\u0041\u004c\u0055\u0045"

// Update updates references in the PrefixRangeExpr after removing a row/column.
func (_feadb PrefixRangeExpr) Update(q *_egg.UpdateQuery) Expression {
	_fgagg := _feadb
	_gbfgf := _feadb._cbcc.String()
	if _gbfgf == q.SheetToUpdate {
		_aedbg := *q
		_aedbg.UpdateCurrentSheet = true
		_fgagg._dgcf = _feadb._dgcf.Update(&_aedbg)
		_fgagg._ccefe = _feadb._ccefe.Update(&_aedbg)
	}
	return _fgagg
}
func _fgbg(_fdac float64) float64 {
	_cceg := float64(1)
	for _gad := float64(2); _gad <= _fdac; _gad++ {
		_cceg *= _gad
	}
	return _cceg
}

var _ffdbc []byte = []byte{0, 1, 2, 1, 11, 1, 12, 1, 13, 1, 14, 1, 15, 1, 16, 1, 17, 1, 18, 1, 19, 1, 20, 1, 21, 1, 22, 1, 23, 1, 24, 1, 25, 1, 26, 1, 27, 1, 28, 1, 29, 1, 30, 1, 31, 1, 32, 1, 33, 1, 34, 1, 35, 1, 36, 1, 37, 1, 38, 1, 39, 1, 40, 1, 41, 1, 42, 1, 43, 2, 0, 1, 2, 3, 4, 2, 3, 5, 2, 3, 6, 2, 3, 7, 2, 3, 8, 2, 3, 9, 2, 3, 10}

type yyLexer interface {
	Lex(_ccdff *yySymType) int
	Error(_bdfee string)
}

// RegisterFunctionComplex registers a standard function.
func RegisterFunctionComplex(name string, fn FunctionComplex) {
	_agccd.Lock()
	defer _agccd.Unlock()
	if _, _cfcdg := _ddebg[name]; _cfcdg {
		_cg.Log("\u0064\u0075p\u006c\u0069\u0063\u0061t\u0065\u0020r\u0065\u0067\u0069\u0073\u0074\u0072\u0061\u0074i\u006f\u006e\u0020\u006f\u0066\u0020\u0066\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0025\u0073", name)
	}
	_ddebg[name] = fn
}
func _fcag(_ead, _cgeag _ea.Time, _aadba int) _ea.Time {
	_gfgbf := _ea.Date(_ead.Year(), _cgeag.Month(), _cgeag.Day(), 0, 0, 0, 0, _ea.UTC)
	if _gfgbf.After(_ead) {
		_gfgbf = _gfgbf.AddDate(-1, 0, 0)
	}
	for !_gfgbf.After(_ead) {
		_gfgbf = _gfgbf.AddDate(0, 12/_aadba, 0)
	}
	return _gfgbf
}

// Reference returns a string reference value to a horizontal range with prefix.
func (_deaga PrefixHorizontalRange) Reference(ctx Context, ev Evaluator) Reference {
	_dgabe := _deaga._afcd.Reference(ctx, ev)
	return Reference{Type: ReferenceTypeHorizontalRange, Value: _deaga.horizontalRangeReference(_dgabe.Value)}
}
func _afc(_aeae, _caaf []float64, _ggag float64) Result {
	_cab := false
	_ebff := false
	for _faadb := 0; _faadb < len(_aeae); _faadb++ {
		if _aeae[_faadb] > 0 {
			_cab = true
		}
		if _aeae[_faadb] < 0 {
			_ebff = true
		}
	}
	if !_cab || !_ebff {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	_ffcd := _ggag
	_dccf := 1e-10
	_acdf := 0
	_bdgd := 50
	_ggdfb := false
	for {
		_egba := _efab(_aeae, _caaf, _ffcd)
		_bbdb := _ffcd - _egba/_dddg(_aeae, _caaf, _ffcd)
		_gebd := _gg.Abs(_bbdb - _ffcd)
		_ffcd = _bbdb
		_acdf++
		if _gebd <= _dccf || _gg.Abs(_egba) <= _dccf {
			break
		}
		if _acdf > _bdgd {
			_ggdfb = true
			break
		}
	}
	if _ggdfb || _gg.IsNaN(_ffcd) || _gg.IsInf(_ffcd, 0) {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	return MakeNumberResult(_ffcd)
}
func _dddg(_begb, _dgdb []float64, _dcab float64) float64 {
	_fded := _dcab + 1
	_gcga := 0.0
	_ggge := len(_begb)
	_dbfce := _dgdb[0]
	for _dffff := 1; _dffff < _ggge; _dffff++ {
		_fgad := (_dgdb[_dffff] - _dbfce) / 365
		_gcga -= _fgad * _begb[_dffff] / _gg.Pow(_fded, _fgad+1)
	}
	return _gcga
}

// Multinomial implements the excel MULTINOMIAL function.
func Multinomial(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u004d\u0055\u004c\u0054\u0049\u004eO\u004d\u0049\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006ce\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c\u0020i\u006e\u0070\u0075\u0074")
	}
	_bcfdd, _gfac, _bgadb := _eebd(args)
	if _bgadb.Type == ResultTypeError {
		return _bgadb
	}
	return MakeNumberResult(_fgbg(_bcfdd) / _gfac)
}
func init() {
	RegisterFunction("\u0043\u0048\u0041\u0052", Char)
	RegisterFunction("\u0043\u004c\u0045A\u004e", Clean)
	RegisterFunction("\u0043\u004f\u0044\u0045", Code)
	RegisterFunction("C\u004f\u004e\u0043\u0041\u0054\u0045\u004e\u0041\u0054\u0045", Concat)
	RegisterFunction("\u0043\u004f\u004e\u0043\u0041\u0054", Concat)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u0043\u004f\u004e\u0043\u0041\u0054", Concat)
	RegisterFunction("\u0045\u0058\u0041C\u0054", Exact)
	RegisterFunction("\u0046\u0049\u004e\u0044", Find)
	RegisterFunctionComplex("\u0046\u0049\u004eD\u0042", Findb)
	RegisterFunction("\u004c\u0045\u0046\u0054", Left)
	RegisterFunction("\u004c\u0045\u0046T\u0042", Left)
	RegisterFunction("\u004c\u0045\u004e", Len)
	RegisterFunction("\u004c\u0045\u004e\u0042", Len)
	RegisterFunction("\u004c\u004f\u0057E\u0052", Lower)
	RegisterFunction("\u004d\u0049\u0044", Mid)
	RegisterFunction("\u0050\u0052\u004f\u0050\u0045\u0052", Proper)
	RegisterFunction("\u0052E\u0050\u004c\u0041\u0043\u0045", Replace)
	RegisterFunction("\u0052\u0045\u0050\u0054", Rept)
	RegisterFunction("\u0052\u0049\u0047H\u0054", Right)
	RegisterFunction("\u0052\u0049\u0047\u0048\u0054\u0042", Right)
	RegisterFunction("\u0053\u0045\u0041\u0052\u0043\u0048", Search)
	RegisterFunctionComplex("\u0053E\u0041\u0052\u0043\u0048\u0042", Searchb)
	RegisterFunction("\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", Substitute)
	RegisterFunction("\u0054", T)
	RegisterFunction("\u0054\u0045\u0058\u0054", Text)
	RegisterFunction("\u0054\u0045\u0058\u0054\u004a\u004f\u0049\u004e", TextJoin)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0054\u0045\u0058T\u004a\u004f\u0049\u004e", TextJoin)
	RegisterFunction("\u0054\u0052\u0049\u004d", Trim)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0055\u004e\u0049\u0043\u0048\u0041\u0052", Char)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0055\u004e\u0049\u0043\u004f\u0044\u0045", Unicode)
	RegisterFunction("\u0055\u0050\u0050E\u0052", Upper)
	RegisterFunction("\u0056\u0041\u004cU\u0045", Value)
}
func (_bfdba *plex) Lex(lval *yySymType) int {
	_gagfea = true
	_cedag := <-_bfdba._edaga
	if _cedag != nil {
		lval._ddcb = _cedag
		return int(lval._ddcb._ccfcc)
	}
	return 0
}

// Xor is an implementation of the Excel XOR() function and takes a variable
// number of arguments. It's odd to say the least.  If any argument is numeric,
// it returns true if the number of non-zero numeric arguments is odd and false
// otherwise.  If no argument is numeric, it returns an error.
func Xor(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0058\u004f\u0052 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061t\u0020l\u0065a\u0073t\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fcda := 0
	_daae := false
	for _, _gfcc := range args {
		switch _gfcc.Type {
		case ResultTypeList, ResultTypeArray:
			_agagc := Xor(_gfcc.ListValues())
			if _agagc.Type == ResultTypeError {
				return _agagc
			}
			if _agagc.ValueNumber != 0 {
				_fcda++
			}
			_daae = true
		case ResultTypeNumber:
			if _gfcc.ValueNumber != 0 {
				_fcda++
			}
			_daae = true
		case ResultTypeString:
		case ResultTypeError:
			return _gfcc
		default:
			return MakeErrorResult("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0061\u0072\u0067u\u006de\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0058\u004f\u0052")
		}
	}
	if !_daae {
		return MakeErrorResult("\u0058\u004f\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069n\u0070\u0075\u0074")
	}
	return MakeBoolResult(_fcda%2 != 0)
}

var _fafcd = [...]uint8{0, 20, 37, 60, 78, 96}

// Ispmt implements the Excel ISPMT function.
func Ispmt(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("\u0049\u0053P\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eace := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0070e\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_caff := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069o\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ebdb := args[2].ValueNumber
	if _ebdb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049S\u0050\u004d\u0054\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072i\u006f\u0064\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062er\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065s\u0065\u006e\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_egggd := args[3].ValueNumber
	return MakeNumberResult(_egggd * _eace * (_caff/_ebdb - 1))
}
func _efcg(_ebee, _bagg float64, _ddea, _gcgf int) float64 {
	_aeb := _ddef(_ebee)
	_gdc := _ddef(_bagg)
	if _gcgf == 1 {
		_cbbd := _efe(_aeb, _gdc, _ddea, 1)
		_fea := _cbbd.AddDate(0, 12/_ddea, 0)
		return _bdeb(_cbbd, _fea, _gcgf)
	}
	return float64(_fdge(0, _gcgf)) / float64(_ddea)
}
func _gbbg(_aaafb Result, _debb *criteriaParsed) bool {
	_ddee := _fa.ToLower(_aaafb.ValueString)
	_ecfe := _debb._edbfb._dgbebb
	_aged := _debb._edbfb._cbcgcc
	if _ecfe == _cgbed {
		return _ddee == _aged || _d.Match(_aged, _ddee)
	}
	if _aaafb.Type != ResultTypeEmpty {
		if _ddee == _debb._ffcbg || _d.Match(_debb._ffcbg, _ddee) {
			return true
		}
		if _, _bgdf := _ga.ParseFloat(_aged, 64); _bgdf == nil {
			return false
		}
		switch _ecfe {
		case _eacfe:
			return _ddee <= _aged
		case _fbafb:
			return _ddee >= _aged
		case _eabe:
			return _ddee < _aged
		case _efeg:
			return _ddee > _aged
		}
	}
	return false
}

const _egce = 57369

// IsNA is an implementation of the Excel ISNA() function.
func IsNA(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u004e\u0041\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError && args[0].ValueString == "\u0023\u004e\u002f\u0041")
}

// Update updates references in the PrefixVerticalRange after removing a row/column.
func (_afcb PrefixVerticalRange) Update(q *_egg.UpdateQuery) Expression {
	if q.UpdateType == _egg.UpdateActionRemoveColumn {
		_faabf := _afcb
		_gebac := _afcb._ccea.String()
		if _gebac == q.SheetToUpdate {
			_abdfe := q.ColumnIdx
			_faabf._fbedd = _eb(_afcb._fbedd, _abdfe)
			_faabf._gacbg = _eb(_afcb._gacbg, _abdfe)
		}
		return _faabf
	}
	return _afcb
}
func _gcgcd(_ecab string, _ffeb []Result) (*parsedReplaceObject, Result) {
	if len(_ffeb) != 4 {
		return nil, MakeErrorResult(_ecab + "\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _ffeb[0].Type != ResultTypeString {
		return nil, MakeErrorResult(_ecab + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_aabbb := _ffeb[0].ValueString
	if _ffeb[1].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_ecab + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e \u0061\u0020\u006eu\u006db\u0065\u0072")
	}
	_ccged := int(_ffeb[1].ValueNumber) - 1
	if _ffeb[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_ecab + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0069r\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cbfb := int(_ffeb[2].ValueNumber)
	if _ffeb[3].Type != ResultTypeString {
		return nil, MakeErrorResult(_ecab + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0074\u0068\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e \u0061\u0020\u0073t\u0072i\u006e\u0067")
	}
	_dcaa := _ffeb[3].ValueString
	return &parsedReplaceObject{_aabbb, _ccged, _cbfb, _dcaa}, _aaa
}
func (_bfe BinOpType) String() string {
	if _bfe >= BinOpType(len(_bac)-1) {
		return _b.Sprintf("\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029", _bfe)
	}
	return _eff[_bac[_bfe]:_bac[_bfe+1]]
}

// Eval evaluates a vertical range returning a list of results or an error.
func (_gefgc VerticalRange) Eval(ctx Context, ev Evaluator) Result {
	_affdb := _gefgc.verticalRangeReference()
	if _fcdgee, _decc := ev.GetFromCache(_affdb); _decc {
		return _fcdgee
	}
	_acecb, _fggb := _ffbba(ctx, _gefgc._eabbc, _gefgc._cebb)
	_ffgbb := _bdgac(ctx, ev, _acecb, _fggb)
	ev.SetCache(_affdb, _ffgbb)
	return _ffgbb
}

// Npv implements the Excel NPV function.
func Npv(args []Result) Result {
	_ebb := len(args)
	if _ebb < 2 {
		return MakeErrorResult("\u004e\u0050\u0056 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f \u006fr\u0020m\u006f\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ddbd := args[0].ValueNumber
	if _ddbd == -1 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_effg := []float64{}
	for _, _cega := range args[1:] {
		switch _cega.Type {
		case ResultTypeNumber:
			_effg = append(_effg, _cega.ValueNumber)
		case ResultTypeArray, ResultTypeList:
			_cbgd := _aefda(_cega)
			for _, _acad := range _cbgd {
				for _, _cbcgc := range _acad {
					if _cbcgc.Type == ResultTypeNumber && !_cbcgc.IsBoolean {
						_effg = append(_effg, _cbcgc.ValueNumber)
					}
				}
			}
		}
	}
	_dgb := 0.0
	for _fgdfa, _geeag := range _effg {
		_dgb += _geeag / _gg.Pow(1+_ddbd, float64(_fgdfa)+1)
	}
	return MakeNumberResult(_dgb)
}

var (
	_gfeg   = 0
	_gagfea = false
)

func _agaea(_dgef [][]Result, _acgcd int) [][]Result {
	_bgcf := [][]Result{}
	for _gacbc := range _dgef {
		if _gacbc == 0 {
			continue
		}
		_fgga := []Result{}
		for _eeee := range _dgef {
			if _eeee == _acgcd {
				continue
			}
			_fgga = append(_fgga, _dgef[_gacbc][_eeee])
		}
		_bgcf = append(_bgcf, _fgga)
	}
	return _bgcf
}

// Rows implements the Excel ROWS function.
func Rows(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0052\u004f\u0057\u0053\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	_aadge := args[0]
	if _aadge.Type != ResultTypeArray && _aadge.Type != ResultTypeList {
		return MakeErrorResult("\u0052\u004f\u0057S\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_geee := _aadge.ValueArray
	if len(_geee) == 0 {
		return MakeErrorResult("\u0052O\u0057\u0053 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0072r\u0061\u0079\u0020\u0074\u006f\u0020c\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074\u0020\u006ce\u0061\u0073\u0074\u0020\u0031\u0020\u0072\u006f\u0077")
	}
	return MakeNumberResult(float64(len(_geee)))
}

var _agccd _eg.Mutex

// Update updates references in the PrefixHorizontalRange after removing a row/column.
func (_aedg PrefixHorizontalRange) Update(q *_egg.UpdateQuery) Expression { return _aedg }

// NewCellRef constructs a new cell reference.
func NewCellRef(v string) Expression { return CellRef{v} }

// ResultType is the type of the result
//go:generate stringer -type=ResultType
type ResultType byte

// Rate implements the Excel RATE function.
func Rate(args []Result) Result {
	_egdc := len(args)
	if _egdc < 3 || _egdc > 6 {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0072\u0065\u0065 \u0061\u006e\u0064\u0020\u0073i\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eaag := args[0].ValueNumber
	if _eaag != float64(int(_eaag)) {
		return MakeErrorResultType(ErrorTypeNum, "R\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072i\u006fd\u0073\u0020\u0074\u006f \u0062\u0065 \u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0070\u0061y\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bgfg := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_cadb := args[2].ValueNumber
	_efbe := 0.0
	if _egdc >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_efbe = args[3].ValueNumber
	}
	_bage := 0.0
	if _egdc >= 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("R\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_bage = args[4].ValueNumber
		if _bage != 0 {
			_bage = 1
		}
	}
	_agaf := 0.1
	if _egdc >= 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_agaf = args[5].ValueNumber
	}
	_gafa := 100
	_gdd := 0
	_fdab := false
	_facdc := 1e-6
	_efag := _agaf
	for _gdd < _gafa && !_fdab {
		_gbdg := _gg.Pow(_efag+1, _eaag)
		_dgcc := _gg.Pow(_efag+1, _eaag-1)
		_dbadd := _efag*_bage + 1
		_gaaa := _bgfg * (_gbdg - 1)
		_eaea := _efbe + _gbdg*_cadb + _gaaa*_dbadd/_efag
		_gabaa := _eaag*_dgcc*_cadb - _gaaa*_dbadd/_gg.Pow(_efag, 2)
		_cbacg := (_eaag*_bgfg*_dgcc*_dbadd + _gaaa*_bage) / _efag
		_ebefc := _eaea / (_gabaa + _cbacg)
		if _gg.Abs(_ebefc) < _facdc {
			_fdab = true
		}
		_gdd++
		_efag -= _ebefc
	}
	return MakeNumberResult(_efag)
}

// Char is an implementation of the Excel CHAR function that takes an integer in
// the range [0,255] and returns the corresponding ASCII character.
func Char(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bbdbe := args[0].AsNumber()
	if _bbdbe.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fggec := int(_bbdbe.ValueNumber)
	if _fggec < 0 || _fggec > 255 {
		return MakeErrorResult("\u0043H\u0041\u0052 \u0072\u0065\u0071\u0075i\u0072\u0065\u0073 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073 i\u006e\u0020\u0074h\u0065\u0020r\u0061\u006e\u0067\u0065\u0020\u005b0\u002c\u00325\u0035\u005d")
	}
	return MakeStringResult(_b.Sprintf("\u0025\u0063", _fggec))
}

// FactDouble is an implementation of the excel FACTDOUBLE function which
// returns the double factorial of a positive numeric input.
func FactDouble(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0046\u0041C\u0054\u0044\u004f\u0055\u0042\u004c\u0045\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bdgdg := args[0].AsNumber()
	if _bdgdg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0041C\u0054\u0044\u004f\u0055\u0042\u004c\u0045\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _bdgdg.ValueNumber < 0 {
		return MakeErrorResult("\u0046A\u0043\u0054D\u004f\u0055\u0042\u004cE\u0028\u0029\u0020a\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006f\u006ely\u0020\u0070\u006fs\u0069\u0074i\u0076\u0065\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_dffgd := float64(1)
	_aade := _gg.Trunc(_bdgdg.ValueNumber)
	for _fefa := _aade; _fefa > 1; _fefa -= 2 {
		_dffgd *= _fefa
	}
	return MakeNumberResult(_dffgd)
}

// Yielddisc implements the Excel YIELDDISC function.
func Yielddisc(args []Result) Result {
	_agaaa := len(args)
	if _agaaa != 4 && _agaaa != 5 {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_edga, _deebg, _bcee := _daea(args[0], args[1], "\u0059I\u0045\u004c\u0044\u0044\u0049\u0053C")
	if _bcee.Type == ResultTypeError {
		return _bcee
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0044\u0049S\u0043\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eaba := args[2].ValueNumber
	if _eaba <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0049E\u004c\u0044\u0044\u0049\u0053C\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_bgbca := args[3].ValueNumber
	if _bgbca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "YI\u0045\u004cD\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076e\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072g\u0075m\u0065\u006et")
	}
	_fffa := 0
	if _agaaa == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0059\u0049E\u004c\u0044\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_fffa = int(args[4].ValueNumber)
		if !_efb(_fffa) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0059I\u0045\u004cD\u0044\u0049\u0053\u0043")
		}
	}
	_bfeca, _bcee := _cbfa(_edga, _deebg, _fffa)
	if _bcee.Type == ResultTypeError {
		return _bcee
	}
	return MakeNumberResult((_bgbca/_eaba - 1) / _bfeca)
}
func _ddfe(_ddce []Result, _aeabc bool) Result {
	var _egfdf string
	if _aeabc {
		_egfdf = "\u004c\u0041\u0052G\u0045"
	} else {
		_egfdf = "\u0053\u004d\u0041L\u004c"
	}
	if len(_ddce) != 2 {
		return MakeErrorResult(_egfdf + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dgea := _ddce[0]
	var _bagef [][]Result
	switch _dgea.Type {
	case ResultTypeArray:
		_bagef = _dgea.ValueArray
	case ResultTypeList:
		_bagef = [][]Result{_dgea.ValueList}
	default:
		return MakeErrorResult(_egfdf + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u006f\u0066\u0020\u0074\u0079p\u0065\u0020a\u0072\u0072\u0061\u0079")
	}
	if len(_bagef) == 0 {
		return MakeErrorResult(_egfdf + "\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0074\u006f\u0020c\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0031\u0020\u0072\u006f\u0077")
	}
	if _ddce[1].Type != ResultTypeNumber {
		return MakeErrorResult(_egfdf + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074yp\u0065\u0020\u006eu\u006db\u0065\u0072")
	}
	_dabe := _ddce[1].ValueNumber
	if _dabe < 1 {
		return MakeErrorResultType(ErrorTypeNum, _egfdf+"\u0020\u0072e\u0071\u0075\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006fn\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030")
	}
	_fbafa := int(_dabe)
	if float64(_fbafa) != _dabe {
		return MakeErrorResultType(ErrorTypeNum, _egfdf+"\u0020\u0072e\u0071\u0075\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006fn\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030")
	}
	_ecde := []float64{}
	for _, _agea := range _bagef {
		for _, _bcbg := range _agea {
			if _bcbg.Type == ResultTypeNumber {
				_ecde = append(_ecde, _bcbg.ValueNumber)
			}
		}
	}
	if _fbafa > len(_ecde) {
		return MakeErrorResultType(ErrorTypeNum, _egfdf+" \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u006c\u0065s\u0073\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u0068\u0061\u006e\u0020t\u0068\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072s\u0020\u0069\u006e\u0020t\u0068\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_fffg := _egc.MergeSort(_ecde)
	if _aeabc {
		return MakeNumberResult(_fffg[len(_fffg)-_fbafa])
	} else {
		return MakeNumberResult(_fffg[_fbafa-1])
	}
}

var _bcbfa = [...]int{0, -2, 1, 2, 0, 0, 0, 0, 11, 12, 13, 14, 0, 16, 5, 6, 7, 8, 22, 0, 24, 46, 0, 26, 25, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 18, 20, 9, 10, 0, 0, 23, 32, 33, 47, 0, 49, 51, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 0, 17, 0, 0, 15, 27, 0, 48, 53, 4, 19, 21, 28, 50, 52}

type cumulArgs struct {
	_ebca float64
	_deb  float64
	_fcad float64
	_bgff float64
	_eccd float64
	_aaac int
}

// Amorlinc implements the Excel AMORLINC function.
func Amorlinc(args []Result) Result {
	_cegf, _gfdb := _ffed(args, "\u0041\u004d\u004f\u0052\u004c\u0049\u004e\u0043")
	if _gfdb.Type == ResultTypeError {
		return _gfdb
	}
	_eccac := _cegf._fgb
	_fbab := _cegf._bggd
	_cacg := _cegf._gagfe
	_eedc := _cegf._cggf
	_gdcg := _cegf._cdgcc
	_cda := _cegf._baca
	_gbg := _cegf._fcfd
	_fdd, _eaege := _cbfa(_fbab, _cacg, _gbg)
	if _eaege.Type == ResultTypeError {
		return MakeErrorResult("\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0065\u0073 \u0066o\u0072\u0020\u0041\u004d\u004f\u0052\u004cI\u004e\u0043")
	}
	_geea := _fdd * _cda * _eccac
	if _gdcg == 0 {
		return MakeNumberResult(_geea)
	}
	_efae := _eccac * _cda
	_eggdc := _eccac - _eedc
	_ded := int((_eggdc - _geea) / _efae)
	if _gdcg <= _ded {
		return MakeNumberResult(_efae)
	} else if _gdcg == _ded+1 {
		return MakeNumberResult(_eggdc - _efae*float64(_ded) - _geea)
	} else {
		return MakeNumberResult(0)
	}
}

// NewBinaryExpr constructs a new binary expression with a given operator.
func NewBinaryExpr(lhs Expression, op BinOpType, rhs Expression) Expression {
	return BinaryExpr{lhs, rhs, op}
}

// String returns a string representation of a vertical range with prefix.
func (_bbcef PrefixVerticalRange) String() string {
	return _b.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _bbcef._ccea.String(), _bbcef._fbedd, _bbcef._gacbg)
}

const _fffab = "\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070\u0065\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070\u0065\u0043\u0065\u006c\u006c\u0052\u0065\u0066\u0065r\u0065\u006ec\u0065\u0054\u0079\u0070e\u004e\u0061\u006d\u0065\u0064\u0052\u0061\u006e\u0067\u0065R\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054y\u0070\u0065\u0052\u0061\u006e\u0067\u0065\u0052\u0065\u0066e\u0072\u0065\u006ec\u0065\u0054\u0079\u0070\u0065\u0053\u0068e\u0065\u0074"

// Day is an implementation of the Excel DAY() function.
func Day(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0044A\u0059\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_bbg := args[0]
	switch _bbg.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(0)
	case ResultTypeNumber:
		_abaa := _ddef(_bbg.ValueNumber)
		return MakeNumberResult(float64(_abaa.Day()))
	case ResultTypeString:
		_afa := _fa.ToLower(_bbg.ValueString)
		if !_ede(_afa) {
			_, _, _, _, _bfd, _gdf := _cgfb(_afa)
			if _gdf.Type == ResultTypeError {
				_gdf.ErrorMessage = "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073\u0020\u0066o\u0072 \u0044\u0041\u0059"
				return _gdf
			}
			if _bfd {
				return MakeNumberResult(0)
			}
		}
		_, _, _adcg, _, _bcf := _dbbf(_afa)
		if _bcf.Type == ResultTypeError {
			return _bcf
		}
		return MakeNumberResult(float64(_adcg))
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072 \u0044\u0041\u0059")
	}
}

// Db implements the Excel DB function.
func Db(args []Result) Result {
	_aacfd := len(args)
	if _aacfd != 4 && _aacfd != 5 {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u006f\u0072 \u0066\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0063\u006f\u0073\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cafee := args[0].ValueNumber
	if _cafee < 0 {
		return MakeErrorResultType(ErrorTypeNum, "D\u0042\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0063\u006fs\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aecac := args[1].ValueNumber
	if _aecac < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069\u0066\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bdde := args[2].ValueNumber
	if _bdde <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006c\u0069\u0066\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("D\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_ebce := args[3].ValueNumber
	if _ebce <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	if _ebce-_bdde > 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0042")
	}
	_gafc := 12.0
	if _aacfd == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006do\u006e\u0074\u0068\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_gafc = args[4].ValueNumber
		if _gafc < 1 || _gafc > 12 {
			return MakeErrorResultType(ErrorTypeNum, "\u0044B\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u006do\u006e\u0074\u0068\u0020\u0074\u006f\u0020\u0062\u0065 i\u006e\u0020\u0072a\u006e\u0067e\u0020\u006f\u0066\u0020\u0031\u0020a\u006e\u0064 \u0031\u0032")
		}
	}
	if _gafc == 12 && _ebce > _bdde {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0042")
	}
	if _aecac >= _cafee {
		return MakeNumberResult(0)
	}
	_egad := 1 - _gg.Pow(_aecac/_cafee, 1/_bdde)
	_egad = float64(int(_egad*1000+0.5)) / 1000
	_dcgg := _cafee * _egad * _gafc / 12
	if _ebce == 1 {
		return MakeNumberResult(_dcgg)
	}
	_dcde := _dcgg
	_dfab := 0.0
	_eccgf := _bdde
	if _eccgf > _ebce {
		_eccgf = _ebce
	}
	for _gbda := 2.0; _gbda <= _eccgf; _gbda++ {
		_dfab = (_cafee - _dcde) * _egad
		_dcde += _dfab
	}
	if _ebce > _bdde {
		return MakeNumberResult((_cafee - _dcde) * _egad * (12 - _gafc) / 12)
	}
	return MakeNumberResult(_dfab)
}

const _ffccc = 57356

// Eval evaluates and returns a string.
func (_dgecg String) Eval(ctx Context, ev Evaluator) Result { return MakeStringResult(_dgecg._cabg) }

// Eval evaluates a range with prefix returning a list of results or an error.
func (_cagd PrefixRangeExpr) Eval(ctx Context, ev Evaluator) Result {
	_eccb := _cagd._cbcc.Reference(ctx, ev)
	_cfea := _cagd._dgcf.Reference(ctx, ev)
	_agbdf := _cagd._ccefe.Reference(ctx, ev)
	switch _eccb.Type {
	case ReferenceTypeSheet:
		_gegc := _dcef(_eccb, _cfea, _agbdf)
		if _cfea.Type == ReferenceTypeCell && _agbdf.Type == ReferenceTypeCell {
			if _dfeee, _bfdca := ev.GetFromCache(_gegc); _bfdca {
				return _dfeee
			} else {
				_fcfdc := _bdgac(ctx.Sheet(_eccb.Value), ev, _cfea.Value, _agbdf.Value)
				ev.SetCache(_gegc, _fcfdc)
				return _fcfdc
			}
		}
		return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072a\u006e\u0067\u0065\u0020" + _gegc)
	default:
		return MakeErrorResult(_b.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _eccb.Type))
	}
}
func _degc(_cgbe float64) bool { return _cgbe == 1 || _cgbe == 2 || _cgbe == 4 }

type ivr struct{}

// Reference returns an invalid reference for FunctionCall.
func (_fbafbf FunctionCall) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

const _aegg = 57359

// Reference returns a string reference value to a range.
func (_eeda Range) Reference(ctx Context, ev Evaluator) Reference {
	_fafd := _eeda._ecgg.Reference(ctx, ev)
	_cefe := _eeda._bgfde.Reference(ctx, ev)
	if _fafd.Type == ReferenceTypeCell && _cefe.Type == ReferenceTypeCell {
		return MakeRangeReference(_ddad(_fafd, _cefe))
	}
	return ReferenceInvalid
}

// Find is an implementation of the Excel FIND().
func Find(args []Result) Result {
	_bgcg, _dedf := _gfag("\u0046\u0049\u004e\u0044", args)
	if _dedf.Type != ResultTypeEmpty {
		return _dedf
	}
	_dgffg := _bgcg._fcac
	if _dgffg == "" {
		return MakeNumberResult(1.0)
	}
	_bddg := _bgcg._edegc
	_ebfe := _bgcg._edafc
	_ebdg := 1
	for _aceb := range _bddg {
		if _ebdg < _ebfe {
			_ebdg++
			continue
		}
		_gbbgc := _fa.Index(_bddg[_aceb:], _dgffg)
		if _gbbgc == 0 {
			return MakeNumberResult(float64(_ebdg))
		}
		_ebdg++
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// NewNegate constructs a new negate expression.
func NewNegate(e Expression) Expression { return Negate{e} }

// Xirr implements the Excel XIRR function.
func Xirr(args []Result) Result {
	_ccfbd := len(args)
	if _ccfbd != 2 && _ccfbd != 3 {
		return MakeErrorResult("\u0058\u0049RR\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0077o \u006f\u0072\u0020\u0074\u0068\u0072\u0065e \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_bgaac, _cgec := _cdaa(args[0], args[1], "\u0058\u0049\u0052\u0052")
	if _cgec.Type == ResultTypeError {
		return _cgec
	}
	_gedb := _bgaac._gaed
	_adfe := _bgaac._fbbee
	_gbgg := 0.1
	if _ccfbd == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("\u0058\u0049\u0052\u0052\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gbgg = args[2].ValueNumber
		if _gbgg <= -1 {
			return MakeErrorResult("\u0058\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020\u0074\u006f\u0020\u0062e\u0020\u006d\u006f\u0072\u0065 \u0074\u0068a\u006e\u0020\u002d\u0031")
		}
	}
	return _afc(_gedb, _adfe, _gbgg)
}

// NewFunction constructs a new function call expression.
func NewFunction(name string, args []Expression) Expression { return FunctionCall{name, args} }

// String returns a string representation of ConstArrayExpr.
func (_dc ConstArrayExpr) String() string { return "" }

// Dollarde implements the Excel DOLLARDE function.
func Dollarde(args []Result) Result {
	_dede, _bcba, _ecac := _dcggb(args, "\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045")
	if _ecac.Type == ResultTypeError {
		return _ecac
	}
	if _bcba < 1 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072a\u0063t\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u006f\u0072 \u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0031")
	}
	if _dede == 0 {
		return MakeNumberResult(0)
	}
	_daga := _dede < 0
	if _daga {
		_dede = -_dede
	}
	_aagd := args[0].Value()
	_fgdb := _fa.Split(_aagd, "\u002e")
	_fefd := float64(int(_dede))
	_cfcd := _fgdb[1]
	_cbac := len(_cfcd)
	_bgee := int(_gg.Log10(_bcba)) + 1
	_efgea := float64(_bgee - _cbac)
	_acd, _cbcb := _ga.ParseFloat(_cfcd, 64)
	if _cbcb != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006fr \u0044\u004f\u004cL\u0041R\u0044\u0045")
	}
	_acd *= _gg.Pow(10, _efgea)
	_cfbf := _fefd + _acd/_bcba
	if _daga {
		_cfbf = -_cfbf
	}
	return MakeNumberResult(_cfbf)
}

// Eval evaluates and returns the result of a formula.
func (_gde *defEval) Eval(ctx Context, formula string) Result {
	_ddd := ParseString(formula)
	if _ddd != nil {
		_gde.checkLastEvalIsRef(ctx, _ddd)
		_cbc := _ddd.Eval(ctx, _gde)
		return _cbc
	}
	return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070a\u0072\u0073\u0065\u0020\u0066\u006f\u0072\u006d\u0075\u006ca\u0020\u0025\u0073", formula))
}

const _gecde = 57358

func NewLexer() *Lexer { return &Lexer{_fggf: make(chan *node)} }

// Eval evaluates and returns a number.
func (_gcdab Number) Eval(ctx Context, ev Evaluator) Result { return MakeNumberResult(_gcdab._bgbaf) }

// BinOpType is the binary operation operator type
//go:generate stringer -type=BinOpType
type BinOpType byte

// Eval evaluates and returns the result of the NamedRangeRef reference.
func (_eecd NamedRangeRef) Eval(ctx Context, ev Evaluator) Result {
	_efca := ctx.NamedRange(_eecd._daega)
	_faacga := _efca.Value
	if _deag, _fcdff := ev.GetFromCache(_faacga); _fcdff {
		return _deag
	}
	_gbabg := _fa.Split(_faacga, "\u0021")
	if len(_gbabg) != 2 {
		return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006e\u0061\u006de\u0064 \u0072\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0025\u0073", _faacga))
	}
	_fbgeb := ctx.Sheet(_gbabg[0])
	_ecgfe := _fa.Split(_gbabg[1], "\u003a")
	switch len(_ecgfe) {
	case 1:
		_aeaa := ev.Eval(_fbgeb, _ecgfe[0])
		ev.SetCache(_faacga, _aeaa)
		return _aeaa
	case 2:
		_ecdfb := _bdgac(_fbgeb, ev, _ecgfe[0], _ecgfe[1])
		ev.SetCache(_faacga, _ecdfb)
		return _ecdfb
	}
	return MakeErrorResult(_b.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070e \u0025\u0073", _efca.Type))
}

// ISNONTEXT is an implementation of the Excel ISNONTEXT() function.
func IsNonText(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053N\u004f\u004e\u0054\u0045X\u0054\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073 \u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type != ResultTypeString)
}

const _gefb = 187

// Number is a nubmer expression.
type Number struct{ _bgbaf float64 }

// Update returns the same object as updating sheet references does not affect Error.
func (_efa Error) Update(q *_egg.UpdateQuery) Expression { return _efa }

const _efgag = 57349

func _ddad(_gafcc, _gfdgg Reference) string {
	return _b.Sprintf("\u0025\u0073\u003a%\u0073", _gafcc.Value, _gfdgg.Value)
}

// SumIfs implements the SUMIFS function.
func SumIfs(args []Result) Result {
	_geebe := _ddaa(args, true, "\u0053\u0055\u004d\u0049\u0046\u0053")
	if _geebe.Type != ResultTypeEmpty {
		return _geebe
	}
	_fefb := _agge(args[1:])
	_dddba := 0.0
	_edgb := _aefda(args[0])
	for _, _dgab := range _fefb {
		_dddba += _edgb[_dgab._bgdb][_dgab._afcc].ValueNumber
	}
	return MakeNumberResult(float64(_dddba))
}

const _bbec = 57377

// Eval evaluates and returns the result of a constant array expression.
func (_gge ConstArrayExpr) Eval(ctx Context, ev Evaluator) Result {
	_bbd := [][]Result{}
	for _, _bgf := range _gge._dd {
		_gec := []Result{}
		for _, _ccbf := range _bgf {
			_gec = append(_gec, _ccbf.Eval(ctx, ev))
		}
		_bbd = append(_bbd, _gec)
	}
	return MakeArrayResult(_bbd)
}

// Lookup implements the LOOKUP function that returns a matching value from a
// column, or from the same index in a second column.
func Lookup(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0061\u0074\u0020\u006do\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_fbbaac := args[0]
	_gcec := args[1]
	if _gcec.Type != ResultTypeArray && _gcec.Type != ResultTypeList {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_bcgb := _ebfbc(_gcec)
	_cdge := -1
	for _cfge, _gbfeg := range _bcgb {
		if _fbae(_fbbaac, _gbfeg, false, false) == _gabde {
			_cdge = _cfge
		}
	}
	if _cdge == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u004c\u004f\u004f\u004bUP\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075n\u0064")
	}
	_fgge := _bcgb
	if len(args) == 3 {
		_fgge = _ebfbc(args[2])
	}
	if _cdge < 0 || _cdge >= len(_fgge) {
		return MakeErrorResultType(ErrorTypeNA, "\u004c\u004f\u004f\u004bUP\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075n\u0064")
	}
	return _fgge[_cdge]
}

// ISTEXT is an implementation of the Excel ISTEXT() function.
func IsText(args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053\u0054EX\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070t\u0073 \u0061 \u0073i\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeString)
}

var _egdd = [...]uint8{0, 17, 33, 49, 63, 78, 93, 108}

// NewPrefixExpr constructs an expression with prefix.
func NewPrefixExpr(pfx, exp Expression) Expression { return &PrefixExpr{pfx, exp} }
func _ddef(_cbf float64) _ea.Time {
	_dfge := int64((_cbf - _dcc) * _ecc)
	return _ea.Unix(0, _dfge).UTC()
}

var _bac = [...]uint8{0, 16, 29, 43, 56, 68, 80, 91, 102, 113, 125, 137, 148, 163}

func _aedf(_fbaee Result, _bdag, _bcad int) [][]Result {
	_ffcb := [][]Result{}
	switch _fbaee.Type {
	case ResultTypeArray:
		for _dfabf, _bdgc := range _fbaee.ValueArray {
			if _dfabf < _bdag {
				_ffcb = append(_ffcb, _cfff(MakeListResult(_bdgc), _bcad))
			} else {
				_ffcb = append(_ffcb, _cfff(MakeErrorResultType(ErrorTypeNA, ""), _bcad))
			}
		}
	case ResultTypeList:
		_edfg := _cfff(_fbaee, _bcad)
		for _ecaf := 0; _ecaf < _bdag; _ecaf++ {
			_ffcb = append(_ffcb, _edfg)
		}
	case ResultTypeNumber, ResultTypeString, ResultTypeError, ResultTypeEmpty:
		for _febca := 0; _febca < _bdag; _febca++ {
			_dged := _cfff(_fbaee, _bcad)
			_ffcb = append(_ffcb, _dged)
		}
	}
	return _ffcb
}

// CountBlank implements the COUNTBLANK function.
func CountBlank(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043\u004f\u0055N\u0054\u0042\u004c\u0041N\u004b\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(_gcfe(args, _geaa))
}

// MakeArrayResult constructs an array result (matrix).
func MakeArrayResult(arr [][]Result) Result { return Result{Type: ResultTypeArray, ValueArray: arr} }

// Text is an implementation of the Excel TEXT function.
func Text(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("T\u0045\u0058\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	_fcec := args[0]
	if _fcec.Type != ResultTypeNumber && _fcec.Type != ResultTypeString && _fcec.Type != ResultTypeEmpty {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	if args[1].Type != ResultTypeString {
		return MakeErrorResult("\u0054E\u0058\u0054 \u0072\u0065\u0071\u0075i\u0072\u0065\u0073 \u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072gu\u006d\u0065\u006et\u0020\u0074o\u0020\u0062\u0065\u0020\u0061\u0020s\u0074\u0072i\u006e\u0067")
	}
	_dfaaa := args[1].ValueString
	switch _fcec.Type {
	case ResultTypeNumber:
		return MakeStringResult(_c.Number(_fcec.ValueNumber, _dfaaa))
	case ResultTypeString:
		return MakeStringResult(_c.String(_fcec.ValueString, _dfaaa))
	case ResultTypeEmpty:
		return MakeStringResult(_c.Number(0, _dfaaa))
	case ResultTypeArray, ResultTypeList:
		return MakeErrorResultType(ErrorTypeSpill, "\u0054\u0045X\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0077\u006f\u0072\u006b\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u0072ra\u0079\u0073")
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020T\u0045\u0058\u0054")
	}
}

const _dbdd = "\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u005c\u002e\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u0028\u0020(\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

// Time is an implementation of the Excel TIME() function.
func Time(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0049ME\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0068re\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_fcab := args[0].ValueNumber
	_bgda := args[1].ValueNumber
	_adcb := args[2].ValueNumber
	_fgc := _dgc(_fcab, _bgda, _adcb)
	if _fgc >= 0 {
		return MakeNumberResult(_fgc)
	} else {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
}

var _fgbbc = []ri{{1000, "\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {95, "\u0056\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

func _bfage(_fdgg []string, _cdfe int) string { return _ga.Itoa(len(_fdgg[len(_fdgg)-1-_cdfe])) }

var _ccbd = [...]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

func _ebfbc(_efef Result) []Result {
	_cdaf := _efef.ValueList
	if _efef.Type == ResultTypeArray {
		_cdaf = nil
		for _, _abbg := range _efef.ValueArray {
			if len(_abbg) > 0 {
				_cdaf = append(_cdaf, _abbg[0])
			} else {
				_cdaf = append(_cdaf, _aaa)
			}
		}
	}
	return _cdaf
}
func _dcggb(_dddc []Result, _cdea string) (float64, float64, Result) {
	if len(_dddc) != 2 {
		return 0, 0, MakeErrorResult(_cdea + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _dddc[0].Type != ResultTypeNumber {
		return 0, 0, MakeErrorResult(_cdea + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0061\u006c\u0020\u0064\u006f\u006c\u006c\u0061\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_gafg := _dddc[0].ValueNumber
	if _dddc[1].Type != ResultTypeNumber {
		return 0, 0, MakeErrorResult(_cdea + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_caa := float64(int(_dddc[1].ValueNumber))
	if _caa < 0 {
		return 0, 0, MakeErrorResultType(ErrorTypeNum, _cdea+"\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073 \u0066\u0072\u0061c\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062e \u006e\u006f\u006e \u006e\u0065g\u0061\u0074\u0069\u0076\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	return _gafg, _caa, _aaa
}

// AsNumber attempts to intepret a string cell value as a number. Upon success,
// it returns a new number result, upon  failure it returns the original result.
// This is used as functions return strings that can then act like number (e.g.
// LEFT(1.2345,3) + LEFT(1.2345,3) = 2.4)
func (_fbddd Result) AsNumber() Result {
	if _fbddd.Type == ResultTypeString {
		_geag, _geefa := _ga.ParseFloat(_fbddd.ValueString, 64)
		if _geefa == nil {
			return MakeNumberResult(_geag)
		}
	}
	if _fbddd.Type == ResultTypeEmpty {
		return MakeNumberResult(0)
	}
	return _fbddd
}

var _ebade = [...]string{"\u0024\u0065\u006e\u0064", "\u0065\u0072\u0072o\u0072", "\u0024\u0075\u006e\u006b", "t\u006fk\u0065\u006e\u0048\u006f\u0072\u0069\u007a\u006fn\u0074\u0061\u006c\u0052an\u0067\u0065", "\u0074o\u006be\u006e\u0056\u0065\u0072\u0074i\u0063\u0061l\u0052\u0061\u006e\u0067\u0065", "\u0074\u006f\u006b\u0065\u006e\u0052\u0065\u0073\u0065\u0072\u0076\u0065d\u004e\u0061\u006d\u0065", "\u0074\u006f\u006be\u006e\u0044\u0044\u0045\u0043\u0061\u006c\u006c", "\u0074\u006f\u006b\u0065\u006e\u004c\u0065\u0078\u0045\u0072\u0072\u006f\u0072", "\u0074o\u006be\u006e\u004e\u0061\u006d\u0065\u0064\u0052\u0061\u006e\u0067\u0065", "\u0074o\u006b\u0065\u006e\u0042\u006f\u006fl", "t\u006f\u006b\u0065\u006e\u004e\u0075\u006d\u0062\u0065\u0072", "t\u006f\u006b\u0065\u006e\u0053\u0074\u0072\u0069\u006e\u0067", "\u0074\u006f\u006b\u0065\u006e\u0045\u0072\u0072\u006f\u0072", "\u0074\u006f\u006b\u0065\u006e\u0045\u0072\u0072\u006f\u0072\u0052\u0065\u0066", "\u0074\u006f\u006b\u0065\u006e\u0053\u0068\u0065\u0065\u0074", "\u0074o\u006b\u0065\u006e\u0043\u0065\u006cl", "t\u006fk\u0065\u006e\u0046\u0075\u006e\u0063\u0074\u0069o\u006e\u0042\u0075\u0069lt\u0069\u006e", "t\u006f\u006b\u0065\u006e\u004c\u0042\u0072\u0061\u0063\u0065", "t\u006f\u006b\u0065\u006e\u0052\u0042\u0072\u0061\u0063\u0065", "t\u006f\u006b\u0065\u006e\u004c\u0050\u0061\u0072\u0065\u006e", "t\u006f\u006b\u0065\u006e\u0052\u0050\u0061\u0072\u0065\u006e", "\u0074o\u006b\u0065\u006e\u0050\u006c\u0075s", "\u0074\u006f\u006b\u0065\u006e\u004d\u0069\u006e\u0075\u0073", "\u0074o\u006b\u0065\u006e\u004d\u0075\u006ct", "\u0074\u006f\u006b\u0065\u006e\u0044\u0069\u0076", "\u0074\u006f\u006b\u0065\u006e\u0045\u0078\u0070", "\u0074o\u006b\u0065\u006e\u0045\u0051", "\u0074o\u006b\u0065\u006e\u004c\u0054", "\u0074o\u006b\u0065\u006e\u0047\u0054", "\u0074\u006f\u006b\u0065\u006e\u004c\u0045\u0051", "\u0074\u006f\u006b\u0065\u006e\u0047\u0045\u0051", "\u0074o\u006b\u0065\u006e\u004e\u0045", "\u0074\u006f\u006b\u0065\u006e\u0043\u006f\u006c\u006f\u006e", "\u0074\u006f\u006b\u0065\u006e\u0043\u006f\u006d\u006d\u0061", "\u0074\u006f\u006b\u0065\u006e\u0041\u006d\u0070\u0065r\u0073\u0061\u006e\u0064", "\u0074o\u006b\u0065\u006e\u0053\u0065\u006di"}

type plex struct {
	_edaga chan *node
	_gedbg Expression
}

// Update returns the same object as updating sheet references does not affect Bool.
func (_dbd Bool) Update(q *_egg.UpdateQuery) Expression { return _dbd }

const _edagc = 57378

type Expression interface {
	Eval(_gee Context, _gef Evaluator) Result
	Reference(_ebg Context, _ebfb Evaluator) Reference
	String() string
	Update(_adb *_egg.UpdateQuery) Expression
}

// NamedRangeRef is a reference to a named range.
type NamedRangeRef struct{ _daega string }

var _fbgf = map[string]*_af.Regexp{}
var _ddebg = map[string]FunctionComplex{}

func _eggg(_cgg, _gfc, _ggg, _ccc int) int {
	if _gfc > _ggg {
		return 0
	}
	if _ggc(_ccc) {
		return (_ggg - _gfc + 1) * 30
	}
	_egf := 0
	for _faaf := _gfc; _faaf <= _ggg; _faaf++ {
		_egf += _eccg(_cgg, _faaf)
	}
	return _egf
}

// Reference returns a string reference value to a cell.
func (_acac CellRef) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeCell, Value: _acac._dgd}
}
func _dddb(_cgae Result, _cffc, _gfdg string) (float64, Result) {
	var _cee float64
	switch _cgae.Type {
	case ResultTypeNumber:
		_cee = float64(int(_cgae.ValueNumber))
	case ResultTypeString:
		_dae := DateValue([]Result{_cgae})
		if _dae.Type == ResultTypeError {
			return 0, MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020" + _cffc + "\u0020\u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u0020" + _gfdg)
		}
		_cee = _dae.ValueNumber
	default:
		return 0, MakeErrorResult("\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020" + _gfdg)
	}
	if _cee < 0 {
		return 0, MakeErrorResultType(ErrorTypeNum, _cffc+"\u0020\u0073\u0068ou\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	return _cee, _aaa
}

var _ecfag = [...]string{}

// NewString constructs a new string expression.
func NewString(v string) Expression {
	v = _fa.Replace(v, "\u0022\u0022", "\u0022", -1)
	return String{v}
}

// Ddb implements the Excel DDB function.
func Ddb(args []Result) Result {
	_eec := len(args)
	if _eec != 4 && _eec != 5 {
		return MakeErrorResult("\u0044\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_aeab := args[0].ValueNumber
	if _aeab < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044B \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 co\u0073t \u0074\u006f\u0020\u0062\u0065\u0020\u006eon\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gcbab := args[1].ValueNumber
	if _gcbab < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cgcg := args[2].ValueNumber
	if _cgcg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dfe := args[3].ValueNumber
	if _dfe < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0070\u0065\u0072i\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065")
	}
	if _dfe > _cgcg {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072i\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0044\u0042")
	}
	_edfd := 2.0
	if _eec == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_edfd = args[4].ValueNumber
		if _edfd < 0 {
			return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
		}
	}
	return MakeNumberResult(_cdcfb(_aeab, _gcbab, _cgcg, _dfe, _edfd))
}

var _be = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

// NewError constructs a new error expression from a string.
func NewError(v string) Expression { return Error{v} }

// TimeValue is an implementation of the Excel TIMEVALUE() function.
func TimeValue(args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0054I\u004d\u0045V\u0041\u004c\u0055\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069ng\u006c\u0065\u0020s\u0074\u0072i\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_dcged := _fa.ToLower(args[0].ValueString)
	if !_eab(_dcged) {
		_, _, _, _gecg, _edcd := _dbbf(_dcged)
		if _edcd.Type == ResultTypeError {
			_edcd.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020f\u006f\u0072\u0020\u0054\u0049\u004d\u0045V\u0041\u004c\u0055\u0045"
			return _edcd
		}
		if _gecg {
			return MakeNumberResult(0)
		}
	}
	_agb, _ggbg, _geg, _bfab, _, _cecd := _cgfb(_dcged)
	if _cecd.Type == ResultTypeError {
		return _cecd
	}
	_eba := _dgc(float64(_agb), float64(_ggbg), _geg)
	if _bfab {
		_eba += 0.5
	} else if _eba >= 1 {
		_eba -= float64(int(_eba))
	}
	return MakeNumberResult(_eba)
}

// LastEvalIsRef returns if last evaluation with the evaluator was a reference.
func (_cgf *defEval) LastEvalIsRef() bool { return _cgf._ccf }

// String returns an empty string for Error.
func (_egdf Error) String() string { return "" }

// Eval evaluates and returns the result of the cell reference.
func (_fce CellRef) Eval(ctx Context, ev Evaluator) Result { return ctx.Cell(_fce._dgd, ev) }

// String returns a string representation of a named range.
func (_bdbc NamedRangeRef) String() string { return _bdbc._daega }

// Upper is an implementation of the Excel UPPER function that returns a upper
// case version of a string.
func Upper(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0055\u0050\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ebdgc := args[0].AsString()
	if _ebdgc.Type != ResultTypeString {
		return MakeErrorResult("\u0055\u0050\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeStringResult(_fa.ToUpper(_ebdgc.ValueString))
}
func _ecacb(_agfc string, _gcccc func(_ebbg float64) float64) Function {
	return func(_decda []Result) Result {
		if len(_decda) != 1 {
			return MakeErrorResult(_agfc + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_fgbec := _decda[0].AsNumber()
		switch _fgbec.Type {
		case ResultTypeNumber:
			_cgeb := _gcccc(_fgbec.ValueNumber)
			if _gg.IsNaN(_cgeb) {
				return MakeErrorResult(_agfc + "\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0065\u0064\u0020\u004e\u0061\u004e")
			}
			if _gg.IsInf(_cgeb, 0) {
				return MakeErrorResult(_agfc + "\u0020r\u0065t\u0075\u0072\u006e\u0065\u0064 \u0069\u006ef\u0069\u006e\u0069\u0074\u0079")
			}
			return MakeNumberResult(_cgeb)
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult(_agfc + "\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072i\u0063\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		case ResultTypeError:
			return _fgbec
		default:
			return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0068a\u006e\u0064\u006c\u0065d\u0020\u0025\u0073\u0028\u0029\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _agfc, _fgbec.Type))
		}
	}
}

var _dcc float64 = 25569.0

// Yieldmat implements the Excel YIELDMAT function.
func Yieldmat(args []Result) Result {
	_fcbc := len(args)
	if _fcbc != 5 && _fcbc != 6 {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0069v\u0065\u0020\u006f\u0072\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_gbfee, _fgcg, _bfccg := _daea(args[0], args[1], "\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054")
	if _bfccg.Type == ResultTypeError {
		return _bfccg
	}
	_eccda, _bfccg := _dddb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054")
	if _bfccg.Type == ResultTypeError {
		return _bfccg
	}
	if _eccda >= _gbfee {
		return MakeErrorResult("\u0059\u0049\u0045\u004cD\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0062\u0065\u0066\u006fr\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049E\u004c\u0044\u004d\u0041T\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_gfga := args[3].ValueNumber
	if _gfga < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0049\u0045\u004c\u0044M\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cgad := args[4].ValueNumber
	if _cgad <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "Y\u0049\u0045\u004c\u0044\u004d\u0041T\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0072\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069v\u0065")
	}
	_aef := 0
	if _fcbc == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0059I\u0045\u004cD\u004d\u0041\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_aef = int(args[5].ValueNumber)
		if !_efb(_aef) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0059\u0049\u0045L\u0044\u004d\u0041\u0054")
		}
	}
	_cagfg, _bfccg := _cbfa(_eccda, _fgcg, _aef)
	if _bfccg.Type == ResultTypeError {
		return _bfccg
	}
	_edggf, _bfccg := _cbfa(_eccda, _gbfee, _aef)
	if _bfccg.Type == ResultTypeError {
		return _bfccg
	}
	_aaagc, _bfccg := _cbfa(_gbfee, _fgcg, _aef)
	if _bfccg.Type == ResultTypeError {
		return _bfccg
	}
	_efafe := 1 + _cagfg*_gfga
	_efafe /= _cgad/100 + _edggf*_gfga
	_efafe--
	_efafe /= _aaagc
	return MakeNumberResult(_efafe)
}
func (_adef ReferenceType) String() string {
	if _adef >= ReferenceType(len(_fafcd)-1) {
		return _b.Sprintf("\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _adef)
	}
	return _fffab[_fafcd[_adef]:_fafcd[_adef+1]]
}

// Row implements the Excel ROW function.
func Row(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0052O\u0057\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_efaeb := args[0].Ref
	if _efaeb.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0052\u004f\u0057\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 a\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065n\u0063\u0065")
	}
	_fedc, _fgbd := _df.ParseCellReference(_efaeb.Value)
	if _fgbd != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _efaeb.Value)
	}
	return MakeNumberResult(float64(_fedc.RowIdx))
}

var _fdbd = [...]int{123, -1000, -1000, 74, 163, 103, 163, 163, -1000, -1000, -1000, -1000, 163, -1000, -1000, -1000, -1000, -1000, -12, 106, -1000, -1000, 143, -1000, -1000, -1000, -1000, -1000, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 74, 163, 163, 6, -28, 74, -15, -15, 60, 10, -14, -1000, -1000, -1000, 7, -1000, 74, -15, -15, -23, -23, -1000, -8, -8, -8, -8, -8, -8, -4, 33, -1000, 163, 163, -1000, -1000, 10, -1000, 163, -1000, -28, 74, -1000, -1000, 74}

// String is a string expression.
type String struct{ _cabg string }

const (
	_baead countMode = iota
	_fffb
	_geaa
)

func _bdeb(_cdcf, _bbcf _ea.Time, _aff int) float64 {
	if _cdcf.After(_bbcf) {
		_cdcf, _bbcf = _bbcf, _cdcf
	}
	_cdb := 0
	_gcae, _gbe, _afgcc := _cdcf.Date()
	_eed, _caf, _cfcb := _bbcf.Date()
	_bfdc, _abae := int(_gbe), int(_caf)
	_cbdd, _gfba := _cfa(_gcae, _bfdc, _afgcc, _aff), _cfa(_eed, _abae, _cfcb, _aff)
	if !_ggc(_aff) {
		return _fag(_eed, _abae, _gfba) - _fag(_gcae, _bfdc, _cbdd)
	}
	if _aff == 0 {
		if (_bfdc == 2 || _cbdd < 30) && _cfcb == 31 {
			_gfba = 31
		} else if _abae == 2 && _gfba == _eccg(_eed, _abae) {
			_gfba = _eccg(_eed, 2)
		}
	} else {
		if _bfdc == 2 && _cbdd == 30 {
			_cbdd = _eccg(_gcae, 2)
		}
		if _abae == 2 && _gfba == 30 {
			_gfba = _eccg(_eed, 2)
		}
	}
	if _gcae < _eed || (_gcae == _eed && _bfdc < _abae) {
		_cdb = 30 - _cbdd + 1
		_afgcc = 1
		_cbdd = 1
		_fgaf := _ea.Date(_gcae, _ea.Month(_bfdc), _afgcc, 0, 0, 0, 0, _ea.UTC).AddDate(0, 1, 0)
		if _fgaf.Year() < _eed {
			_cdb += _eggg(_fgaf.Year(), int(_fgaf.Month()), 12, _aff)
			_fgaf = _fgaf.AddDate(0, 13-int(_fgaf.Month()), 0)
			_cdb += _abdg(_fgaf.Year(), _eed-1, _aff)
		}
		_cdb += _eggg(_eed, int(_fgaf.Month()), _abae-1, _aff)
		_fgaf = _fgaf.AddDate(0, _abae-int(_fgaf.Month()), 0)
		_bfdc = _fgaf.Day()
	}
	_cdb += _gfba - _cbdd
	if _cdb > 0 {
		return float64(_cdb)
	} else {
		return 0
	}
}
func Unicode(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004fD\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gfcf := args[0].AsString()
	if _gfcf.Type != ResultTypeString {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004fD\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(_gfcf.ValueString) == 0 {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004f\u0044\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 \u0061\u0020\u006e\u006f\u006e\u002d\u007a\u0065\u0072\u006f\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(float64(_gfcf.ValueString[0]))
}

// DateValue is an implementation of the Excel DATEVALUE() function.
func DateValue(args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0044A\u0054\u0045V\u0041\u004c\u0055\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069ng\u006c\u0065\u0020s\u0074\u0072i\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_gbde := _fa.ToLower(args[0].ValueString)
	if !_ede(_gbde) {
		_, _, _, _, _aad, _afe := _cgfb(_gbde)
		if _afe.Type == ResultTypeError {
			_afe.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020f\u006f\u0072\u0020\u0044\u0041\u0054\u0045V\u0041\u004c\u0055\u0045"
			return _afe
		}
		if _aad {
			return MakeNumberResult(0)
		}
	}
	_cbd, _gaea, _bfag, _, _gcba := _dbbf(_gbde)
	if _gcba.Type == ResultTypeError {
		return _gcba
	}
	return MakeNumberResult(_fag(_cbd, _gaea, _bfag))
}

// Update updates references in the BinaryExpr after removing a row/column.
func (_acc BinaryExpr) Update(q *_egg.UpdateQuery) Expression {
	_gb := _acc
	_gb._ag = _acc._ag.Update(q)
	_gb._bd = _acc._bd.Update(q)
	return _gb
}

// GetFilename returns an empty string for the invalid reference context.
func (_ccecc *ivr) GetFilename() string { return "" }

type criteriaRegex struct {
	_dgbebb byte
	_cbcgcc string
}

// Accrintm implements the Excel ACCRINTM function.
func Accrintm(args []Result) Result {
	_cfca := len(args)
	if _cfca != 4 && _cfca != 5 {
		return MakeErrorResult("A\u0043\u0043\u0052\u0049\u004e\u0054\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066o\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_gaac, _ddcg := _dddb(args[0], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d")
	if _ddcg.Type == ResultTypeError {
		return _ddcg
	}
	_dfgee, _ddcg := _dddb(args[1], "\u0073e\u0074t\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065", "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d")
	if _ddcg.Type == ResultTypeError {
		return _ddcg
	}
	if _gaac >= _dfgee {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0073\u0073\u0075\u0065\u0020d\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0065\u0061\u0072\u006c\u0069\u0065r\u0020\u0074\u0068\u0061\u006e\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065n\u0074 \u0064\u0061\u0074\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0041C\u0043\u0052I\u004e\u0054\u004d\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_bge := args[2].ValueNumber
	if _bge <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061t\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0041\u0043\u0043\u0052\u0049\u004e\u0054M\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0070\u0061\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_adee := args[3].ValueNumber
	if _adee <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u0043C\u0052\u0049\u004e\u0054\u004d \u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0061\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_adg := 0
	if _cfca == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0041C\u0043\u0052I\u004e\u0054\u004d \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_adg = int(args[4].ValueNumber)
		if !_efb(_adg) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0041\u0043\u0043R\u0049\u004e\u0054\u004d")
		}
	}
	_gaba, _ddcg := _cbfa(_gaac, _dfgee, _adg)
	if _ddcg.Type == ResultTypeError {
		return _ddcg
	}
	return MakeNumberResult(_adee * _bge * _gaba)
}

// Duration implements the Excel DURATION function.
func Duration(args []Result) Result {
	_bcab, _eeef := _aggbe(args, "\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e")
	if _eeef.Type == ResultTypeError {
		return _eeef
	}
	_fcgfa := _bcab._dade
	_cffcb := _bcab._ddfb
	_afde := _bcab._egcd
	_ecfa := _bcab._agabg
	_daf := _bcab._accf
	_cgdc := _bcab._afbc
	return _gffb(_fcgfa, _cffcb, _afde, _ecfa, _daf, _cgdc)
}

// Ifs is an implementation of the Excel IFS() function.
func Ifs(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("I\u0046\u0053\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061t\u0020\u006c\u0065\u0061\u0073\u0074\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	for _edgec := 0; _edgec < len(args)-1; _edgec += 2 {
		if args[_edgec].ValueNumber == 1 {
			return args[_edgec+1]
		}
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}
func _agge(_dbaff []Result) []rangeIndex {
	_cdegg := []rangeIndex{}
	_dfaf := len(_dbaff)
	for _cadef := 0; _cadef < _dfaf-1; _cadef += 2 {
		_bbbee := []rangeIndex{}
		_bbdad := _aefda(_dbaff[_cadef])
		_bbacf := _adebe(_dbaff[_cadef+1])
		if _cadef == 0 {
			for _dfdf, _bgga := range _bbdad {
				for _cdba, _afeg := range _bgga {
					if _aefe(_afeg, _bbacf) {
						_bbbee = append(_bbbee, rangeIndex{_dfdf, _cdba})
					}
				}
			}
		} else {
			for _, _affc := range _cdegg {
				_abaecg := _bbdad[_affc._bgdb][_affc._afcc]
				if _aefe(_abaecg, _bbacf) {
					_bbbee = append(_bbbee, _affc)
				}
			}
		}
		if len(_bbbee) == 0 {
			return []rangeIndex{}
		}
		_cdegg = _bbbee[:]
	}
	return _cdegg
}
func Parse(r _e.Reader) Expression {
	_abdcg := &plex{LexReader(r), nil}
	_cbbcb(_abdcg)
	return _abdcg._gedbg
}

const _gafee = 57353
const _bcg = _abg + "\u0020\u0028\u0028[0\u002d\u0039\u005d\u0029\u002b\u0029\u002c\u0020\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

var _eabad = [...]int{1}

func _fdge(_fda, _cca int) int {
	switch _cca {
	case 1:
		if _dbfd(_fda) {
			return 366
		} else {
			return 365
		}
	case 3:
		return 365
	default:
		return 360
	}
}

// Coupncd implements the Excel COUPNCD function.
func Coupncd(args []Result) Result {
	_fgfd, _abc := _gdgb(args, "\u0043O\u0055\u0050\u004e\u0043\u0044")
	if _abc.Type == ResultTypeError {
		return _abc
	}
	_agcfc := _ddef(_fgfd._eebf)
	_baed := _ddef(_fgfd._edge)
	_dfbgc := _fgfd._eda
	_gecd := _fcag(_agcfc, _baed, _dfbgc)
	_cbgf, _ffa, _gdfa := _gecd.Date()
	return MakeNumberResult(_fag(_cbgf, int(_ffa), _gdfa))
}
func _aagb(_begc, _edaf, _caggg, _facd, _agdd, _afbg float64, _eced int) (float64, Result) {
	_bccg := int(_afbg)
	_afdf := _efcg(_begc, _edaf, _bccg, _eced)
	_dce := _gfe(_begc, _edaf, _bccg, _eced) / _afdf
	_ceef, _fdeb := _cbge(_begc, _edaf, _bccg, _eced)
	if _fdeb.Type == ResultTypeError {
		return 0, _fdeb
	}
	_acbd := _fdf(_begc, _edaf, _bccg, _eced)
	_efee := _agdd / _gg.Pow(1+_facd/_afbg, _ceef-1+_dce)
	_efee -= 100 * _caggg / _afbg * _acbd / _afdf
	_fegd := 100 * _caggg / _afbg
	_eaa := 1 + _facd/_afbg
	for _adfb := 0.0; _adfb < _ceef; _adfb++ {
		_efee += _fegd / _gg.Pow(_eaa, _adfb+_dce)
	}
	return _efee, MakeEmptyResult()
}

// String returns a string representation of Number.
func (_gbdb Number) String() string { return _ga.FormatFloat(_gbdb._bgbaf, 'f', -1, 64) }

// IsBool returns false for the invalid reference context.
func (_gefae *ivr) IsBool(cellRef string) bool { return false }

// Indirect is an implementation of the Excel INDIRECT function that returns the
// contents of a cell.
func Indirect(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 && len(args) != 2 {
		return MakeErrorResult("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u006f\u0072 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_bfea := args[0].AsString()
	if _bfea.Type != ResultTypeString {
		return MakeErrorResult("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069r\u0073t\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066 \u0074\u0079\u0070\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	return ctx.Cell(_bfea.ValueString, ev)
}

// Eval evaluates and returns the result of a function call.
func (_fedb FunctionCall) Eval(ctx Context, ev Evaluator) Result {
	_gcece := LookupFunction(_fedb._eadcc)
	if _gcece != nil {
		_bdbaa := make([]Result, len(_fedb._aeef))
		for _gbgge, _ggbb := range _fedb._aeef {
			_bdbaa[_gbgge] = _ggbb.Eval(ctx, ev)
			_bdbaa[_gbgge].Ref = _ggbb.Reference(ctx, ev)
		}
		return _gcece(_bdbaa)
	}
	_cbcga := LookupFunctionComplex(_fedb._eadcc)
	if _cbcga != nil {
		_aacgg := make([]Result, len(_fedb._aeef))
		for _bgffe, _efce := range _fedb._aeef {
			_aacgg[_bgffe] = _efce.Eval(ctx, ev)
			_aacgg[_bgffe].Ref = _efce.Reference(ctx, ev)
		}
		return _cbcga(ctx, ev, _aacgg)
	}
	return MakeErrorResult("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0066\u0075\u006e\u0063t\u0069\u006f\u006e\u0020" + _fedb._eadcc)
}

// Negate is a negate expression like -A1.
type Negate struct{ _bddff Expression }

// ISFORMULA is an implementation of the Excel ISFORMULA() function.
func IsFormula(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		MakeErrorResult("\u0049\u0053F\u004f\u0052\u004d\u0055L\u0041\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073 \u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bccea := args[0].Ref
	if _bccea.Type != ReferenceTypeCell {
		return MakeErrorResult("I\u0053\u0046\u004f\u0052\u004d\u0055\u004c\u0041\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072\u0067\u0075\u006de\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	return MakeBoolResult(ctx.HasFormula(_bccea.Value))
}

type parsedReplaceObject struct {
	_edcdb string
	_acebg int
	_egfeg int
	_daee  string
}

// Update returns the same object as updating sheet references does not affect Number.
func (_adffa Number) Update(q *_egg.UpdateQuery) Expression { return _adffa }

// MakeEmptyResult is ued when parsing an empty argument.
func MakeEmptyResult() Result { return Result{Type: ResultTypeEmpty} }

// Eval evaluates and returns the result of a sheet expression.
func (_ffeed SheetPrefixExpr) Eval(ctx Context, ev Evaluator) Result {
	return MakeErrorResult("\u0073\u0068\u0065\u0065\u0074\u0020\u0070\u0072\u0065\u0066\u0069\u0078\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065r\u0020\u0062\u0065\u0020\u0065v\u0061\u006cu\u0061\u0074\u0065\u0064")
}
func (_aefddc *Lexer) emit(_cddag tokenType, _fcdb []byte) {
	if _aebeb {
		_b.Println("\u0065\u006d\u0069\u0074", _cddag, _edgab(string(_fcdb)))
	}
	_aefddc._fggf <- &node{_cddag, string(_fcdb)}
}
func _edea(_fggc []Result, _gddf []string, _dbcag bool) []string {
	for _, _dgec := range _fggc {
		switch _dgec.Type {
		case ResultTypeEmpty:
			if !_dbcag {
				_gddf = append(_gddf, "")
			}
		case ResultTypeString:
			if _dgec.ValueString != "" || !_dbcag {
				_gddf = append(_gddf, _dgec.ValueString)
			}
		case ResultTypeNumber:
			_gddf = append(_gddf, _dgec.Value())
		case ResultTypeList:
			_gddf = _adffc(_gddf, _edea(_dgec.ValueList, []string{}, _dbcag))
		case ResultTypeArray:
			for _, _adbab := range _dgec.ValueArray {
				_gddf = _adffc(_gddf, _edea(_adbab, []string{}, _dbcag))
			}
		}
	}
	return _gddf
}

// Reference returns an invalid reference for Bool.
func (_cgd Bool) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Intrate implements the Excel INTRATE function.
func Intrate(args []Result) Result {
	_dbe := len(args)
	if _dbe != 4 && _dbe != 5 {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0066\u006f\u0075r\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_deaf, _adab, _edec := _daea(args[0], args[1], "\u0049N\u0054\u0052\u0041\u0054\u0045")
	if _edec.Type == ResultTypeError {
		return _edec
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006e\u0076\u0065\u0073\u0074\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_aggba := args[2].ValueNumber
	if _aggba <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006e\u0076e\u0073\u0074\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_bdgfd := args[3].ValueNumber
	if _bdgfd <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064e\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	_dcbc := 0
	if _dbe == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0049N\u0054\u0052A\u0054\u0045\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
		}
		_dcbc = int(args[4].ValueNumber)
		if !_efb(_dcbc) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006eco\u0072\u0072\u0065c\u0074\u0020\u0062\u0061sis\u0020ar\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020\u0049\u004e\u0054\u0052\u0041T\u0045")
		}
	}
	_caac, _edec := _cbfa(_deaf, _adab, _dcbc)
	if _edec.Type == ResultTypeError {
		return _edec
	}
	return MakeNumberResult((_bdgfd - _aggba) / _aggba / _caac)
}
func _facb(_abcd, _agaa, _edff, _edgc float64, _fffd int) float64 {
	var _gacb float64
	if _abcd == 0 {
		_gacb = _edgc + _edff*_agaa
	} else {
		_gcda := _gg.Pow(1+_abcd, _agaa)
		if _fffd == 1 {
			_gacb = _edgc*_gcda + _edff*(1+_abcd)*(_gcda-1)/_abcd
		} else {
			_gacb = _edgc*_gcda + _edff*(_gcda-1)/_abcd
		}
	}
	return -_gacb
}

// Bool is a boolean expression.
type Bool struct{ _ccda bool }

func Sign(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0053\u0049\u0047\u004e(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_feeae := args[0].AsNumber()
	if _feeae.Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0049\u0047N(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020a\u0020n\u0075m\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _feeae.ValueNumber < 0 {
		return MakeNumberResult(-1)
	} else if _feeae.ValueNumber > 0 {
		return MakeNumberResult(1)
	}
	return MakeNumberResult(0)
}

// Update updates references in the PrefixExpr after removing a row/column.
func (_gbgaf PrefixExpr) Update(q *_egg.UpdateQuery) Expression {
	_bged := _gbgaf
	_geecd := _gbgaf._cafc.String()
	if _geecd == q.SheetToUpdate {
		_aagf := *q
		_aagf.UpdateCurrentSheet = true
		_bged._adda = _gbgaf._adda.Update(&_aagf)
	}
	return _bged
}

// IsLeapYear is an implementation of the Excel ISLEAPYEAR() function.
func IsLeapYear(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049S\u004c\u0045A\u0050\u0059\u0045\u0041R\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073in\u0067\u006c\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_beaa := ctx.GetEpoch()
	_adfg, _daeda := _eccgb(args[0].Value(), _beaa)
	if _daeda != nil {
		return MakeErrorResult("\u0049S\u004c\u0045A\u0050\u0059\u0045\u0041R\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073in\u0067\u006c\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_gfgg := _adfg.Year()
	return MakeBoolResult(_dbfd(_gfgg))
}
func (_bbdbdd *yyParserImpl) Parse(yylex yyLexer) int {
	var _dfba int
	var _dbdg yySymType
	var _edae []yySymType
	_ = _edae
	_feac := _bbdbdd._bdbge[:]
	Nerrs := 0
	Errflag := 0
	_bcfb := 0
	_bbdbdd._febg = -1
	_agbc := -1
	defer func() { _bcfb = -1; _bbdbdd._febg = -1; _agbc = -1 }()
	_gedd := -1
	goto _fcdf
_cdcc:
	return 0
_efaag:
	return 1
_fcdf:
	if _gfeg >= 4 {
		_b.Printf("\u0063\u0068\u0061\u0072\u0020\u0025\u0076\u0020\u0069n\u0020\u0025\u0076\u000a", _faafa(_agbc), _eedd(_bcfb))
	}
	_gedd++
	if _gedd >= len(_feac) {
		_fdacf := make([]yySymType, len(_feac)*2)
		copy(_fdacf, _feac)
		_feac = _fdacf
	}
	_feac[_gedd] = _dbdg
	_feac[_gedd]._ffdb = _bcfb
_ggadb:
	_dfba = _fdbd[_bcfb]
	if _dfba <= _deaa {
		goto _fcdge
	}
	if _bbdbdd._febg < 0 {
		_bbdbdd._febg, _agbc = _agcgb(yylex, &_bbdbdd._fgcde)
	}
	_dfba += _agbc
	if _dfba < 0 || _dfba >= _gefb {
		goto _fcdge
	}
	_dfba = _edbb[_dfba]
	if _gcfac[_dfba] == _agbc {
		_bbdbdd._febg = -1
		_agbc = -1
		_dbdg = _bbdbdd._fgcde
		_bcfb = _dfba
		if Errflag > 0 {
			Errflag--
		}
		goto _fcdf
	}
_fcdge:
	_dfba = _bcbfa[_bcfb]
	if _dfba == -2 {
		if _bbdbdd._febg < 0 {
			_bbdbdd._febg, _agbc = _agcgb(yylex, &_bbdbdd._fgcde)
		}
		_effac := 0
		for {
			if _ecbfc[_effac+0] == -1 && _ecbfc[_effac+1] == _bcfb {
				break
			}
			_effac += 2
		}
		for _effac += 2; ; _effac += 2 {
			_dfba = _ecbfc[_effac+0]
			if _dfba < 0 || _dfba == _agbc {
				break
			}
		}
		_dfba = _ecbfc[_effac+1]
		if _dfba < 0 {
			goto _cdcc
		}
	}
	if _dfba == 0 {
		switch Errflag {
		case 0:
			yylex.Error(_bddf(_bcfb, _agbc))
			Nerrs++
			if _gfeg >= 1 {
				_b.Printf("\u0025\u0073", _eedd(_bcfb))
				_b.Printf("\u0020\u0073\u0061\u0077\u0020\u0025\u0073\u000a", _faafa(_agbc))
			}
			fallthrough
		case 1, 2:
			Errflag = 3
			for _gedd >= 0 {
				_dfba = _fdbd[_feac[_gedd]._ffdb] + _cgbfg
				if _dfba >= 0 && _dfba < _gefb {
					_bcfb = _edbb[_dfba]
					if _gcfac[_bcfb] == _cgbfg {
						goto _fcdf
					}
				}
				if _gfeg >= 2 {
					_b.Printf("\u0065\u0072r\u006f\u0072\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u0070\u006f\u0070\u0073\u0020\u0073\u0074\u0061\u0074\u0065 %\u0064\u000a", _feac[_gedd]._ffdb)
				}
				_gedd--
			}
			goto _efaag
		case 3:
			if _gfeg >= 2 {
				_b.Printf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u0064\u0069s\u0063\u0061\u0072d\u0073 \u0025\u0073\u000a", _faafa(_agbc))
			}
			if _agbc == _cdee {
				goto _efaag
			}
			_bbdbdd._febg = -1
			_agbc = -1
			goto _ggadb
		}
	}
	if _gfeg >= 2 {
		_b.Printf("\u0072e\u0064u\u0063\u0065\u0020\u0025\u0076 \u0069\u006e:\u000a\u0009\u0025\u0076\u000a", _dfba, _eedd(_bcfb))
	}
	_ffef := _dfba
	_cabcfd := _gedd
	_ = _cabcfd
	_gedd -= _gdfaa[_dfba]
	if _gedd+1 >= len(_feac) {
		_dbceb := make([]yySymType, len(_feac)*2)
		copy(_dbceb, _feac)
		_feac = _dbceb
	}
	_dbdg = _feac[_gedd+1]
	_dfba = _faacg[_dfba]
	_gdfc := _bfaebg[_dfba]
	_eaeae := _gdfc + _feac[_gedd]._ffdb + 1
	if _eaeae >= _gefb {
		_bcfb = _edbb[_gdfc]
	} else {
		_bcfb = _edbb[_eaeae]
		if _gcfac[_bcfb] != -_dfba {
			_bcfb = _edbb[_gdfc]
		}
	}
	switch _ffef {
	case 1:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			yylex.(*plex)._gedbg = _dbdg._bgfd
		}
	case 3:
		_edae = _feac[_cabcfd-2 : _cabcfd+1]
		{
			_dbdg._bgfd = _edae[2]._bgfd
		}
	case 4:
		_edae = _feac[_cabcfd-4 : _cabcfd+1]
		{
		}
	case 5:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBool(_edae[1]._ddcb._bacgg)
		}
	case 6:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewNumber(_edae[1]._ddcb._bacgg)
		}
	case 7:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewString(_edae[1]._ddcb._bacgg)
		}
	case 8:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewError(_edae[1]._ddcb._bacgg)
		}
	case 9:
		_edae = _feac[_cabcfd-2 : _cabcfd+1]
		{
			_dbdg._bgfd = _edae[2]._bgfd
		}
	case 10:
		_edae = _feac[_cabcfd-2 : _cabcfd+1]
		{
			_dbdg._bgfd = NewNegate(_edae[2]._bgfd)
		}
	case 15:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = _edae[2]._bgfd
		}
	case 17:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewConstArrayExpr(_edae[2]._aaee)
		}
	case 18:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._aaee = append(_dbdg._aaee, _edae[1]._babdac)
		}
	case 19:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._aaee = append(_edae[1]._aaee, _edae[3]._babdac)
		}
	case 20:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._babdac = append(_dbdg._babdac, _edae[1]._bgfd)
		}
	case 21:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._babdac = append(_edae[1]._babdac, _edae[3]._bgfd)
		}
	case 23:
		_edae = _feac[_cabcfd-2 : _cabcfd+1]
		{
			_dbdg._bgfd = NewPrefixExpr(_edae[1]._bgfd, _edae[2]._bgfd)
		}
	case 25:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewSheetPrefixExpr(_edae[1]._ddcb._bacgg)
		}
	case 26:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewCellRef(_edae[1]._ddcb._bacgg)
		}
	case 27:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewRange(_edae[1]._bgfd, _edae[3]._bgfd)
		}
	case 28:
		_edae = _feac[_cabcfd-4 : _cabcfd+1]
		{
			_dbdg._bgfd = NewPrefixRangeExpr(_edae[1]._bgfd, _edae[2]._bgfd, _edae[4]._bgfd)
		}
	case 29:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewNamedRangeRef(_edae[1]._ddcb._bacgg)
		}
	case 30:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewHorizontalRange(_edae[1]._ddcb._bacgg)
		}
	case 31:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._bgfd = NewVerticalRange(_edae[1]._ddcb._bacgg)
		}
	case 32:
		_edae = _feac[_cabcfd-2 : _cabcfd+1]
		{
			_dbdg._bgfd = NewPrefixHorizontalRange(_edae[1]._bgfd, _edae[2]._ddcb._bacgg)
		}
	case 33:
		_edae = _feac[_cabcfd-2 : _cabcfd+1]
		{
			_dbdg._bgfd = NewPrefixVerticalRange(_edae[1]._bgfd, _edae[2]._ddcb._bacgg)
		}
	case 34:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypePlus, _edae[3]._bgfd)
		}
	case 35:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeMinus, _edae[3]._bgfd)
		}
	case 36:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeMult, _edae[3]._bgfd)
		}
	case 37:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeDiv, _edae[3]._bgfd)
		}
	case 38:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeExp, _edae[3]._bgfd)
		}
	case 39:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeLT, _edae[3]._bgfd)
		}
	case 40:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeGT, _edae[3]._bgfd)
		}
	case 41:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeLEQ, _edae[3]._bgfd)
		}
	case 42:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeGEQ, _edae[3]._bgfd)
		}
	case 43:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeEQ, _edae[3]._bgfd)
		}
	case 44:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeNE, _edae[3]._bgfd)
		}
	case 45:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewBinaryExpr(_edae[1]._bgfd, BinOpTypeConcat, _edae[3]._bgfd)
		}
	case 47:
		_edae = _feac[_cabcfd-2 : _cabcfd+1]
		{
			_dbdg._bgfd = NewFunction(_edae[1]._ddcb._bacgg, nil)
		}
	case 48:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._bgfd = NewFunction(_edae[1]._ddcb._bacgg, _edae[2]._babdac)
		}
	case 49:
		_edae = _feac[_cabcfd-1 : _cabcfd+1]
		{
			_dbdg._babdac = append(_dbdg._babdac, _edae[1]._bgfd)
		}
	case 50:
		_edae = _feac[_cabcfd-3 : _cabcfd+1]
		{
			_dbdg._babdac = append(_edae[1]._babdac, _edae[3]._bgfd)
		}
	case 53:
		_edae = _feac[_cabcfd-0 : _cabcfd+1]
		{
			_dbdg._bgfd = NewEmptyExpr()
		}
	}
	goto _fcdf
}
func _aacfa(_cgge, _ddgc, _baae, _degb, _dcgb float64, _caeb int) float64 {
	_fbfg := _dgfg(_cgge, _baae, _degb, _dcgb, _caeb)
	var _effe float64
	if _ddgc == 1 {
		if _caeb == 1 {
			_effe = 0
		} else {
			_effe = -_degb
		}
	} else {
		if _caeb == 1 {
			_effe = _facb(_cgge, _ddgc-2, _fbfg, _degb, 1) - _fbfg
		} else {
			_effe = _facb(_cgge, _ddgc-1, _fbfg, _degb, 0)
		}
	}
	return _effe * _cgge
}
func _cbge(_cea, _dcdg float64, _ebaa, _afea int) (float64, Result) {
	_degf, _eac := _ddef(_cea), _ddef(_dcdg)
	if _eac.After(_degf) {
		_bdbf := _efe(_degf, _eac, _ebaa, _afea)
		_cgag := (_eac.Year()-_bdbf.Year())*12 + int(_eac.Month()) - int(_bdbf.Month())
		return float64(_cgag*_ebaa) / 12.0, _aaa
	}
	return 0, MakeErrorResultType(ErrorTypeNum, "\u0053\u0065t\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065")
}

// SumProduct is an implementation of the Excel SUMPRODUCT() function.
func SumProduct(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004f\u0044U\u0043\u0054\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_baga := args[0].Type
	for _, _gcbae := range args {
		if _gcbae.Type != _baga {
			return MakeErrorResult("\u0053\u0055M\u0050\u0052\u004f\u0044\u0055C\u0054\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006c\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065\u0020\u0074\u0079\u0070\u0065")
		}
	}
	switch _baga {
	case ResultTypeNumber:
		return Product(args)
	case ResultTypeList, ResultTypeArray:
		_affd := len(args[0].ListValues())
		_cegac := make([]float64, _affd)
		for _fced := range _cegac {
			_cegac[_fced] = 1.0
		}
		for _, _gcea := range args {
			if len(_gcea.ListValues()) != _affd {
				return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004f\u0044\u0055\u0043\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069re\u0073 \u0061\u006c\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074s\u0020\u0074\u006f\u0020\u0068\u0061\u0076\u0065\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065 \u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006f\u006e")
			}
			for _gecdg, _gege := range _gcea.ListValues() {
				_gege = _gege.AsNumber()
				if _gege.Type != ResultTypeNumber {
					return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004fD\u0055\u0043\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006c\u006c\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020n\u0075m\u0065\u0072\u0069\u0063")
				}
				_cegac[_gecdg] = _cegac[_gecdg] * _gege.ValueNumber
			}
		}
		_gcfd := 0.0
		for _, _cdef := range _cegac {
			_gcfd += _cdef
		}
		return MakeNumberResult(_gcfd)
	}
	return MakeNumberResult(1.0)
}

// ListValues converts an array to a list or returns a lists values. This is used
// for functions that can accept an array, but don't care about ordering to
// reuse the list function logic.
func (_aeee Result) ListValues() []Result {
	if _aeee.Type == ResultTypeArray {
		_gbcfd := []Result{}
		for _, _gbag := range _aeee.ValueArray {
			for _, _cafd := range _gbag {
				_gbcfd = append(_gbcfd, _cafd)
			}
		}
		return _gbcfd
	}
	if _aeee.Type == ResultTypeList {
		return _aeee.ValueList
	}
	return nil
}

// Pi is an implementation of the Excel Pi() function that just returns the Pi
// constant.
func Pi(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0050I\u0028\u0029\u0020\u0061c\u0063\u0065\u0070\u0074\u0073 \u006eo\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s")
	}
	return MakeNumberResult(_gg.Pi)
}

// Update returns the same object as updating sheet references does not affect SheetPrefixExpr.
func (_eadac SheetPrefixExpr) Update(q *_egg.UpdateQuery) Expression { return _eadac }

// NewSheetPrefixExpr constructs a new prefix expression.
func NewSheetPrefixExpr(s string) Expression { return &SheetPrefixExpr{s} }

// Received implements the Excel RECEIVED function.
func Received(args []Result) Result {
	_bcdce := len(args)
	if _bcdce != 4 && _bcdce != 5 {
		return MakeErrorResult("R\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066o\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_fgg, _feaa, _dgaf := _daea(args[0], args[1], "\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044")
	if _dgaf.Type == ResultTypeError {
		return _dgaf
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020i\u006e\u0076\u0065\u0073\u0074\u006d\u0065n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bgge := args[2].ValueNumber
	if _bgge <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006ev\u0065\u0073\u0074\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044 \u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0064\u0069s\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_babc := args[3].ValueNumber
	if _babc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0045\u0043\u0045I\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020p\u006f\u0073\u0069\u0074\u0069v\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gcf := 0
	if _bcdce == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052E\u0043\u0045I\u0056\u0045\u0044 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gcf = int(args[4].ValueNumber)
		if !_efb(_gcf) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0052\u0045\u0043E\u0049\u0056\u0045\u0044")
		}
	}
	_faca, _dgaf := _cbfa(_fgg, _feaa, _gcf)
	if _dgaf.Type == ResultTypeError {
		return _dgaf
	}
	return MakeNumberResult(_bgge / (1 - _babc*_faca))
}
func _fbae(_egcf, _gaeda Result, _bfgd, _cbab bool) cmpResult {
	_egcf = _egcf.AsNumber()
	_gaeda = _gaeda.AsNumber()
	if _egcf.Type != _gaeda.Type {
		return _abef
	}
	if _egcf.Type == ResultTypeNumber {
		if _egcf.ValueNumber == _gaeda.ValueNumber {
			return _gabde
		}
		if _egcf.ValueNumber < _gaeda.ValueNumber {
			return _fceaf
		}
		return _cdgg
	}
	if _egcf.Type == ResultTypeString {
		_begea := _egcf.ValueString
		_fadd := _gaeda.ValueString
		if !_bfgd {
			_begea = _fa.ToLower(_begea)
			_fadd = _fa.ToLower(_fadd)
		}
		if _cbab {
			_eade := _d.Match(_fadd, _begea)
			if _eade {
				return _gabde
			} else {
				return _cdgg
			}
		}
		return cmpResult(_fa.Compare(_begea, _fadd))
	}
	if _egcf.Type == ResultTypeEmpty {
		return _gabde
	}
	if _egcf.Type == ResultTypeList {
		if len(_egcf.ValueList) < len(_gaeda.ValueList) {
			return _fceaf
		}
		if len(_egcf.ValueList) > len(_gaeda.ValueList) {
			return _cdgg
		}
		for _ggfg := range _egcf.ValueList {
			_dcag := _fbae(_egcf.ValueList[_ggfg], _gaeda.ValueList[_ggfg], _bfgd, _cbab)
			if _dcag != _gabde {
				return _dcag
			}
		}
		return _gabde
	}
	if _egcf.Type == ResultTypeList {
		if len(_egcf.ValueArray) < len(_gaeda.ValueArray) {
			return _fceaf
		}
		if len(_egcf.ValueArray) > len(_gaeda.ValueArray) {
			return _cdgg
		}
		for _egbag := range _egcf.ValueArray {
			_ccfe := _egcf.ValueArray[_egbag]
			_ffda := _egcf.ValueArray[_egbag]
			if len(_ccfe) < len(_ffda) {
				return _fceaf
			}
			if len(_ccfe) > len(_ffda) {
				return _cdgg
			}
			for _bccef := range _ccfe {
				_cfbe := _fbae(_ccfe[_bccef], _ffda[_bccef], _bfgd, _cbab)
				if _cfbe != _gabde {
					return _cfbe
				}
			}
		}
		return _gabde
	}
	return _abef
}

// Coupdaysnc implements the Excel COUPDAYSNC function.
func Coupdaysnc(args []Result) Result {
	_fbgd, _gegd := _gdgb(args, "\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053\u004e\u0043")
	if _gegd.Type == ResultTypeError {
		return _gegd
	}
	return MakeNumberResult(_gfe(_fbgd._eebf, _fbgd._edge, _fbgd._eda, _fbgd._ceca))
}
func (_aebge node) String() string {
	return _b.Sprintf("\u007b%\u0073\u0020\u0025\u0073\u007d", _aebge._ccfcc, _edgab(string(_aebge._bacgg)))
}

// LookupFunction looks up and returns a standard function or nil.
func LookupFunction(name string) Function {
	_agccd.Lock()
	defer _agccd.Unlock()
	if _baff, _gbcdc := _ecfcd[name]; _gbcdc {
		return _baff
	}
	return nil
}

const _ddaf = "\u0028\u0028\u005b\u0030\u002d\u0039]\u0029\u002b\u0029:\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b(\\\u002e\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u003f\u0029\u0028\u0020\u0028\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

func Trunc(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("T\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061t \u006c\u0065\u0061\u0073t\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065ri\u0063\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_aadd := args[0].AsNumber()
	if _aadd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0054\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_fcfge := float64(0)
	if len(args) > 1 {
		_dceb := args[1].AsNumber()
		if _dceb.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0054\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_fcfge = _dceb.ValueNumber
	}
	_agda := _aadd.ValueNumber
	_abbbb := 1.0
	if _fcfge >= 0 {
		_abbbb = _gg.Pow(1/10.0, _fcfge)
	} else {
		return MakeNumberResult(0)
	}
	_agda, _ddff := _gg.Modf(_agda / _abbbb)
	_bega := 0.99999
	if _ddff > _bega {
		_agda++
	} else if _ddff < -_bega {
		_agda--
	}
	_ = _ddff
	return MakeNumberResult(_agda * _abbbb)
}

// Coupdaybs implements the Excel COUPDAYBS function.
func Coupdaybs(args []Result) Result {
	_fba, _ccga := _gdgb(args, "\u0043O\u0055\u0050\u0044\u0041\u0059\u0042S")
	if _ccga.Type == ResultTypeError {
		return _ccga
	}
	return MakeNumberResult(_fdf(_fba._eebf, _fba._edge, _fba._eda, _fba._ceca))
}
func (_bccc *yyParserImpl) Lookahead() int { return _bccc._febg }

// Update updates the horizontal range references after removing a row/column.
func (_ebde HorizontalRange) Update(q *_egg.UpdateQuery) Expression { return _ebde }

// Price implements the Excel PRICE function.
func Price(args []Result) Result {
	_ggae := len(args)
	if _ggae != 6 && _ggae != 7 {
		return MakeErrorResult("\u0050\u0052I\u0043\u0045\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020o\u0072\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_agca, _adcd, _eeec := _daea(args[0], args[1], "\u0050\u0052\u0049C\u0045")
	if _eeec.Type == ResultTypeError {
		return _eeec
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049CE\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072a\u0074e\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ggcd := args[2].ValueNumber
	if _ggcd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u006eo\u0074\u0020\u0062\u0065\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0052\u0049\u0043\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0079\u0069\u0065\u006c\u0064\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_accd := args[3].ValueNumber
	if _accd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0079\u0069\u0065\u006c\u0064 \u0074\u006f\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0065\u0064em\u0070\u0074\u0069\u006fn\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_abca := args[4].ValueNumber
	if _abca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073 \u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e \u0074\u006f\u0020\u0062\u0065 p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bffd := args[5]
	if _bffd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0066\u0072\u0065\u0071\u0075e\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cgged := _bffd.ValueNumber
	if !_degc(_cgged) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_bcbaa := 0
	if _ggae == 7 && args[6].Type != ResultTypeEmpty {
		if args[6].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0052\u0049C\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_bcbaa = int(args[6].ValueNumber)
		if !_efb(_bcbaa) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069s\u0020a\u0072g\u0075m\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0050\u0052\u0049\u0043\u0045")
		}
	}
	_aee, _eeec := _aagb(_agca, _adcd, _ggcd, _accd, _abca, _cgged, _bcbaa)
	if _eeec.Type == ResultTypeError {
		return _eeec
	}
	return MakeNumberResult(_aee)
}

const _fefbd = 57372

// Replace is an implementation of the Excel REPLACE().
func Replace(args []Result) Result {
	_eage, _dcgc := _gcgcd("\u0052E\u0050\u004c\u0041\u0043\u0045", args)
	if _dcgc.Type != ResultTypeEmpty {
		return _dcgc
	}
	_ggad := _eage._edcdb
	_ccegc := _eage._acebg
	_agegc := _eage._egfeg
	_fabg := _eage._daee
	_acabb := len(_ggad)
	if _ccegc > _acabb {
		_ccegc = _acabb
	}
	_ebfg := _ccegc + _agegc
	if _ebfg > _acabb {
		_ebfg = _acabb
	}
	_fbcb := _ggad[0:_ccegc] + _fabg + _ggad[_ebfg:]
	return MakeStringResult(_fbcb)
}

const (
	ErrorTypeValue ErrorType = iota
	ErrorTypeNull
	ErrorTypeRef
	ErrorTypeName
	ErrorTypeNum
	ErrorTypeSpill
	ErrorTypeNA
	ErrorTypeDivideByZero
)

// MinA is an implementation of the Excel MINA() function.
func MinA(args []Result) Result { return _bcfdf(args, true) }
func _ede(_gabd string) bool {
	for _, _efd := range _bfa {
		_dcg := _efd.FindStringSubmatch(_gabd)
		if len(_dcg) > 1 {
			return true
		}
	}
	return false
}
func ParseString(s string) Expression {
	if s == "" {
		return NewEmptyExpr()
	}
	return Parse(_fa.NewReader(s))
}

const (
	ReferenceTypeInvalid ReferenceType = iota
	ReferenceTypeCell
	ReferenceTypeHorizontalRange
	ReferenceTypeVerticalRange
	ReferenceTypeNamedRange
	ReferenceTypeRange
	ReferenceTypeSheet
)

// String returns a string representation of FunctionCall expression.
func (_bebg FunctionCall) String() string {
	_aefa := _bg.Buffer{}
	_aefa.WriteString(_bebg._eadcc)
	_aefa.WriteString("\u0028")
	_fdag := len(_bebg._aeef) - 1
	for _bdea, _fffac := range _bebg._aeef {
		_aefa.WriteString(_fffac.String())
		if _bdea != _fdag {
			_aefa.WriteString("\u002c")
		}
	}
	_aefa.WriteString("\u0029")
	return _aefa.String()
}

// Eval evaluates a horizontal range with prefix returning a list of results or an error.
func (_adbg PrefixHorizontalRange) Eval(ctx Context, ev Evaluator) Result {
	_bfcce := _adbg._afcd.Reference(ctx, ev)
	switch _bfcce.Type {
	case ReferenceTypeSheet:
		_cbdb := _adbg.horizontalRangeReference(_bfcce.Value)
		if _gfdge, _gaefg := ev.GetFromCache(_cbdb); _gaefg {
			return _gfdge
		}
		_faecg := ctx.Sheet(_bfcce.Value)
		_ffde, _egcea := _cfbd(_faecg, _adbg._eadb, _adbg._abgg)
		_dgba := _bdgac(_faecg, ev, _ffde, _egcea)
		ev.SetCache(_cbdb, _dgba)
		return _dgba
	default:
		return MakeErrorResult(_b.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _bfcce.Type))
	}
}

// LastRow returns 0 for the invalid reference context.
func (_eeegb *ivr) LastRow(colFrom string) int { return 0 }

type parsedSearchObject struct {
	_fcac  string
	_edegc string
	_edafc int
}

// Or is an implementation of the Excel OR() function and takes a variable
// number of arguments.
func Or(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004f\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bdfd := false
	for _, _adge := range args {
		switch _adge.Type {
		case ResultTypeList, ResultTypeArray:
			_bdcg := Or(_adge.ListValues())
			if _bdcg.Type == ResultTypeError {
				return _bdcg
			}
			if _bdcg.ValueNumber != 0 {
				_bdfd = true
			}
		case ResultTypeNumber:
			if _adge.ValueNumber != 0 {
				_bdfd = true
			}
		case ResultTypeString:
			return MakeErrorResult("\u004f\u0052 \u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u0065\u0020\u006f\u006e\u0020\u0073\u0074\u0072in\u0067\u0073")
		case ResultTypeError:
			return _adge
		default:
			return MakeErrorResult("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u004f\u0052")
		}
	}
	return MakeBoolResult(_bdfd)
}

// Reference returns an invalid reference for Negate.
func (_efacd Negate) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Sln implements the Excel SLN function.
func Sln(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0053\u004c\u004e\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ege := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bgdcd := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bdbfa := args[2].ValueNumber
	if _bdbfa == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u007a\u0065\u0072\u006f")
	}
	return MakeNumberResult((_ege - _bgdcd) / _bdbfa)
}

const _gfd = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002d\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u002d\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

// GetWidth returns 0 for the invalid reference context.
func (_fcde *ivr) GetWidth(colIdx int) float64 { return float64(0) }

const _deaa = -1000

func _feea(_ebgb float64) float64 { return float64(int(_ebgb + 0.5)) }

// Large implements the Excel LARGE function.
func Large(args []Result) Result { return _ddfe(args, true) }

// Radians is an implementation of the Excel function RADIANS() that converts
// degrees to radians.
func Radians(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0052\u0041\u0044I\u0041\u004e\u0053\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aegc := args[0].AsNumber()
	if _aegc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0044IA\u004e\u0053\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u006eu\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(_gg.Pi / 180.0 * _aegc.ValueNumber)
}

type durationArgs struct {
	_dade  float64
	_ddfb  float64
	_egcd  float64
	_agabg float64
	_accf  float64
	_afbc  int
}

func _cgfb(_bfdb string) (int, int, float64, bool, bool, Result) {
	_gffc := ""
	_effa := []string{}
	for _bgfb, _cgba := range _fbgf {
		_effa = _cgba.FindStringSubmatch(_bfdb)
		if len(_effa) > 1 {
			_gffc = _bgfb
			break
		}
	}
	if _gffc == "" {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
	}
	_dfbg := _effa[1] == ""
	_effa = _effa[49:]
	_beg := len(_effa)
	_bcbc := _effa[_beg-1]
	_aeag := _bcbc == "\u0061\u006d"
	_cdgc := _bcbc == "\u0070\u006d"
	var _cfb, _eef int
	var _cbb float64
	var _aggb error
	switch _gffc {
	case "\u0068\u0068":
		_cfb, _aggb = _ga.Atoi(_effa[0])
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
		_eef = 0
		_cbb = 0
	case "\u0068\u0068\u003am\u006d":
		_cfb, _aggb = _ga.Atoi(_effa[0])
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
		_eef, _aggb = _ga.Atoi(_effa[2])
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
		_cbb = 0
	case "\u006d\u006d\u003as\u0073":
		_cfb = 0
		_eef, _aggb = _ga.Atoi(_effa[0])
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
		_cbb, _aggb = _ga.ParseFloat(_effa[2], 64)
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
	case "\u0068\u0068\u003a\u006d\u006d\u003a\u0073\u0073":
		_cfb, _aggb = _ga.Atoi(_effa[0])
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
		_eef, _aggb = _ga.Atoi(_effa[2])
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
		_cbb, _aggb = _ga.ParseFloat(_effa[4], 64)
		if _aggb != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		}
	}
	if _eef >= 60 {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
	}
	if _aeag || _cdgc {
		if _cfb > 12 || _cbb >= 60 {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
		} else if _cfb == 12 {
			_cfb = 0
		}
	} else if _cfb >= 24 || _cbb >= 10000 {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _abd)
	}
	return _cfb, _eef, _cbb, _cdgc, _dfbg, _aaa
}

type yyParser interface {
	Parse(yyLexer) int
	Lookahead() int
}

// Power is an implementation of the Excel POWER function that raises a number
// to a power. It requires two numeric arguments.
func Power(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_ggcca := args[0].AsNumber()
	if _ggcca.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bcgba := args[1].AsNumber()
	if _bcgba.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	return MakeNumberResult(_gg.Pow(_ggcca.ValueNumber, _bcgba.ValueNumber))
}

// Amordegrc implements the Excel AMORDEGRC function.
func Amordegrc(args []Result) Result {
	_ccgd, _abbe := _ffed(args, "\u0041M\u004f\u0052\u0044\u0045\u0047\u0052C")
	if _abbe.Type == ResultTypeError {
		return _abbe
	}
	_eea := _ccgd._fgb
	_gagf := _ccgd._bggd
	_ecca := _ccgd._gagfe
	_daeg := _ccgd._cggf
	_affa := _ccgd._cdgcc
	_bdba := _ccgd._baca
	if _bdba >= 0.5 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u004d\u004f\u0052\u0044\u0045\u0047R\u0043\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u0030\u002e\u0035")
	}
	_deacc := _ccgd._fcfd
	_gcgd := 1.0 / _bdba
	_aegd := 2.5
	if _gcgd < 3 {
		_aegd = 1
	} else if _gcgd < 5 {
		_aegd = 1.5
	} else if _gcgd <= 6 {
		_aegd = 2
	}
	_bdba *= _aegd
	_ada, _bgdg := _cbfa(_gagf, _ecca, _deacc)
	if _bgdg.Type == ResultTypeError {
		return MakeErrorResult("\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0072\u0020\u0041\u004d\u004f\u0052\u0044EG\u0052\u0043")
	}
	_acec := _feea(_ada * _bdba * _eea)
	_eea -= _acec
	_dca := _eea - _daeg
	for _gcad := 0; _gcad < _affa; _gcad++ {
		_acec = _feea(_bdba * _eea)
		_dca -= _acec
		if _dca < 0 {
			switch _affa - _gcad {
			case 0:
			case 1:
				return MakeNumberResult(_feea(_eea * 0.5))
			default:
				return MakeNumberResult(0)
			}
		}
		_eea -= _acec
	}
	return MakeNumberResult(_acec)
}
func _bddf(_caded, _aacggb int) string {
	const TOKSTART = 4
	if !_gagfea {
		return "\u0073\u0079\u006et\u0061\u0078\u0020\u0065\u0072\u0072\u006f\u0072"
	}
	for _, _babea := range _dddab {
		if _babea._ecbfe == _caded && _babea._gcfcb == _aacggb {
			return "\u0073\u0079\u006e\u0074\u0061\u0078\u0020\u0065\u0072r\u006f\u0072\u003a\u0020" + _babea._fcbgd
		}
	}
	_dbcf := "\u0073y\u006e\u0074\u0061\u0078 \u0065\u0072\u0072\u006f\u0072:\u0020u\u006ee\u0078\u0070\u0065\u0063\u0074\u0065\u0064 " + _faafa(_aacggb)
	_cfaeb := make([]int, 0, 4)
	_gcbdca := _fdbd[_caded]
	for _cccdc := TOKSTART; _cccdc-1 < len(_ebade); _cccdc++ {
		if _bcbd := _gcbdca + _cccdc; _bcbd >= 0 && _bcbd < _gefb && _gcfac[_edbb[_bcbd]] == _cccdc {
			if len(_cfaeb) == cap(_cfaeb) {
				return _dbcf
			}
			_cfaeb = append(_cfaeb, _cccdc)
		}
	}
	if _bcbfa[_caded] == -2 {
		_ebbbb := 0
		for _ecbfc[_ebbbb] != -1 || _ecbfc[_ebbbb+1] != _caded {
			_ebbbb += 2
		}
		for _ebbbb += 2; _ecbfc[_ebbbb] >= 0; _ebbbb += 2 {
			_aegbf := _ecbfc[_ebbbb]
			if _aegbf < TOKSTART || _ecbfc[_ebbbb+1] == 0 {
				continue
			}
			if len(_cfaeb) == cap(_cfaeb) {
				return _dbcf
			}
			_cfaeb = append(_cfaeb, _aegbf)
		}
		if _ecbfc[_ebbbb+1] != 0 {
			return _dbcf
		}
	}
	for _deebe, _ecccf := range _cfaeb {
		if _deebe == 0 {
			_dbcf += "\u002c\u0020\u0065x\u0070\u0065\u0063\u0074\u0069\u006e\u0067\u0020"
		} else {
			_dbcf += "\u0020\u006f\u0072\u0020"
		}
		_dbcf += _faafa(_ecccf)
	}
	return _dbcf
}

// Eval evaluates and returns the result of an empty expression.
func (_agag EmptyExpr) Eval(ctx Context, ev Evaluator) Result { return MakeEmptyResult() }

// Trim is an implementation of the Excel TRIM function that removes leading,
// trailing and consecutive spaces.
func Trim(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0054\u0052\u0049\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_aeed := args[0].AsString()
	if _aeed.Type != ResultTypeString {
		return MakeErrorResult("\u0054\u0052\u0049\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dfabg := _bg.Buffer{}
	_dfbd := false
	_acdfc := false
	_egcde := 0
	for _, _cdad := range _aeed.ValueString {
		_ecbe := _cdad == ' '
		if _ecbe {
			if !_dfbd {
				continue
			}
			if !_acdfc {
				_egcde++
				_dfabg.WriteRune(_cdad)
			}
		} else {
			_egcde = 0
			_dfbd = true
			_dfabg.WriteRune(_cdad)
		}
		_acdfc = _ecbe
	}
	_dfabg.Truncate(_dfabg.Len() - _egcde)
	return MakeStringResult(_dfabg.String())
}

const _cggedc = 57368

// Combina is an implementation of the Excel COMBINA function whic returns the
// number of combinations with repetitions.
func Combina(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004dB\u0049\u004e\u0041\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_abaga := args[0].AsNumber()
	_ggaf := args[1].AsNumber()
	if _abaga.Type != ResultTypeNumber || _ggaf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043\u004fMB\u0049\u004e\u0041(\u0029\u0020\u0072\u0065qui\u0072es\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_faed := _gg.Trunc(_abaga.ValueNumber)
	_ebgbe := _gg.Trunc(_ggaf.ValueNumber)
	if _faed < _ebgbe {
		return MakeErrorResult("\u0043O\u004d\u0042\u0049\u004e\u0041\u0028\u0029\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u006e\u0020\u003e\u0020\u006b")
	}
	if _faed == 0 {
		return MakeNumberResult(0)
	}
	args[0] = MakeNumberResult(_faed + _ebgbe - 1)
	args[1] = MakeNumberResult(_faed - 1)
	return Combin(args)
}

// Reference returns a string reference value to a vertical range with prefix.
func (_fbfa PrefixVerticalRange) Reference(ctx Context, ev Evaluator) Reference {
	_abee := _fbfa._ccea.Reference(ctx, ev)
	return Reference{Type: ReferenceTypeVerticalRange, Value: _fbfa.verticalRangeReference(_abee.Value)}
}

// Log implements the Excel LOG function which returns the log of a number. By
// default the result is base 10, however the second argument to the function
// can specify a different base.
func Log(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 o\u006e\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("L\u004f\u0047\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u006d\u0061\u0078i\u006d\u0075\u006d\u0020\u006f\u0066\u0020\u0074\u0077\u006f a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_gaag := args[0].AsNumber()
	if _gaag.Type != ResultTypeNumber {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 o\u006e\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_agcc := 10.0
	if len(args) > 1 {
		_cacec := args[1].AsNumber()
		if _cacec.Type != ResultTypeNumber {
			return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061rg\u0075\u006d\u0065n\u0074\u0020t\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0065r\u0069\u0063")
		}
		_agcc = args[1].ValueNumber
	}
	if _gaag.ValueNumber == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072gu\u006d\u0065\u006et\u0020\u0074o\u0020\u0062\u0065\u0020\u006e\u006fn\u002d\u007ae\u0072\u006f")
	}
	if _agcc == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073e\u0063\u006f\u006e\u0064\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u002d\u007a\u0065\u0072\u006f")
	}
	return MakeNumberResult(_gg.Log(_gaag.ValueNumber) / _gg.Log(_agcc))
}

// Reference returns a string reference value to a horizontal range.
func (_dedg HorizontalRange) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeHorizontalRange, Value: _dedg.horizontalRangeReference()}
}

// GetEpoch returns a null time object for the invalid reference context.
func (_fagb *ivr) GetEpoch() _ea.Time { return _ea.Time{} }

// Update updates references in the VerticalRange after removing a row/column.
func (_ebfd VerticalRange) Update(q *_egg.UpdateQuery) Expression {
	if q.UpdateType == _egg.UpdateActionRemoveColumn {
		_bcaed := _ebfd
		if q.UpdateCurrentSheet {
			_geaf := q.ColumnIdx
			_bcaed._eabbc = _eb(_ebfd._eabbc, _geaf)
			_bcaed._cebb = _eb(_ebfd._cebb, _geaf)
		}
		return _bcaed
	}
	return _ebfd
}
func _fag(_cdgf, _cdfa, _bcd int) float64 {
	return float64(_ddcf(_cdgf, _ea.Month(_cdfa), _bcd)/86400) + _dcc
}
func _adebe(_ggbcc Result) *criteriaParsed {
	_dedea := _ggbcc.Type == ResultTypeNumber
	_ccggf := _ggbcc.ValueNumber
	_gfdc := _fa.ToLower(_ggbcc.ValueString)
	_gdgag := _acbag(_gfdc)
	return &criteriaParsed{_dedea, _ccggf, _gfdc, _gdgag}
}

const _cbacc = 16

type xargs struct {
	_gaed  []float64
	_fbbee []float64
}

// NewHorizontalRange constructs a new full rows range.
func NewHorizontalRange(v string) Expression {
	_cbba := _fa.Split(v, "\u003a")
	if len(_cbba) != 2 {
		return nil
	}
	_gcgae, _ := _ga.Atoi(_cbba[0])
	_ebfc, _ := _ga.Atoi(_cbba[1])
	return HorizontalRange{_gcgae, _ebfc}
}
func _agef(_fdabd, _fge float64) bool { return _gg.Abs(_fdabd-_fge) < 1.0e-6 }

const _dbfc = "\u0028(\u005b0\u002d\u0039\u005d\u0029\u002b)\u0020\u0028a\u006d\u007c\u0070\u006d\u0029"

// Arabic implements the Excel ARABIC function which parses roman numerals.  It
// accepts one numeric argument.
func Arabic(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0041\u0052\u0041\u0042I\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_edcac := args[0]
	switch _edcac.Type {
	case ResultTypeNumber, ResultTypeList, ResultTypeEmpty:
		return MakeErrorResult("\u0041\u0052\u0041B\u0049\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	case ResultTypeString:
		_fgafdf := 0.0
		_ggdd := 0.0
		for _, _ebfa := range _edcac.ValueString {
			_cdcd := 0.0
			switch _ebfa {
			case 'I':
				_cdcd = 1
			case 'V':
				_cdcd = 5
			case 'X':
				_cdcd = 10
			case 'L':
				_cdcd = 50
			case 'C':
				_cdcd = 100
			case 'D':
				_cdcd = 500
			case 'M':
				_cdcd = 1000
			}
			_fgafdf += _cdcd
			switch {
			case _ggdd == _cdcd && (_ggdd == 5 || _ggdd == 50 || _ggdd == 500):
				return MakeErrorResult("i\u006e\u0076\u0061\u006cid\u0020A\u0052\u0041\u0042\u0049\u0043 \u0066\u006f\u0072\u006d\u0061\u0074")
			case 2*_ggdd == _cdcd:
				return MakeErrorResult("i\u006e\u0076\u0061\u006cid\u0020A\u0052\u0041\u0042\u0049\u0043 \u0066\u006f\u0072\u006d\u0061\u0074")
			}
			if _ggdd < _cdcd {
				_fgafdf -= 2 * _ggdd
			}
			_ggdd = _cdcd
		}
		return MakeNumberResult(_fgafdf)
	case ResultTypeError:
		return _edcac
	default:
		return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0068an\u0064\u006c\u0065\u0064\u0020\u0041\u0043\u004f\u0053H\u0028)\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _edcac.Type))
	}
}

// GCD implements the Excel GCD() function which returns the greatest common
// divisor of a range of numbers.
func GCD(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0047\u0043D(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0061t \u006c\u0065\u0061\u0073\u0074\u0020\u006fne\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_dcga := []float64{}
	for _, _cbcd := range args {
		switch _cbcd.Type {
		case ResultTypeString:
			_fbdcg := _cbcd.AsNumber()
			if _fbdcg.Type != ResultTypeNumber {
				return MakeErrorResult("\u0047\u0043D(\u0029\u0020\u006fn\u006c\u0079\u0020\u0061cce\u0070ts\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
			}
			_dcga = append(_dcga, _fbdcg.ValueNumber)
		case ResultTypeList, ResultTypeArray:
			_dafbc := GCD(_cbcd.ListValues())
			if _dafbc.Type != ResultTypeNumber {
				return _dafbc
			}
			_dcga = append(_dcga, _dafbc.ValueNumber)
		case ResultTypeNumber:
			_dcga = append(_dcga, _cbcd.ValueNumber)
		case ResultTypeError:
			return _cbcd
		default:
			return MakeErrorResult(_b.Sprintf("\u0047\u0043\u0044()\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065d\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cbcd.Type))
		}
	}
	if _dcga[0] < 0 {
		return MakeErrorResult("\u0047\u0043D\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(_dcga) == 1 {
		return MakeNumberResult(_dcga[0])
	}
	_acaea := _dcga[0]
	for _dggd := 1; _dggd < len(_dcga); _dggd++ {
		if _dcga[_dggd] < 0 {
			return MakeErrorResult("\u0047\u0043D\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
		}
		_acaea = _ccgc(_acaea, _dcga[_dggd])
	}
	return MakeNumberResult(_acaea)
}

// String returns a string representation of SheetPrefixExpr.
func (_dbcc SheetPrefixExpr) String() string { return _dbcc._fdcd }

// Match implements the MATCH function.
func Match(args []Result) Result {
	_cbfad := len(args)
	if _cbfad != 2 && _cbfad != 3 {
		return MakeErrorResult("\u004d\u0041T\u0043\u0048\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020o\u0072\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_cbed := 1
	if _cbfad == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065q\u0075\u0069\u0072es\u0020\u0074\u0068\u0065\u0020\u0074h\u0069\u0072\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006db\u0065\u0072")
		}
		_cfec := args[2].ValueNumber
		if _cfec == -1 || _cfec == 0 {
			_cbed = int(_cfec)
		}
	}
	_geac := args[1]
	var _eacf []Result
	switch _geac.Type {
	case ResultTypeList:
		_eacf = _geac.ValueList
	case ResultTypeArray:
		_dcea := _geac.ValueArray
		if len(_dcea[0]) != 1 {
			return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068e\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006f\u006e\u0065\u002dd\u0069\u006d\u0065\u006e\u0073\u0069o\u006e\u0061l\u0020\u0072a\u006eg\u0065")
		}
		for _, _acgf := range _dcea {
			_eacf = append(_eacf, _acgf[0])
		}
	default:
		return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068e\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006f\u006e\u0065\u002dd\u0069\u006d\u0065\u006e\u0073\u0069o\u006e\u0061l\u0020\u0072a\u006eg\u0065")
	}
	_dcbf := _adebe(args[0])
	switch _cbed {
	case 0:
		for _fcgfe, _cgaa := range _eacf {
			if _eagf(_cgaa, _dcbf) {
				return MakeNumberResult(float64(_fcgfe + 1))
			}
		}
	case -1:
		for _eafb := 0; _eafb < len(_eacf); _eafb++ {
			if _eagf(_eacf[_eafb], _dcbf) {
				return MakeNumberResult(float64(_eafb + 1))
			}
			if _dcbf._bfabd && (_eacf[_eafb].ValueNumber < _dcbf._cbaa) {
				if _eafb == 0 {
					return MakeErrorResultType(ErrorTypeNA, "")
				}
				return MakeNumberResult(float64(_eafb))
			}
		}
	case 1:
		for _eaaga := 0; _eaaga < len(_eacf); _eaaga++ {
			if _eagf(_eacf[_eaaga], _dcbf) {
				return MakeNumberResult(float64(_eaaga + 1))
			}
			if _dcbf._bfabd && (_eacf[_eaaga].ValueNumber > _dcbf._cbaa) {
				if _eaaga == 0 {
					return MakeErrorResultType(ErrorTypeNA, "")
				}
				return MakeNumberResult(float64(_eaaga))
			}
		}
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

// Eomonth is an implementation of the Excel EOMONTH() function.
func Eomonth(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u004f\u004d\u004f\u004e\u0054\u0048\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	_aea := args[1].ValueNumber
	_egcc := args[0]
	var _bed float64
	switch _egcc.Type {
	case ResultTypeEmpty:
		_bed = 0
	case ResultTypeNumber:
		_bed = _egcc.ValueNumber
	case ResultTypeString:
		_bgfe := DateValue([]Result{args[0]})
		if _bgfe.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
		}
		_bed = _bgfe.ValueNumber
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	_dbab := _ddef(_bed)
	_afgc := _dbab.AddDate(0, int(_aea+1), 0)
	_bbc, _fcgf, _ := _afgc.Date()
	_fbba := _fag(_bbc, int(_fcgf), 0)
	if _fbba < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	if _bbc == 1900 && _fcgf == 3 {
		_fbba--
	}
	return MakeNumberResult(_fbba)
}

// PrefixHorizontalRange is a range expression that when evaluated returns a list of Results from references like Sheet1!1:4 (all cells from rows 1 to 4 of sheet 'Sheet1').
type PrefixHorizontalRange struct {
	_afcd        Expression
	_eadb, _abgg int
}

// Mround is an implementation of the Excel MROUND function.  It is not a
// generic rounding function and has some oddities to match Excel's behavior.
func Mround(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004d\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0077o\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_abcb := args[0].AsNumber()
	if _abcb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006de\u006e\u0074\u0020\u0074o\u0020\u004d\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_gbfea := float64(1)
	_edfda := args[1].AsNumber()
	if _edfda.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073e\u0063\u006fn\u0064\u0020\u0061\u0072g\u0075\u006d\u0065n\u0074\u0020\u0074\u006f\u0020\u004d\u0052\u004f\u0055ND\u0028\u0029\u0020m\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006db\u0065\u0072")
	}
	_gbfea = _edfda.ValueNumber
	if _gbfea < 0 && _abcb.ValueNumber > 0 || _gbfea > 0 && _abcb.ValueNumber < 0 {
		return MakeErrorResult("\u004d\u0052\u004fUN\u0044\u0028\u0029\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020s\u0069g\u006e\u0073\u0020\u006d\u0075\u0073\u0074\u0020\u006d\u0061\u0074\u0063\u0068")
	}
	_bebaa := _abcb.ValueNumber
	_bebaa, _gcgg := _gg.Modf(_bebaa / _gbfea)
	if _gg.Trunc(_gcgg+0.5) > 0 {
		_bebaa++
	}
	return MakeNumberResult(_bebaa * _gbfea)
}

const (
	BinOpTypeUnknown BinOpType = iota
	BinOpTypePlus
	BinOpTypeMinus
	BinOpTypeMult
	BinOpTypeDiv
	BinOpTypeExp
	BinOpTypeLT
	BinOpTypeGT
	BinOpTypeEQ
	BinOpTypeLEQ
	BinOpTypeGEQ
	BinOpTypeNE
	BinOpTypeConcat
)

// Value returns a string version of the result.
func (_efegc Result) Value() string {
	switch _efegc.Type {
	case ResultTypeNumber:
		_cdae := _ga.FormatFloat(_efegc.ValueNumber, 'f', -1, 64)
		if len(_cdae) > 12 {
			_eaagd := 12
			for _cfdda := _eaagd; _cfdda > 0 && _cdae[_cfdda] == '0'; _cfdda-- {
				_eaagd--
			}
			_cdae = _cdae[0 : _eaagd+1]
		}
		return _cdae
	case ResultTypeError:
		return _efegc.ValueString
	case ResultTypeString:
		return _efegc.ValueString
	case ResultTypeList:
		if len(_efegc.ValueList) == 0 {
			return ""
		}
		return _efegc.ValueList[0].Value()
	case ResultTypeArray:
		if len(_efegc.ValueArray) == 0 || len(_efegc.ValueArray[0]) == 0 {
			return ""
		}
		return _efegc.ValueArray[0][0].Value()
	case ResultTypeEmpty:
		return ""
	default:
		return "\u0075\u006e\u0068\u0061nd\u006c\u0065\u0064\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0076\u0061\u006cu\u0065"
	}
}

// Disc implements the Excel DISC function.
func Disc(args []Result) Result {
	_baaa := len(args)
	if _baaa != 4 && _baaa != 5 {
		return MakeErrorResult("\u0044\u0049SC\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s f\u006fur\u0020\u006f\u0072\u0020\u0066\u0069\u0076e \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_aagg, _acacg, _gfec := _daea(args[0], args[1], "\u0044\u0049\u0053\u0043")
	if _gfec.Type == ResultTypeError {
		return _gfec
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_eabc := args[2].ValueNumber
	if _eabc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0072\u0020\u0074o \u0062\u0065\u0020\u0070o\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0049S\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_egfe := args[3].ValueNumber
	if _egfe <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0049\u0053\u0043\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0072e\u0064\u0065m\u0070\u0074\u0069\u006f\u006e\u0020t\u006f b\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cebg := 0
	if _baaa == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0049\u0053\u0043\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_cebg = int(args[4].ValueNumber)
		if !_efb(_cebg) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0066\u006f\u0072 \u0044\u0049\u0053\u0043")
		}
	}
	_aggbf, _gfec := _cbfa(_aagg, _acacg, _cebg)
	if _gfec.Type == ResultTypeError {
		return _gfec
	}
	return MakeNumberResult((_egfe - _eabc) / _egfe / _aggbf)
}
func _bcfdf(_begd []Result, _aegfc bool) Result {
	_geeaga := "\u004d\u0049\u004e"
	if _aegfc {
		_geeaga = "\u004d\u0049\u004e\u0041"
	}
	if len(_begd) == 0 {
		return MakeErrorResult(_geeaga + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061s\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aedbd := _gg.MaxFloat64
	for _, _dead := range _begd {
		switch _dead.Type {
		case ResultTypeNumber:
			if (_aegfc || !_dead.IsBoolean) && _dead.ValueNumber < _aedbd {
				_aedbd = _dead.ValueNumber
			}
		case ResultTypeList, ResultTypeArray:
			_cfcg := _bcfdf(_dead.ListValues(), _aegfc)
			if _cfcg.ValueNumber < _aedbd {
				_aedbd = _cfcg.ValueNumber
			}
		case ResultTypeEmpty:
		case ResultTypeString:
			_acda := 0.0
			if _aegfc {
				_acda = _dead.AsNumber().ValueNumber
			}
			if _acda < _aedbd {
				_aedbd = _acda
			}
		default:
			_cg.Log("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020"+_geeaga+"\u0028\u0029\u0020\u0061rg\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _dead.Type)
		}
	}
	if _aedbd == _gg.MaxFloat64 {
		_aedbd = 0
	}
	return MakeNumberResult(_aedbd)
}

// LookupFunctionComplex looks up and returns a complex function or nil.
func LookupFunctionComplex(name string) FunctionComplex {
	_agccd.Lock()
	defer _agccd.Unlock()
	if _egdfc, _cfbcb := _ddebg[name]; _cfbcb {
		return _egdfc
	}
	return nil
}

// MakeBoolResult constructs a boolean result (internally a number).
func MakeBoolResult(b bool) Result {
	if b {
		return Result{Type: ResultTypeNumber, ValueNumber: 1, IsBoolean: true}
	}
	return Result{Type: ResultTypeNumber, ValueNumber: 0, IsBoolean: true}
}

// Update returns the same object as updating sheet references does not affect String.
func (_eddc String) Update(q *_egg.UpdateQuery) Expression { return _eddc }

// MakeListResult constructs a list result.
func MakeListResult(list []Result) Result { return Result{Type: ResultTypeList, ValueList: list} }
func _bcfg(_accb float64, _aedeg *criteriaRegex) bool {
	_gbcg, _eeeb := _ga.ParseFloat(_aedeg._cbcgcc, 64)
	if _eeeb != nil {
		return false
	}
	switch _aedeg._dgbebb {
	case _cgbed:
		return _accb == _gbcg
	case _eacfe:
		return _accb <= _gbcg
	case _fbafb:
		return _accb >= _gbcg
	case _eabe:
		return _accb < _gbcg
	case _efeg:
		return _accb > _gbcg
	}
	return false
}

// GetLabelPrefix returns an empty string for the invalid reference context.
func (_dcec *ivr) GetLabelPrefix(cellRef string) string { return "" }

// Syd implements the Excel SYD function.
func Syd(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("S\u0059\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072 \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fbbf := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_adbc := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ebbb := args[2].ValueNumber
	if _ebbb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cedb := args[3].ValueNumber
	if _cedb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070e\u0072i\u006fd\u0020t\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if _cedb > _ebbb {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0065q\u0075\u0061\u006c\u0020\u006f\u0072\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068a\u006e \u006c\u0069\u0066\u0065")
	}
	_cbec := (_fbbf - _adbc) * (_ebbb - _cedb + 1) * 2
	_abgef := _ebbb * (_ebbb + 1)
	return MakeNumberResult(_cbec / _abgef)
}

// Effect implements the Excel EFFECT function.
func Effect(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u0046F\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u006f\u006d\u0069n\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_bcbba := args[0].ValueNumber
	if _bcbba <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0045\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u006f\u006d\u0069n\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0046\u0046\u0045\u0043\u0054 \u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066 \u0063\u006f\u006d\u0070\u006f\u0075\u006e\u0064\u0069\u006e\u0067\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	_cbbcd := float64(int(args[1].ValueNumber))
	if _cbbcd < 1 {
		return MakeErrorResultType(ErrorTypeNum, "E\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0063o\u006dp\u006f\u0075\u006e\u0064i\u006e\u0067 \u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0031\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065")
	}
	return MakeNumberResult(_gg.Pow((1+_bcbba/_cbbcd), _cbbcd) - 1)
}

// Yield implements the Excel YIELD function.
func Yield(args []Result) Result {
	_eeefa := len(args)
	if _eeefa != 6 && _eeefa != 7 {
		return MakeErrorResult("\u0059\u0049E\u004c\u0044\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020o\u0072\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_egdb, _fefdb, _dfgg := _daea(args[0], args[1], "\u0059\u0049\u0045L\u0044")
	if _dfgg.Type == ResultTypeError {
		return _dfgg
	}
	_gffdg := args[2]
	if _gffdg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045LD\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072a\u0074e\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_acgc := _gffdg.ValueNumber
	if _acgc < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	_ebec := args[3]
	if _ebec.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020p\u0072 \u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_adgf := _ebec.ValueNumber
	if _adgf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "p\u0072\u0020\u0073\u0068ou\u006cd\u0020\u0062\u0065\u0020\u0070o\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	_ecbd := args[4]
	if _ecbd.Type != ResultTypeNumber {
		return MakeErrorResult("Y\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065m\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0066\u0020\u0074yp\u0065\u0020\u006eu\u006db\u0065\u0072")
	}
	_dagf := _ecbd.ValueNumber
	if _dagf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_ffdf := args[5]
	if _ffdf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0066\u0072\u0065\u0071\u0075e\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_edgcc := float64(int(_ffdf.ValueNumber))
	if !_degc(_edgcc) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_bdaf := 0
	if _eeefa == 7 && args[6].Type != ResultTypeEmpty {
		_abgb := args[6]
		if _abgb.Type != ResultTypeNumber {
			return MakeErrorResult("Y\u0049\u0045\u004c\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0062\u0061\u0073\u0069\u0073\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
		}
		_bdaf = int(_abgb.ValueNumber)
		if !_efb(_bdaf) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063o\u0072\u0072\u0065\u0063t\u0020\u0062\u0061\u0073\u0069\u0073\u0020v\u0061\u006c\u0075\u0065\u0020\u0066\u006f\u0072\u0020\u0059\u0049\u0045\u004c\u0044")
		}
	}
	_baf := 0.0
	_fdde := 0.0
	_fgbb := 1.0
	_ddeb, _dfgg := _aagb(_egdb, _fefdb, _acgc, _fdde, _dagf, _edgcc, _bdaf)
	if _dfgg.Type == ResultTypeError {
		return _dfgg
	}
	_feba, _dfgg := _aagb(_egdb, _fefdb, _acgc, _fgbb, _dagf, _edgcc, _bdaf)
	if _dfgg.Type == ResultTypeError {
		return _dfgg
	}
	_ggde := (_fgbb - _fdde) * 0.5
	for _bbbd := 0; _bbbd < 100 && _baf != _adgf; _bbbd++ {
		_baf, _dfgg = _aagb(_egdb, _fefdb, _acgc, _ggde, _dagf, _edgcc, _bdaf)
		if _dfgg.Type == ResultTypeError {
			return _dfgg
		}
		if _adgf == _ddeb {
			return MakeNumberResult(_fdde)
		} else if _adgf == _feba {
			return MakeNumberResult(_fgbb)
		} else if _adgf == _baf {
			return MakeNumberResult(_ggde)
		} else if _adgf < _feba {
			_fgbb *= 2.0
			_feba, _dfgg = _aagb(_egdb, _fefdb, _acgc, _fgbb, _dagf, _edgcc, _bdaf)
			if _dfgg.Type == ResultTypeError {
				return _dfgg
			}
			_ggde = (_fgbb - _fdde) * 0.5
		} else {
			if _adgf < _baf {
				_fdde = _ggde
				_ddeb = _baf
			} else {
				_fgbb = _ggde
				_feba = _baf
			}
			_ggde = _fgbb - (_fgbb-_fdde)*((_adgf-_feba)/(_ddeb-_feba))
		}
	}
	return MakeNumberResult(_ggde)
}

// Transpose implements the TRANSPOSE function that transposes a cell range.
func Transpose(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0054\u0052AN\u0053\u0050\u004fS\u0045\u0020\u0072\u0065qui\u0072es\u0020\u0061\u0020\u0073\u0069\u006e\u0067le\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[0].Type != ResultTypeArray && args[0].Type != ResultTypeList {
		return MakeErrorResult("T\u0052\u0041\u004e\u0053\u0050\u004fS\u0045\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0061\u0020\u0072a\u006e\u0067\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_geedf := args[0]
	if _geedf.Type == ResultTypeList {
		_dbcd := [][]Result{}
		for _, _caffd := range _geedf.ValueList {
			_dbcd = append(_dbcd, []Result{_caffd})
		}
		return MakeArrayResult(_dbcd)
	}
	_gcgcb := make([][]Result, len(_geedf.ValueArray[0]))
	for _, _bdaa := range _geedf.ValueArray {
		for _cebf, _bcfd := range _bdaa {
			_gcgcb[_cebf] = append(_gcgcb[_cebf], _bcfd)
		}
	}
	return MakeArrayResult(_gcgcb)
}
func _geccb(_gcddc Result) bool {
	_ceda := _gcddc.Type
	return _ceda != ResultTypeArray && _ceda != ResultTypeList
}

// Sum is an implementation of the Excel SUM() function.
func Sum(args []Result) Result {
	_bcbcd := MakeNumberResult(0)
	for _, _gbfba := range args {
		_gbfba = _gbfba.AsNumber()
		switch _gbfba.Type {
		case ResultTypeNumber:
			_bcbcd.ValueNumber += _gbfba.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_baac := Sum(_gbfba.ListValues())
			if _baac.Type != ResultTypeNumber {
				return _baac
			}
			_bcbcd.ValueNumber += _baac.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _gbfba
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0053\u0055\u004d\u0028\u0029 \u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _gbfba.Type))
		}
	}
	return _bcbcd
}

// VerticalRange is a range expression that when evaluated returns a list of Results from references like AA:IJ (all cells from columns AA to IJ).
type VerticalRange struct{ _eabbc, _cebb string }

func _cbfa(_bege, _acg float64, _ceg int) (float64, Result) {
	_bff, _gcag := _ddef(_bege), _ddef(_acg)
	_ebdc := _bff.Unix()
	_dcdd := _gcag.Unix()
	if _ebdc == _dcdd {
		return 0, _aaa
	}
	_faf, _ccg, _fgf := _bff.Date()
	_cad, _cfd, _geed := _gcag.Date()
	_ddga, _gffe := int(_ccg), int(_cfd)
	var _fceb, _agcg float64
	switch _ceg {
	case 0:
		if _fgf == 31 {
			_fgf--
		}
		if _fgf == 30 && _geed == 31 {
			_geed--
		} else if _dga := _dbfd(_faf); _ddga == 2 && ((_dga && _fgf == 29) || (!_dga && _fgf == 28)) {
			_fgf = 30
			if _aacf := _dbfd(_cad); _gffe == 2 && ((_aacf && _geed == 29) || (!_aacf && _geed == 28)) {
				_geed = 30
			}
		}
		_fceb = float64((_cad-_faf)*360 + (_gffe-_ddga)*30 + (_geed - _fgf))
		_agcg = 360
	case 1:
		_fceb = _acg - _bege
		_agae := _faf != _cad
		if _agae && (_cad != _faf+1 || _ddga < _gffe || (_ddga == _gffe && _fgf < _geed)) {
			_gfgb := 0
			for _acgd := _faf; _acgd <= _cad; _acgd++ {
				_gfgb += _fdge(_acgd, 1)
			}
			_agcg = float64(_gfgb) / float64(_cad-_faf+1)
		} else {
			if !_agae && _dbfd(_faf) {
				_agcg = 366
			} else {
				if _agae && ((_dbfd(_faf) && (_ddga < 2 || (_ddga == 2 && _fgf <= 29))) || (_dbfd(_cad) && (_gffe > 2 || (_gffe == 2 && _geed == 29)))) {
					_agcg = 366
				} else {
					_agcg = 365
				}
			}
		}
	case 2:
		_fceb = _acg - _bege
		_agcg = 360
	case 3:
		_fceb = _acg - _bege
		_agcg = 365
	case 4:
		if _fgf == 31 {
			_fgf--
		}
		if _geed == 31 {
			_geed--
		}
		_fceb = float64((_cad-_faf)*360 + (_gffe-_ddga)*30 + (_geed - _fgf))
		_agcg = 360
	default:
		return 0, MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073 \u0066o\u0072\u0020\u0059\u0065\u0061\u0072\u0046r\u0061\u0063")
	}
	return _fceb / _agcg, _aaa
}

// Reference returns a string reference value to an expression with prefix.
func (_cegfd PrefixExpr) Reference(ctx Context, ev Evaluator) Reference {
	_dfaaaf := _cegfd._cafc.Reference(ctx, ev)
	_dbafc := _cegfd._adda.Reference(ctx, ev)
	if _dfaaaf.Type == ReferenceTypeSheet && _dbafc.Type == ReferenceTypeCell {
		return Reference{Type: ReferenceTypeCell, Value: _dfaaaf.Value + "\u0021" + _dbafc.Value}
	}
	return ReferenceInvalid
}

// Quotient is an implementation of the Excel QUOTIENT function that returns the
// integer portion of division.
func Quotient(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0051\u0055\u004f\u0054\u0049E\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_aefc := args[0].AsNumber()
	_ffea := args[1].AsNumber()
	if _aefc.Type != ResultTypeNumber || _ffea.Type != ResultTypeNumber {
		return MakeErrorResult("\u0051\u0055\u004f\u0054\u0049E\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _ffea.ValueNumber == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0051U\u004f\u0054\u0049\u0045N\u0054\u0028\u0029\u0020\u0064i\u0076i\u0064e\u0020\u0062\u0079\u0020\u007a\u0065\u0072o")
	}
	return MakeNumberResult(_gg.Trunc(_aefc.ValueNumber / _ffea.ValueNumber))
}

// Degrees is an implementation of the Excel function DEGREES() that converts
// radians to degrees.
func Degrees(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0044\u0045\u0047R\u0045\u0045\u0053\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eegef := args[0].AsNumber()
	if _eegef.Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0045\u0047RE\u0045\u0053\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u006eu\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(180.0 / _gg.Pi * _eegef.ValueNumber)
}

// String returns a string representation of CellRef.
func (_ccb CellRef) String() string { return _ccb._dgd }
func _eb(_dff string, _fbg uint32) string {
	_cagb := _df.ColumnToIndex(_dff)
	if _cagb == _fbg {
		return "\u0023\u0052\u0045F\u0021"
	} else if _cagb > _fbg {
		return _df.IndexToColumn(_cagb - 1)
	} else {
		return _dff
	}
}
func _fdc(_cffe, _fcfg int64) float64 { return float64(int(0.5 + float64((_fcfg-_cffe)/86400))) }

// NA is an implementation of the Excel NA() function that just returns the #N/A! error.
func NA(args []Result) Result {
	if len(args) != 0 {
		MakeErrorResult("\u004eA\u0028\u0029\u0020\u0061c\u0063\u0065\u0070\u0074\u0073 \u006eo\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s")
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

// PrefixVerticalRange is a range expression that when evaluated returns a list of Results from references like Sheet1!AA:IJ (all cells from columns AA to IJ of sheet 'Sheet1').
type PrefixVerticalRange struct {
	_ccea          Expression
	_fbedd, _gacbg string
}

// LastColumn returns empty string for the invalid reference context.
func (_agbe *ivr) LastColumn(rowFrom, rowTo int) string { return "" }
func _dcef(_dbef, _gfcfc, _cgcd Reference) string {
	return _b.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _dbef.Value, _gfcfc.Value, _cgcd.Value)
}
func (_dabb *Lexer) nextRaw() *node {
	for len(_dabb._dedgf) != 0 {
		_gfacb := <-_dabb._dedgf[len(_dabb._dedgf)-1]
		if _gfacb != nil {
			return _gfacb
		}
		_dabb._dedgf = _dabb._dedgf[0 : len(_dabb._dedgf)-1]
	}
	return <-_dabb._fggf
}
func _cbbcb(_dgbbf yyLexer) int { return _cgbd().Parse(_dgbbf) }

// Edate is an implementation of the Excel EDATE() function.
func Edate(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u0044\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077o\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	_bgd := args[1].ValueNumber
	_cacd := args[0]
	var _dcb float64
	switch _cacd.Type {
	case ResultTypeEmpty:
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	case ResultTypeNumber:
		_dcb = _cacd.ValueNumber
	case ResultTypeString:
		_cagbb := DateValue([]Result{args[0]})
		if _cagbb.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
		}
		_dcb = _cagbb.ValueNumber
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	_cce := _ddef(_dcb)
	_bdg := _cce.AddDate(0, int(_bgd), 0)
	_bcc, _eafd, _agc := _bdg.Date()
	_fgdf := _fag(_bcc, int(_eafd), _agc)
	if _fgdf < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	return MakeNumberResult(_fgdf)
}

var _gbca *_aca.Rand

// Offset is an implementation of the Excel OFFSET function.
func Offset(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 3 && len(args) != 5 {
		return MakeErrorResult("\u004f\u0046\u0046\u0053\u0045\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0068\u0072\u0065e\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_faefd := args[0].Ref
	for _faefd.Type == ReferenceTypeNamedRange {
		_faefd = ctx.NamedRange(_faefd.Value)
	}
	_fcdg := ""
	switch _faefd.Type {
	case ReferenceTypeCell:
		_fcdg = _faefd.Value
	case ReferenceTypeRange:
		_dcfe := _fa.Split(_faefd.Value, "\u003a")
		if len(_dcfe) == 2 {
			_fcdg = _dcfe[0]
		}
	default:
		return MakeErrorResult(_b.Sprintf("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0069\u006e\u0020\u004f\u0046\u0046\u0053\u0045\u0054\u0028\u0029: \u0025\u0073", _faefd.Type))
	}
	_bdae, _gbfb := _df.ParseCellReference(_fcdg)
	if _gbfb != nil {
		return MakeErrorResult(_b.Sprintf("\u0070\u0061\u0072s\u0065\u0020\u006f\u0072i\u0067\u0069\u006e\u0020\u0065\u0072\u0072o\u0072\u0020\u004f\u0046\u0046\u0053\u0045\u0054\u0028\u0029\u003a\u0020\u0025\u0073", _gbfb.Error()))
	}
	_adcc, _defg, _cdca := _bdae.Column, _bdae.RowIdx, _bdae.SheetName
	_egbe := args[1].AsNumber()
	if _egbe.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0046\u0046SE\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u0075m\u0065r\u0069\u0063\u0020\u0072\u006f\u0077\u0020\u006f\u0066\u0066\u0073\u0065\u0074")
	}
	_bbbf := args[2].AsNumber()
	if _bbbf.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0046\u0046SE\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u0075m\u0065r\u0069\u0063\u0020\u0063\u006f\u006c\u0020\u006f\u0066\u0066\u0073\u0065\u0074")
	}
	var _decf, _bded Result
	if len(args) == 3 {
		_decf = MakeNumberResult(1)
		_bded = MakeNumberResult(1)
	} else {
		_decf = args[3].AsNumber()
		if _decf.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0046\u0046\u0053\u0045\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0068\u0065\u0069\u0067\u0068\u0074")
		}
		if _decf.ValueNumber == 0 {
			return MakeErrorResultType(ErrorTypeRef, "")
		}
		_bded = args[4].AsNumber()
		if _bded.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0046F\u0053\u0045\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0077id\u0074\u0068")
		}
		if _bded.ValueNumber == 0 {
			return MakeErrorResultType(ErrorTypeRef, "")
		}
	}
	_ceac := _df.ColumnToIndex(_adcc)
	_adaf := _defg + uint32(_egbe.ValueNumber)
	_ccbg := _ceac + uint32(_bbbf.ValueNumber)
	_bgac := _adaf + uint32(_decf.ValueNumber)
	_aabb := _ccbg + uint32(_bded.ValueNumber)
	if _decf.ValueNumber > 0 {
		_bgac--
	} else {
		_bgac++
		_adaf, _bgac = _bgac, _adaf
	}
	if _bded.ValueNumber > 0 {
		_aabb--
	} else {
		_aabb++
		_ccbg, _aabb = _aabb, _ccbg
	}
	_bcce := _b.Sprintf("\u0025\u0073\u0025\u0064", _df.IndexToColumn(_ccbg), _adaf)
	_faeb := _b.Sprintf("\u0025\u0073\u0025\u0064", _df.IndexToColumn(_aabb), _bgac)
	if _cdca == "" {
		return _bdgac(ctx, ev, _bcce, _faeb)
	} else {
		return _bdgac(ctx.Sheet(_cdca), ev, _bcce, _faeb)
	}
}

const (
	_ byte = iota
	_cgbed
	_eacfe
	_fbafb
	_eabe
	_efeg
)

// Median implements the MEDIAN function that returns the median of a range of
// values.
func Median(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004d\u0045D\u0049\u0041\u004e\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020l\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dgdg := _aaeb(args)
	_f.Float64s(_dgdg)
	var _fgeg float64
	if len(_dgdg)%2 == 0 {
		_fgeg = (_dgdg[len(_dgdg)/2-1] + _dgdg[len(_dgdg)/2]) / 2
	} else {
		_fgeg = _dgdg[len(_dgdg)/2]
	}
	return MakeNumberResult(_fgeg)
}
func _dbfd(_efge int) bool {
	if _efge == _efge/400*400 {
		return true
	}
	if _efge == _efge/100*100 {
		return false
	}
	return _efge == _efge/4*4
}

// Nper implements the Excel NPER function.
func Nper(args []Result) Result {
	_abfa := len(args)
	if _abfa < 3 || _abfa > 5 {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067e\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u0020\u0035")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("N\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_cgfc := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0070\u0061y\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fbcc := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_feb := args[2].ValueNumber
	_fbaf := 0.0
	if _abfa >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_fbaf = args[3].ValueNumber
	}
	_cbae := 0.0
	if _abfa == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("N\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_cbae = args[4].ValueNumber
		if _cbae != 0 {
			_cbae = 1
		}
	}
	_agbd := _fbcc*(1+_cgfc*_cbae) - _fbaf*_cgfc
	_fbca := (_feb*_cgfc + _fbcc*(1+_cgfc*_cbae))
	return MakeNumberResult(_gg.Log(_agbd/_fbca) / _gg.Log(1+_cgfc))
}
func _gdgb(_gag []Result, _daeb string) (*couponArgs, Result) {
	_ggdf := len(_gag)
	if _ggdf != 3 && _ggdf != 4 {
		return nil, MakeErrorResult(_daeb + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u0066o\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_afag, _afdag, _gbab := _daea(_gag[0], _gag[1], _daeb)
	if _gbab.Type == ResultTypeError {
		return nil, _gbab
	}
	if _gag[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_daeb + "\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fde := _gag[2].ValueNumber
	if !_degc(_fde) {
		return nil, MakeErrorResult("\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0065q\u0075\u0065\u006e\u0063\u0079\u0020\u0066\u006f\u0072\u0020" + _daeb)
	}
	_ece := 0
	if _ggdf == 4 && _gag[3].Type != ResultTypeEmpty {
		if _gag[3].Type != ResultTypeNumber {
			return nil, MakeErrorResult(_daeb + "\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_ece = int(_gag[3].ValueNumber)
		if !_efb(_ece) {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020"+_daeb)
		}
	}
	return &couponArgs{_afag, _afdag, int(_fde), _ece}, _aaa
}

// SumSquares is an implementation of the Excel SUMSQ() function.
func SumSquares(args []Result) Result {
	_effca := MakeNumberResult(0)
	for _, _ebcad := range args {
		_ebcad = _ebcad.AsNumber()
		switch _ebcad.Type {
		case ResultTypeNumber:
			_effca.ValueNumber += _ebcad.ValueNumber * _ebcad.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_agbff := SumSquares(_ebcad.ListValues())
			if _agbff.Type != ResultTypeNumber {
				return _agbff
			}
			_effca.ValueNumber += _agbff.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _ebcad
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_b.Sprintf("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0053\u0055\u004dS\u0051\u0055\u0041\u0052\u0045\u0053(\u0029\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0073", _ebcad.Type))
		}
	}
	return _effca
}

const _agdac = 57352

// NewPrefixRangeExpr constructs a new range with prefix.
func NewPrefixRangeExpr(pfx, from, to Expression) Expression { return PrefixRangeExpr{pfx, from, to} }

// Minute is an implementation of the Excel MINUTE() function.
func Minute(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0049\u004e\u0055T\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_ecce := args[0]
	switch _ecce.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(0)
	case ResultTypeNumber:
		_bde := _ddef(_ecce.ValueNumber)
		return MakeNumberResult(float64(_bde.Minute()))
	case ResultTypeString:
		_eaec := _fa.ToLower(_ecce.ValueString)
		if !_eab(_eaec) {
			_, _, _, _faaa, _ega := _dbbf(_eaec)
			if _ega.Type == ResultTypeError {
				_ega.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s\u0020\u0066\u006f\u0072\u0020\u004d\u0049\u004e\u0055\u0054\u0045"
				return _ega
			}
			if _faaa {
				return MakeNumberResult(0)
			}
		}
		_, _bdbd, _, _, _, _bbf := _cgfb(_eaec)
		if _bbf.Type == ResultTypeError {
			return _bbf
		}
		return MakeNumberResult(float64(_bdbd))
	default:
		return MakeErrorResult("\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u004d\u0049NU\u0054\u0045")
	}
}
func _ddaa(_fdggc []Result, _gbeaa bool, _bdfgg string) Result {
	var _bgfa, _abbf string
	if _gbeaa {
		_bgfa = "\u0074\u0068\u0072e\u0065"
		_abbf = "\u006f\u0064\u0064"
	} else {
		_bgfa = "\u0074\u0077\u006f"
		_abbf = "\u0065\u0076\u0065\u006e"
	}
	_ddafe := len(_fdggc)
	if (_gbeaa && _ddafe < 3) || (!_gbeaa && _ddafe < 2) {
		return MakeErrorResult(_bdfgg + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020" + _bgfa + " \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0073")
	}
	if (_ddafe/2*2 == _ddafe) == _gbeaa {
		return MakeErrorResult(_bdfgg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _abbf + " \u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020a\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_fgdca := -1
	_ecceb := -1
	for _cdfbd := 0; _cdfbd < _ddafe; _cdfbd += 2 {
		_cacdg := _fdggc[_cdfbd]
		if _cacdg.Type != ResultTypeArray && _cacdg.Type != ResultTypeList {
			return MakeErrorResult(_bdfgg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u006e\u0067\u0065\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065 \u006c\u0069\u0073\u0074\u0020o\u0072\u0020a\u0072\u0072\u0061\u0079")
		}
		_eggb := _aefda(_cacdg)
		if _ecceb == -1 {
			_ecceb = len(_eggb)
			_fgdca = len(_eggb[0])
		} else if len(_eggb) != _ecceb || len(_eggb[0]) != _fgdca {
			return MakeErrorResult(_bdfgg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0061l\u006c\u0020\u0072\u0061n\u0067\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065\u0020\u0073\u0069\u007a\u0065")
		}
		if _gbeaa && _cdfbd == 0 {
			_cdfbd--
		}
	}
	return _aaa
}

// Code is an implementation of the Excel CODE function that returns the first
// character of the string as a number.
func Code(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u004f\u0044\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_acdc := args[0].AsString()
	if _acdc.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u004f\u0044\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if len(_acdc.ValueString) == 0 {
		return MakeNumberResult(0)
	}
	return MakeNumberResult(float64(_acdc.ValueString[0]))
}

// RoundUp is an implementation of the Excel ROUNDUP function that rounds a number
// up to a specified number of digits.
func RoundUp(args []Result) Result { return _bbge(args, _fdddb) }

// String returns a string representation of a horizontal range.
func (_caaff HorizontalRange) String() string { return _caaff.horizontalRangeReference() }

type ri struct {
	_dgfgg  float64
	_faafcg string
}

// And is an implementation of the Excel AND() function.
func And(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0041\u004e\u0044 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061t\u0020l\u0065a\u0073t\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gdgf := true
	for _, _eegfg := range args {
		_eegfg = _eegfg.AsNumber()
		switch _eegfg.Type {
		case ResultTypeList, ResultTypeArray:
			_ccfg := And(_eegfg.ListValues())
			if _ccfg.Type == ResultTypeError {
				return _ccfg
			}
			if _ccfg.ValueNumber == 0 {
				_gdgf = false
			}
		case ResultTypeNumber:
			if _eegfg.ValueNumber == 0 {
				_gdgf = false
			}
		case ResultTypeString:
			return MakeErrorResult("\u0041\u004e\u0044\u0020\u0064\u006f\u0065\u0073\u006e\u0027t\u0020\u006f\u0070\u0065\u0072\u0061\u0074e\u0020\u006f\u006e\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0073")
		case ResultTypeError:
			return _eegfg
		default:
			return MakeErrorResult("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0061\u0072\u0067u\u006de\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0041\u004e\u0044")
		}
	}
	return MakeBoolResult(_gdgf)
}

// Search is an implementation of the Excel SEARCH().
func Search(args []Result) Result {
	_gccbg, _aabcc := _gfag("\u0046\u0049\u004e\u0044", args)
	if _aabcc.Type != ResultTypeEmpty {
		return _aabcc
	}
	_bbce := _fa.ToLower(_gccbg._fcac)
	if _bbce == "" {
		return MakeNumberResult(1.0)
	}
	_fabe := _fa.ToLower(_gccbg._edegc)
	_dfea := _gccbg._edafc
	_eaggg := 1
	for _ggfee := range _fabe {
		if _eaggg < _dfea {
			_eaggg++
			continue
		}
		_acagg := _d.Index(_bbce, _fabe[_ggfee:])
		if _acagg == 0 {
			return MakeNumberResult(float64(_eaggg))
		}
		_eaggg++
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// Update updates references in the Range after removing a row/column.
func (_afdd Range) Update(q *_egg.UpdateQuery) Expression {
	_baab := _afdd
	if q.UpdateCurrentSheet {
		_baab._ecgg = _afdd._ecgg.Update(q)
		_baab._bgfde = _afdd._bgfde.Update(q)
	}
	return _baab
}

type yyParserImpl struct {
	_fgcde yySymType
	_bdbge [_cbacc]yySymType
	_febg  int
}

// Mod is an implementation of the Excel MOD function which returns the
// remainder after division. It requires two numeric argumnts.
func Mod(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004d\u004fD(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0074wo\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_fadc := args[0].AsNumber()
	_edee := args[1].AsNumber()
	if _fadc.Type != ResultTypeNumber || _edee.Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u004fD(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0074wo\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	if _edee.ValueNumber == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "M\u004fD\u0028\u0029\u0020\u0064\u0069\u0076\u0069\u0064e\u0020\u0062\u0079\u0020ze\u0072\u006f")
	}
	_bggea, _bbdaf := _gg.Modf(_fadc.ValueNumber / _edee.ValueNumber)
	if _bbdaf < 0 {
		_bggea--
	}
	return MakeNumberResult(_fadc.ValueNumber - _edee.ValueNumber*_bggea)
}

// Pricemat implements the Excel PRICEMAT function.
func Pricemat(args []Result) Result {
	_bfdbe := len(args)
	if _bfdbe != 5 && _bfdbe != 6 {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0069v\u0065\u0020\u006f\u0072\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_aafcb, _fcgdf, _affb := _daea(args[0], args[1], "\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054")
	if _affb.Type == ResultTypeError {
		return _affb
	}
	_dbgc, _affb := _dddb(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054")
	if _affb.Type == ResultTypeError {
		return _affb
	}
	if _dbgc >= _aafcb {
		return MakeErrorResult("\u0050\u0052\u0049\u0043E\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0062\u0065\u0066\u006fr\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052I\u0043\u0045\u004d\u0041T\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cafef := args[3].ValueNumber
	if _cafef < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045M\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cbga := args[4].ValueNumber
	if _cbga < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049C\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_fbd := 0
	if _bfdbe == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050R\u0049\u0043E\u004d\u0041\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_fbd = int(args[5].ValueNumber)
		if !_efb(_fbd) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0050\u0052\u0049C\u0045\u004d\u0041\u0054")
		}
	}
	_fbea, _affb := _cbfa(_aafcb, _fcgdf, _fbd)
	if _affb.Type == ResultTypeError {
		return _affb
	}
	_ccbc, _affb := _cbfa(_dbgc, _fcgdf, _fbd)
	if _affb.Type == ResultTypeError {
		return _affb
	}
	_bagdf, _affb := _cbfa(_dbgc, _aafcb, _fbd)
	if _affb.Type == ResultTypeError {
		return _affb
	}
	_daec := 1 + _ccbc*_cafef
	_aegff := 1 + _fbea*_cbga
	return MakeNumberResult((_daec/_aegff - _bagdf*_cafef) * 100)
}

// MakeErrorResult constructs a #VALUE! error with a given extra error message.
// The error message is for debugging formula evaluation only and is not stored
// in the sheet.
func MakeErrorResult(msg string) Result { return MakeErrorResultType(ErrorTypeValue, msg) }

// MDeterm is an implementation of the Excel MDETERM which finds the determinant
// of a matrix.
func MDeterm(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0044\u0045T\u0045\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0072\u0061\u0079 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dbca := args[0]
	if _dbca.Type != ResultTypeArray {
		return MakeErrorResult("\u004d\u0044\u0045T\u0045\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0072\u0061\u0079 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ffbe := len(_dbca.ValueArray)
	for _, _daddb := range _dbca.ValueArray {
		if len(_daddb) != _ffbe {
			return MakeErrorResult("\u004d\u0044\u0045TE\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u0061 \u0073\u0071\u0075\u0061\u0072\u0065\u0020\u006d\u0061\u0074\u0072\u0069\u0078")
		}
	}
	return MakeNumberResult(_bcadb(_dbca.ValueArray))
}

// Vdb implements the Excel VDB function.
func Vdb(args []Result) Result {
	_gccc := len(args)
	if _gccc < 5 || _gccc > 7 {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0062\u0065\u0074\u0077\u0065\u0065\u006e\u0020\u0066\u0069\u0076\u0065\u0020a\u006e\u0064\u0020\u0073\u0065v\u0065\u006e")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_aebg := args[0].ValueNumber
	if _aebg < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044B \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 co\u0073t \u0074\u006f\u0020\u0062\u0065\u0020\u006eon\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_febc := args[1].ValueNumber
	if _febc < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gegb := args[2].ValueNumber
	if _gegb == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if _gegb < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("V\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0074\u0061\u0072\u0074 p\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gbfe := args[3].ValueNumber
	if _gbfe < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065\u0073\u0073\u0020\u0074h\u0061n\u0020\u006f\u006e\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056D\u0042\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0065\u006e\u0064 \u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fbbd := args[4].ValueNumber
	if _gbfe > _fbbd {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020s\u0074\u0061\u0072\u0074\u0020\u0070\u0065r\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0056\u0044\u0042")
	}
	if _fbbd > _gegb {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0065\u006e\u0064\u0020\u0070e\u0072i\u006f\u0064\u0020\u0066\u006f\u0072\u0020V\u0044\u0042")
	}
	_abda := 2.0
	if _gccc > 5 {
		if args[5].Type == ResultTypeEmpty {
			_abda = 0.0
		} else {
			if args[5].Type != ResultTypeNumber {
				return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
			}
			_abda = args[5].ValueNumber
			if _abda < 0 {
				return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
			}
		}
	}
	_bfb := false
	if _gccc > 6 && args[6].Type != ResultTypeEmpty {
		if args[6].Type != ResultTypeNumber {
			return MakeErrorResult("\u0056D\u0042\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020n\u006f\u005f\u0073\u0077\u0069\u0074\u0063\u0068\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
		}
		_bfb = args[6].ValueNumber != 0
	}
	_afcf := 0.0
	_gffeg := _gg.Floor(_gbfe)
	_dfef := _gg.Ceil(_fbbd)
	if _bfb {
		for _ffgg := _gffeg + 1; _ffgg <= _dfef; _ffgg++ {
			_dgbe := _cdcfb(_aebg, _febc, _gegb, _ffgg, _abda)
			if _ffgg == _gffeg+1 {
				_dgbe *= _gg.Min(_fbbd, _gffeg+1) - _gbfe
			} else if _ffgg == _dfef {
				_dgbe *= _fbbd + 1 - _dfef
			}
			_afcf += _dgbe
		}
	} else {
		_dbadg := _gegb
		var _aabfa float64
		if !_agef(_gbfe, _gg.Floor(_gbfe)) {
			if _abda == 1 {
				_fegc := _gegb / 2
				if _gbfe > _fegc || _agef(_gbfe, _fegc) {
					_aabfa = _gbfe - _fegc
					_gbfe = _fegc
					_fbbd -= _aabfa
					_dbadg++
				}
			}
		}
		if _abda != 0 {
			_aebg -= _dceg(_aebg, _febc, _gegb, _dbadg, _gbfe, _abda)
		}
		_afcf = _dceg(_aebg, _febc, _gegb, _gegb-_gbfe, _fbbd-_gbfe, _abda)
	}
	return MakeNumberResult(_afcf)
}

const _gabb int = 30

// Average implements the AVERAGE function. It differs slightly from Excel (and
// agrees with LibreOffice) in that boolean values are counted. As an example,
// AVERAGE of two cells containing TRUE & FALSE is 0.5 in LibreOffice and
// #DIV/0! in Excel. unioffice will return 0.5 in this case.
func Average(args []Result) Result {
	_ebea, _dacg := _dfaca(args, false)
	if _dacg == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0041\u0056\u0045\u0052AG\u0045\u0020\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065r\u006f")
	}
	return MakeNumberResult(_ebea / _dacg)
}
