//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sharedTypes

import (
	_cc "encoding/xml"
	_d "fmt"
	_g "regexp"
)

// ST_TwipsMeasure is a union type
type ST_TwipsMeasure struct {
	ST_UnsignedDecimalNumber    *uint64
	ST_PositiveUniversalMeasure *string
}

const (
	ST_CryptProvUnset   ST_CryptProv = 0
	ST_CryptProvRsaAES  ST_CryptProv = 1
	ST_CryptProvRsaFull ST_CryptProv = 2
	ST_CryptProvCustom  ST_CryptProv = 3
)

func (_ggd *ST_AlgClass) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_gc, _ccb := d.Token()
	if _ccb != nil {
		return _ccb
	}
	if _dbd, _fba := _gc.(_cc.EndElement); _fba && _dbd.Name == start.Name {
		*_ggd = 1
		return nil
	}
	if _cbb, _dcg := _gc.(_cc.CharData); !_dcg {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gc)
	} else {
		switch string(_cbb) {
		case "":
			*_ggd = 0
		case "\u0068\u0061\u0073\u0068":
			*_ggd = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_ggd = 2
		}
	}
	_gc, _ccb = d.Token()
	if _ccb != nil {
		return _ccb
	}
	if _ae, _ge := _gc.(_cc.EndElement); _ge && _ae.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gc)
}
func (_e *ST_OnOff) Validate() error { return _e.ValidateWithPath("") }
func (_gcd ST_CryptProv) String() string {
	switch _gcd {
	case 0:
		return ""
	case 1:
		return "\u0072\u0073\u0061\u0041\u0045\u0053"
	case 2:
		return "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case 3:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}
func (_dg ST_AlgClass) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_dg.String(), start)
}
func (_cdd ST_CalendarType) Validate() error { return _cdd.ValidateWithPath("") }
func (_gfg ST_XAlign) Validate() error       { return _gfg.ValidateWithPath("") }
func (_edde *ST_YAlign) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_edde = 0
	case "\u0069\u006e\u006c\u0069\u006e\u0065":
		*_edde = 1
	case "\u0074\u006f\u0070":
		*_edde = 2
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_edde = 3
	case "\u0062\u006f\u0074\u0074\u006f\u006d":
		*_edde = 4
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_edde = 5
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_edde = 6
	}
	return nil
}
func (_afd ST_TrueFalse) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_afd.String(), start)
}
func (_abd *ST_TrueFalse) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_abd = 0
	case "\u0074":
		*_abd = 1
	case "\u0066":
		*_abd = 2
	case "\u0074\u0072\u0075\u0065":
		*_abd = 3
	case "\u0066\u0061\u006cs\u0065":
		*_abd = 4
	}
	return nil
}
func (_gde ST_VerticalAlignRun) String() string {
	switch _gde {
	case 0:
		return ""
	case 1:
		return "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case 2:
		return "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case 3:
		return "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return ""
}

const ST_GuidPattern = "\u005c\u007b\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b\u0038\u007d\u002d\u005b\u0030\u002d9\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030-\u0039\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b4\u007d\u002d\u005b\u0030\u002d\u0039A\u002d\u0046]\u007b\u00312\u007d\\\u007d"

func (_egc ST_VerticalAlignRun) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_egc.String(), start)
}

const (
	ST_AlgTypeUnset   ST_AlgType = 0
	ST_AlgTypeTypeAny ST_AlgType = 1
	ST_AlgTypeCustom  ST_AlgType = 2
)
const ST_PositiveUniversalMeasurePattern = "\u005b\u0030-9\u005d\u002b\u0028\\\u002e\u005b\u0030\u002d9]+\u0029?(\u006d\u006d\u007c\u0063\u006d\u007c\u0069n|\u0070\u0074\u007c\u0070\u0063\u007c\u0070i\u0029"

func (_dcff *ST_TrueFalseBlank) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_fdg, _abe := d.Token()
	if _abe != nil {
		return _abe
	}
	if _dag, _ffg := _fdg.(_cc.EndElement); _ffg && _dag.Name == start.Name {
		*_dcff = 1
		return nil
	}
	if _fbaf, _aed := _fdg.(_cc.CharData); !_aed {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _fdg)
	} else {
		switch string(_fbaf) {
		case "":
			*_dcff = 0
		case "\u0074":
			*_dcff = 1
		case "\u0066":
			*_dcff = 2
		case "\u0074\u0072\u0075\u0065":
			*_dcff = 3
		case "\u0066\u0061\u006cs\u0065":
			*_dcff = 4
		case "\u0054\u0072\u0075\u0065":
			*_dcff = 6
		case "\u0046\u0061\u006cs\u0065":
			*_dcff = 7
		}
	}
	_fdg, _abe = d.Token()
	if _abe != nil {
		return _abe
	}
	if _dbce, _ffa := _fdg.(_cc.EndElement); _ffa && _dbce.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _fdg)
}
func (_dd *ST_TrueFalseBlank) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_dd = 0
	case "\u0074":
		*_dd = 1
	case "\u0066":
		*_dd = 2
	case "\u0074\u0072\u0075\u0065":
		*_dd = 3
	case "\u0066\u0061\u006cs\u0065":
		*_dd = 4
	case "\u0054\u0072\u0075\u0065":
		*_dd = 6
	case "\u0046\u0061\u006cs\u0065":
		*_dd = 7
	}
	return nil
}

const (
	ST_TrueFalseBlankUnset  ST_TrueFalseBlank = 0
	ST_TrueFalseBlankT      ST_TrueFalseBlank = 1
	ST_TrueFalseBlankF      ST_TrueFalseBlank = 2
	ST_TrueFalseBlankTrue   ST_TrueFalseBlank = 3
	ST_TrueFalseBlankFalse  ST_TrueFalseBlank = 4
	ST_TrueFalseBlankTrue_  ST_TrueFalseBlank = 6
	ST_TrueFalseBlankFalse_ ST_TrueFalseBlank = 7
)

func (_ac ST_TrueFalseBlank) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_eee := _cc.Attr{}
	_eee.Name = name
	switch _ac {
	case ST_TrueFalseBlankUnset:
		_eee.Value = ""
	case ST_TrueFalseBlankT:
		_eee.Value = "\u0074"
	case ST_TrueFalseBlankF:
		_eee.Value = "\u0066"
	case ST_TrueFalseBlankTrue:
		_eee.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse:
		_eee.Value = "\u0066\u0061\u006cs\u0065"
	case ST_TrueFalseBlankTrue_:
		_eee.Value = "\u0054\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse_:
		_eee.Value = "\u0046\u0061\u006cs\u0065"
	}
	return _eee, nil
}
func (_ee ST_AlgClass) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_fb := _cc.Attr{}
	_fb.Name = name
	switch _ee {
	case ST_AlgClassUnset:
		_fb.Value = ""
	case ST_AlgClassHash:
		_fb.Value = "\u0068\u0061\u0073\u0068"
	case ST_AlgClassCustom:
		_fb.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _fb, nil
}
func _dbf(_eb bool) uint8 {
	if _eb {
		return 1
	}
	return 0
}
func (_fa *ST_CryptProv) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_bf, _ab := d.Token()
	if _ab != nil {
		return _ab
	}
	if _gf, _edd := _bf.(_cc.EndElement); _edd && _gf.Name == start.Name {
		*_fa = 1
		return nil
	}
	if _fbe, _eg := _bf.(_cc.CharData); !_eg {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bf)
	} else {
		switch string(_fbe) {
		case "":
			*_fa = 0
		case "\u0072\u0073\u0061\u0041\u0045\u0053":
			*_fa = 1
		case "\u0072s\u0061\u0046\u0075\u006c\u006c":
			*_fa = 2
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_fa = 3
		}
	}
	_bf, _ab = d.Token()
	if _ab != nil {
		return _ab
	}
	if _gdg, _cg := _bf.(_cc.EndElement); _cg && _gdg.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bf)
}
func (_ea ST_TwipsMeasure) String() string {
	if _ea.ST_UnsignedDecimalNumber != nil {
		return _d.Sprintf("\u0025\u0076", *_ea.ST_UnsignedDecimalNumber)
	}
	if _ea.ST_PositiveUniversalMeasure != nil {
		return _d.Sprintf("\u0025\u0076", *_ea.ST_PositiveUniversalMeasure)
	}
	return ""
}

const ST_PercentagePattern = "-\u003f[\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e[\u0030\u002d\u0039\u005d+)\u003f\u0025"

func (_dgg ST_AlgClass) ValidateWithPath(path string) error {
	switch _dgg {
	case 0, 1, 2:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dgg))
	}
	return nil
}

const (
	ST_AlgClassUnset  ST_AlgClass = 0
	ST_AlgClassHash   ST_AlgClass = 1
	ST_AlgClassCustom ST_AlgClass = 2
)

// ST_OnOff is a union type
type ST_OnOff struct {
	Bool      *bool
	ST_OnOff1 ST_OnOff1
}

func (_a *ST_TwipsMeasure) Validate() error { return _a.ValidateWithPath("") }
func (_feb *ST_XAlign) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_cfc, _fcg := d.Token()
	if _fcg != nil {
		return _fcg
	}
	if _cbf, _ecd := _cfc.(_cc.EndElement); _ecd && _cbf.Name == start.Name {
		*_feb = 1
		return nil
	}
	if _ecf, _ebcc := _cfc.(_cc.CharData); !_ebcc {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cfc)
	} else {
		switch string(_ecf) {
		case "":
			*_feb = 0
		case "\u006c\u0065\u0066\u0074":
			*_feb = 1
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_feb = 2
		case "\u0072\u0069\u0067h\u0074":
			*_feb = 3
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_feb = 4
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_feb = 5
		}
	}
	_cfc, _fcg = d.Token()
	if _fcg != nil {
		return _fcg
	}
	if _cac, _ece := _cfc.(_cc.EndElement); _ece && _cac.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cfc)
}

const ST_FixedPercentagePattern = "-\u003f\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039]\u003f\u0029\u0029\u0028\u005c\u002e\u005b\u0030\u002d\u0039][\u0030\u002d\u0039]\u003f)\u003f\u0025"
const ST_UniversalMeasurePattern = "\u002d\u003f\u005b\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e\u005b\u0030\u002d\u0039\u005d\u002b\u0029\u003f\u0028\u006d\u006d\u007c\u0063m\u007c\u0069\u006e\u007c\u0070t\u007c\u0070c\u007c\u0070\u0069\u0029"

type ST_OnOff1 byte

func (_fcc ST_OnOff1) String() string {
	switch _fcc {
	case 0:
		return ""
	case 1:
		return "\u006f\u006e"
	case 2:
		return "\u006f\u0066\u0066"
	}
	return ""
}
func (_ebad ST_TrueFalseBlank) ValidateWithPath(path string) error {
	switch _ebad {
	case 0, 1, 2, 3, 4, 6, 7:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ebad))
	}
	return nil
}
func (_bg ST_OnOff1) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_afb := _cc.Attr{}
	_afb.Name = name
	switch _bg {
	case ST_OnOff1Unset:
		_afb.Value = ""
	case ST_OnOff1On:
		_afb.Value = "\u006f\u006e"
	case ST_OnOff1Off:
		_afb.Value = "\u006f\u0066\u0066"
	}
	return _afb, nil
}
func (_dec *ST_CalendarType) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_dec = 0
	case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
		*_dec = 1
	case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
		*_dec = 2
	case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
		*_dec = 3
	case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
		*_dec = 4
	case "\u0068\u0069\u006ar\u0069":
		*_dec = 5
	case "\u0068\u0065\u0062\u0072\u0065\u0077":
		*_dec = 6
	case "\u0074\u0061\u0069\u0077\u0061\u006e":
		*_dec = 7
	case "\u006a\u0061\u0070a\u006e":
		*_dec = 8
	case "\u0074\u0068\u0061\u0069":
		*_dec = 9
	case "\u006b\u006f\u0072e\u0061":
		*_dec = 10
	case "\u0073\u0061\u006b\u0061":
		*_dec = 11
	case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
		*_dec = 12
	case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
		*_dec = 13
	case "\u006e\u006f\u006e\u0065":
		*_dec = 14
	}
	return nil
}
func (_ebc *ST_XAlign) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_ebc = 0
	case "\u006c\u0065\u0066\u0074":
		*_ebc = 1
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_ebc = 2
	case "\u0072\u0069\u0067h\u0074":
		*_ebc = 3
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_ebc = 4
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_ebc = 5
	}
	return nil
}
func (_gfc ST_AlgType) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_gdf := _cc.Attr{}
	_gdf.Name = name
	switch _gfc {
	case ST_AlgTypeUnset:
		_gdf.Value = ""
	case ST_AlgTypeTypeAny:
		_gdf.Value = "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case ST_AlgTypeCustom:
		_gdf.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _gdf, nil
}

const (
	ST_OnOff1Unset ST_OnOff1 = 0
	ST_OnOff1On    ST_OnOff1 = 1
	ST_OnOff1Off   ST_OnOff1 = 2
)

func (_def *ST_YAlign) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_cdbg, _beag := d.Token()
	if _beag != nil {
		return _beag
	}
	if _cad, _baac := _cdbg.(_cc.EndElement); _baac && _cad.Name == start.Name {
		*_def = 1
		return nil
	}
	if _degg, _ebaa := _cdbg.(_cc.CharData); !_ebaa {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cdbg)
	} else {
		switch string(_degg) {
		case "":
			*_def = 0
		case "\u0069\u006e\u006c\u0069\u006e\u0065":
			*_def = 1
		case "\u0074\u006f\u0070":
			*_def = 2
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_def = 3
		case "\u0062\u006f\u0074\u0074\u006f\u006d":
			*_def = 4
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_def = 5
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_def = 6
		}
	}
	_cdbg, _beag = d.Token()
	if _beag != nil {
		return _beag
	}
	if _ga, _eacd := _cdbg.(_cc.EndElement); _eacd && _ga.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cdbg)
}
func (_ega *ST_AlgType) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_ega = 0
	case "\u0074y\u0070\u0065\u0041\u006e\u0079":
		*_ega = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_ega = 2
	}
	return nil
}
func (_ede ST_TrueFalse) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_age := _cc.Attr{}
	_age.Name = name
	switch _ede {
	case ST_TrueFalseUnset:
		_age.Value = ""
	case ST_TrueFalseT:
		_age.Value = "\u0074"
	case ST_TrueFalseF:
		_age.Value = "\u0066"
	case ST_TrueFalseTrue:
		_age.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseFalse:
		_age.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _age, nil
}
func (_cbd ST_AlgType) ValidateWithPath(path string) error {
	switch _cbd {
	case 0, 1, 2:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_cbd))
	}
	return nil
}
func (_bec *ST_AlgType) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_gfe, _eea := d.Token()
	if _eea != nil {
		return _eea
	}
	if _caf, _dbe := _gfe.(_cc.EndElement); _dbe && _caf.Name == start.Name {
		*_bec = 1
		return nil
	}
	if _aad, _egd := _gfe.(_cc.CharData); !_egd {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gfe)
	} else {
		switch string(_aad) {
		case "":
			*_bec = 0
		case "\u0074y\u0070\u0065\u0041\u006e\u0079":
			*_bec = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_bec = 2
		}
	}
	_gfe, _eea = d.Token()
	if _eea != nil {
		return _eea
	}
	if _bcd, _ag := _gfe.(_cc.EndElement); _ag && _bcd.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gfe)
}
func (_dc ST_CalendarType) ValidateWithPath(path string) error {
	switch _dc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dc))
	}
	return nil
}
func (_gda ST_OnOff1) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_gda.String(), start)
}
func (_egb ST_ConformanceClass) String() string {
	switch _egb {
	case 0:
		return ""
	case 1:
		return "\u0073\u0074\u0072\u0069\u0063\u0074"
	case 2:
		return "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return ""
}
func (_db *ST_TwipsMeasure) ValidateWithPath(path string) error {
	_aa := []string{}
	if _db.ST_UnsignedDecimalNumber != nil {
		_aa = append(_aa, "\u0053T\u005f\u0055\u006e\u0073\u0069\u0067\u006e\u0065\u0064\u0044\u0065c\u0069\u006d\u0061\u006c\u004e\u0075\u006d\u0062\u0065\u0072")
	}
	if _db.ST_PositiveUniversalMeasure != nil {
		_aa = append(_aa, "S\u0054\u005f\u0050\u006f\u0073\u0069t\u0069\u0076\u0065\u0055\u006e\u0069\u0076\u0065\u0072s\u0061\u006c\u004de\u0061s\u0075\u0072\u0065")
	}
	if len(_aa) > 1 {
		return _d.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _aa)
	}
	return nil
}
func (_dbga ST_AlgType) String() string {
	switch _dbga {
	case 0:
		return ""
	case 1:
		return "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}
func (_eef ST_YAlign) ValidateWithPath(path string) error {
	switch _eef {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_eef))
	}
	return nil
}
func (_gdb *ST_AlgClass) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_gdb = 0
	case "\u0068\u0061\u0073\u0068":
		*_gdb = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_gdb = 2
	}
	return nil
}
func (_aca *ST_ConformanceClass) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_aca = 0
	case "\u0073\u0074\u0072\u0069\u0063\u0074":
		*_aca = 1
	case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
		*_aca = 2
	}
	return nil
}
func (_aeb ST_AlgType) Validate() error { return _aeb.ValidateWithPath("") }
func (_ed ST_AlgClass) Validate() error { return _ed.ValidateWithPath("") }
func (_cgb *ST_OnOff1) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_gdd, _fgb := d.Token()
	if _fgb != nil {
		return _fgb
	}
	if _ad, _fac := _gdd.(_cc.EndElement); _fac && _ad.Name == start.Name {
		*_cgb = 1
		return nil
	}
	if _eac, _bgg := _gdd.(_cc.CharData); !_bgg {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gdd)
	} else {
		switch string(_eac) {
		case "":
			*_cgb = 0
		case "\u006f\u006e":
			*_cgb = 1
		case "\u006f\u0066\u0066":
			*_cgb = 2
		}
	}
	_gdd, _fgb = d.Token()
	if _fgb != nil {
		return _fgb
	}
	if _gga, _dgae := _gdd.(_cc.EndElement); _dgae && _gga.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gdd)
}
func (_gdcf ST_TrueFalse) String() string {
	switch _gdcf {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}
func (_de ST_OnOff) String() string {
	if _de.Bool != nil {
		return _d.Sprintf("\u0025\u0076", *_de.Bool)
	}
	if _de.ST_OnOff1 != ST_OnOff1Unset {
		return _de.ST_OnOff1.String()
	}
	return ""
}
func (_cee *ST_TrueFalse) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_fef, _cag := d.Token()
	if _cag != nil {
		return _cag
	}
	if _bea, _aab := _fef.(_cc.EndElement); _aab && _bea.Name == start.Name {
		*_cee = 1
		return nil
	}
	if _feg, _dcf := _fef.(_cc.CharData); !_dcf {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _fef)
	} else {
		switch string(_feg) {
		case "":
			*_cee = 0
		case "\u0074":
			*_cee = 1
		case "\u0066":
			*_cee = 2
		case "\u0074\u0072\u0075\u0065":
			*_cee = 3
		case "\u0066\u0061\u006cs\u0065":
			*_cee = 4
		}
	}
	_fef, _cag = d.Token()
	if _cag != nil {
		return _cag
	}
	if _gdc, _baae := _fef.(_cc.EndElement); _baae && _gdc.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _fef)
}

var ST_GuidPatternRe = _g.MustCompile(ST_GuidPattern)

func (_b ST_CalendarType) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_fg := _cc.Attr{}
	_fg.Name = name
	switch _b {
	case ST_CalendarTypeUnset:
		_fg.Value = ""
	case ST_CalendarTypeGregorian:
		_fg.Value = "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case ST_CalendarTypeGregorianUs:
		_fg.Value = "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case ST_CalendarTypeGregorianMeFrench:
		_fg.Value = "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeGregorianArabic:
		_fg.Value = "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case ST_CalendarTypeHijri:
		_fg.Value = "\u0068\u0069\u006ar\u0069"
	case ST_CalendarTypeHebrew:
		_fg.Value = "\u0068\u0065\u0062\u0072\u0065\u0077"
	case ST_CalendarTypeTaiwan:
		_fg.Value = "\u0074\u0061\u0069\u0077\u0061\u006e"
	case ST_CalendarTypeJapan:
		_fg.Value = "\u006a\u0061\u0070a\u006e"
	case ST_CalendarTypeThai:
		_fg.Value = "\u0074\u0068\u0061\u0069"
	case ST_CalendarTypeKorea:
		_fg.Value = "\u006b\u006f\u0072e\u0061"
	case ST_CalendarTypeSaka:
		_fg.Value = "\u0073\u0061\u006b\u0061"
	case ST_CalendarTypeGregorianXlitEnglish:
		_fg.Value = "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case ST_CalendarTypeGregorianXlitFrench:
		_fg.Value = "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeNone:
		_fg.Value = "\u006e\u006f\u006e\u0065"
	}
	return _fg, nil
}
func (_agd ST_OnOff1) ValidateWithPath(path string) error {
	switch _agd {
	case 0, 1, 2:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_agd))
	}
	return nil
}

type ST_AlgType byte

func (_bede ST_ConformanceClass) Validate() error { return _bede.ValidateWithPath("") }
func (_eba *ST_OnOff1) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_eba = 0
	case "\u006f\u006e":
		*_eba = 1
	case "\u006f\u0066\u0066":
		*_eba = 2
	}
	return nil
}
func (_dba ST_TrueFalse) Validate() error { return _dba.ValidateWithPath("") }
func (_fe ST_CryptProv) Validate() error  { return _fe.ValidateWithPath("") }
func (_dbg *ST_CryptProv) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_dbg = 0
	case "\u0072\u0073\u0061\u0041\u0045\u0053":
		*_dbg = 1
	case "\u0072s\u0061\u0046\u0075\u006c\u006c":
		*_dbg = 2
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_dbg = 3
	}
	return nil
}
func (_agec ST_XAlign) String() string {
	switch _agec {
	case 0:
		return ""
	case 1:
		return "\u006c\u0065\u0066\u0074"
	case 2:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 5:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}
func (_ddg ST_XAlign) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_cbg := _cc.Attr{}
	_cbg.Name = name
	switch _ddg {
	case ST_XAlignUnset:
		_cbg.Value = ""
	case ST_XAlignLeft:
		_cbg.Value = "\u006c\u0065\u0066\u0074"
	case ST_XAlignCenter:
		_cbg.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_XAlignRight:
		_cbg.Value = "\u0072\u0069\u0067h\u0074"
	case ST_XAlignInside:
		_cbg.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_XAlignOutside:
		_cbg.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _cbg, nil
}
func ParseUnionST_OnOff(s string) (ST_OnOff, error) {
	_cd := ST_OnOff{}
	switch s {
	case "\u0074\u0072\u0075\u0065", "\u0031", "\u006f\u006e":
		_fc := true
		_cd.Bool = &_fc
	default:
		_ca := false
		_cd.Bool = &_ca
	}
	return _cd, nil
}
func (_fd ST_TwipsMeasure) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	e.EncodeToken(start)
	if _fd.ST_UnsignedDecimalNumber != nil {
		e.EncodeToken(_cc.CharData(_d.Sprintf("\u0025\u0064", *_fd.ST_UnsignedDecimalNumber)))
	}
	if _fd.ST_PositiveUniversalMeasure != nil {
		e.EncodeToken(_cc.CharData(*_fd.ST_PositiveUniversalMeasure))
	}
	return e.EncodeToken(_cc.EndElement{Name: start.Name})
}

type ST_TrueFalseBlank byte

func (_baaa *ST_VerticalAlignRun) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_fgba, _fff := d.Token()
	if _fff != nil {
		return _fff
	}
	if _dde, _aee := _fgba.(_cc.EndElement); _aee && _dde.Name == start.Name {
		*_baaa = 1
		return nil
	}
	if _bfg, _fge := _fgba.(_cc.CharData); !_fge {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _fgba)
	} else {
		switch string(_bfg) {
		case "":
			*_baaa = 0
		case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
			*_baaa = 1
		case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
			*_baaa = 2
		case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
			*_baaa = 3
		}
	}
	_fgba, _fff = d.Token()
	if _fff != nil {
		return _fff
	}
	if _aae, _cdb := _fgba.(_cc.EndElement); _cdb && _aae.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _fgba)
}

type ST_CalendarType byte

var ST_PositivePercentagePatternRe = _g.MustCompile(ST_PositivePercentagePattern)

func (_f *ST_OnOff) ValidateWithPath(path string) error {
	_ce := []string{}
	if _f.Bool != nil {
		_ce = append(_ce, "\u0042\u006f\u006f\u006c")
	}
	if _f.ST_OnOff1 != ST_OnOff1Unset {
		_ce = append(_ce, "\u0053T\u005f\u004f\u006e\u004f\u0066\u00661")
	}
	if len(_ce) > 1 {
		return _d.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _ce)
	}
	return nil
}

const (
	ST_VerticalAlignRunUnset       ST_VerticalAlignRun = 0
	ST_VerticalAlignRunBaseline    ST_VerticalAlignRun = 1
	ST_VerticalAlignRunSuperscript ST_VerticalAlignRun = 2
	ST_VerticalAlignRunSubscript   ST_VerticalAlignRun = 3
)

func (_cddc ST_VerticalAlignRun) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_ef := _cc.Attr{}
	_ef.Name = name
	switch _cddc {
	case ST_VerticalAlignRunUnset:
		_ef.Value = ""
	case ST_VerticalAlignRunBaseline:
		_ef.Value = "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case ST_VerticalAlignRunSuperscript:
		_ef.Value = "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case ST_VerticalAlignRunSubscript:
		_ef.Value = "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return _ef, nil
}
func (_ec ST_XAlign) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_ec.String(), start)
}
func (_dca ST_TrueFalseBlank) String() string {
	switch _dca {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	case 6:
		return "\u0054\u0072\u0075\u0065"
	case 7:
		return "\u0046\u0061\u006cs\u0065"
	}
	return ""
}
func (_gd ST_OnOff) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	e.EncodeToken(start)
	if _gd.Bool != nil {
		e.EncodeToken(_cc.CharData(_d.Sprintf("\u0025\u0064", _dbf(*_gd.Bool))))
	}
	if _gd.ST_OnOff1 != ST_OnOff1Unset {
		e.EncodeToken(_cc.CharData(_gd.ST_OnOff1.String()))
	}
	return e.EncodeToken(_cc.EndElement{Name: start.Name})
}

const (
	ST_XAlignUnset   ST_XAlign = 0
	ST_XAlignLeft    ST_XAlign = 1
	ST_XAlignCenter  ST_XAlign = 2
	ST_XAlignRight   ST_XAlign = 3
	ST_XAlignInside  ST_XAlign = 4
	ST_XAlignOutside ST_XAlign = 5
)

func (_ccbe ST_YAlign) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_bggg := _cc.Attr{}
	_bggg.Name = name
	switch _ccbe {
	case ST_YAlignUnset:
		_bggg.Value = ""
	case ST_YAlignInline:
		_bggg.Value = "\u0069\u006e\u006c\u0069\u006e\u0065"
	case ST_YAlignTop:
		_bggg.Value = "\u0074\u006f\u0070"
	case ST_YAlignCenter:
		_bggg.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_YAlignBottom:
		_bggg.Value = "\u0062\u006f\u0074\u0074\u006f\u006d"
	case ST_YAlignInside:
		_bggg.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_YAlignOutside:
		_bggg.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _bggg, nil
}
func (_af ST_CryptProv) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_af.String(), start)
}

type ST_ConformanceClass byte

func (_gdcg ST_TrueFalseBlank) Validate() error { return _gdcg.ValidateWithPath("") }
func (_gccd ST_TrueFalseBlank) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_gccd.String(), start)
}

var ST_UniversalMeasurePatternRe = _g.MustCompile(ST_UniversalMeasurePattern)

type ST_XAlign byte

func (_bad ST_AlgType) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_bad.String(), start)
}

const ST_PositiveFixedPercentagePattern = "\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039\u005d\u003f\u0029\u0029\u0028\u005c\u002e[\u0030\u002d\u0039\u005d\u005b0\u002d\u0039]\u003f\u0029\u003f\u0025"
const (
	ST_ConformanceClassUnset        ST_ConformanceClass = 0
	ST_ConformanceClassStrict       ST_ConformanceClass = 1
	ST_ConformanceClassTransitional ST_ConformanceClass = 2
)

func (_bed ST_VerticalAlignRun) Validate() error { return _bed.ValidateWithPath("") }
func (_cgf ST_VerticalAlignRun) ValidateWithPath(path string) error {
	switch _cgf {
	case 0, 1, 2, 3:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_cgf))
	}
	return nil
}

var ST_PositiveUniversalMeasurePatternRe = _g.MustCompile(ST_PositiveUniversalMeasurePattern)

func (_gg ST_CalendarType) String() string {
	switch _gg {
	case 0:
		return ""
	case 1:
		return "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case 2:
		return "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case 3:
		return "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case 4:
		return "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case 5:
		return "\u0068\u0069\u006ar\u0069"
	case 6:
		return "\u0068\u0065\u0062\u0072\u0065\u0077"
	case 7:
		return "\u0074\u0061\u0069\u0077\u0061\u006e"
	case 8:
		return "\u006a\u0061\u0070a\u006e"
	case 9:
		return "\u0074\u0068\u0061\u0069"
	case 10:
		return "\u006b\u006f\u0072e\u0061"
	case 11:
		return "\u0073\u0061\u006b\u0061"
	case 12:
		return "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case 13:
		return "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case 14:
		return "\u006e\u006f\u006e\u0065"
	}
	return ""
}

const (
	ST_YAlignUnset   ST_YAlign = 0
	ST_YAlignInline  ST_YAlign = 1
	ST_YAlignTop     ST_YAlign = 2
	ST_YAlignCenter  ST_YAlign = 3
	ST_YAlignBottom  ST_YAlign = 4
	ST_YAlignInside  ST_YAlign = 5
	ST_YAlignOutside ST_YAlign = 6
)

func (_dbc ST_AlgClass) String() string {
	switch _dbc {
	case 0:
		return ""
	case 1:
		return "\u0068\u0061\u0073\u0068"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}

const ST_PositivePercentagePattern = "\u005b0\u002d9\u005d\u002b\u0028\u005c\u002e[\u0030\u002d9\u005d\u002b\u0029\u003f\u0025"

func (_cbdd ST_ConformanceClass) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_edb := _cc.Attr{}
	_edb.Name = name
	switch _cbdd {
	case ST_ConformanceClassUnset:
		_edb.Value = ""
	case ST_ConformanceClassStrict:
		_edb.Value = "\u0073\u0074\u0072\u0069\u0063\u0074"
	case ST_ConformanceClassTransitional:
		_edb.Value = "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return _edb, nil
}
func (_cdf ST_YAlign) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_cdf.String(), start)
}

const (
	ST_TrueFalseUnset ST_TrueFalse = 0
	ST_TrueFalseT     ST_TrueFalse = 1
	ST_TrueFalseF     ST_TrueFalse = 2
	ST_TrueFalseTrue  ST_TrueFalse = 3
	ST_TrueFalseFalse ST_TrueFalse = 4
)

func (_efe ST_XAlign) ValidateWithPath(path string) error {
	switch _efe {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_efe))
	}
	return nil
}

type ST_TrueFalse byte

func (_gcc ST_TrueFalse) ValidateWithPath(path string) error {
	switch _gcc {
	case 0, 1, 2, 3, 4:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gcc))
	}
	return nil
}
func (_eeg ST_ConformanceClass) ValidateWithPath(path string) error {
	switch _eeg {
	case 0, 1, 2:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_eeg))
	}
	return nil
}
func (_cba ST_OnOff1) Validate() error { return _cba.ValidateWithPath("") }

var ST_PercentagePatternRe = _g.MustCompile(ST_PercentagePattern)

func (_ceea *ST_VerticalAlignRun) UnmarshalXMLAttr(attr _cc.Attr) error {
	switch attr.Value {
	case "":
		*_ceea = 0
	case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
		*_ceea = 1
	case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
		*_ceea = 2
	case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
		*_ceea = 3
	}
	return nil
}

const (
	ST_CalendarTypeUnset                ST_CalendarType = 0
	ST_CalendarTypeGregorian            ST_CalendarType = 1
	ST_CalendarTypeGregorianUs          ST_CalendarType = 2
	ST_CalendarTypeGregorianMeFrench    ST_CalendarType = 3
	ST_CalendarTypeGregorianArabic      ST_CalendarType = 4
	ST_CalendarTypeHijri                ST_CalendarType = 5
	ST_CalendarTypeHebrew               ST_CalendarType = 6
	ST_CalendarTypeTaiwan               ST_CalendarType = 7
	ST_CalendarTypeJapan                ST_CalendarType = 8
	ST_CalendarTypeThai                 ST_CalendarType = 9
	ST_CalendarTypeKorea                ST_CalendarType = 10
	ST_CalendarTypeSaka                 ST_CalendarType = 11
	ST_CalendarTypeGregorianXlitEnglish ST_CalendarType = 12
	ST_CalendarTypeGregorianXlitFrench  ST_CalendarType = 13
	ST_CalendarTypeNone                 ST_CalendarType = 14
)

type ST_VerticalAlignRun byte

func (_fee ST_YAlign) Validate() error { return _fee.ValidateWithPath("") }
func (_ebd *ST_CalendarType) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_da, _be := d.Token()
	if _be != nil {
		return _be
	}
	if _ba, _fdd := _da.(_cc.EndElement); _fdd && _ba.Name == start.Name {
		*_ebd = 1
		return nil
	}
	if _caa, _bc := _da.(_cc.CharData); !_bc {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _da)
	} else {
		switch string(_caa) {
		case "":
			*_ebd = 0
		case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
			*_ebd = 1
		case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
			*_ebd = 2
		case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
			*_ebd = 3
		case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
			*_ebd = 4
		case "\u0068\u0069\u006ar\u0069":
			*_ebd = 5
		case "\u0068\u0065\u0062\u0072\u0065\u0077":
			*_ebd = 6
		case "\u0074\u0061\u0069\u0077\u0061\u006e":
			*_ebd = 7
		case "\u006a\u0061\u0070a\u006e":
			*_ebd = 8
		case "\u0074\u0068\u0061\u0069":
			*_ebd = 9
		case "\u006b\u006f\u0072e\u0061":
			*_ebd = 10
		case "\u0073\u0061\u006b\u0061":
			*_ebd = 11
		case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
			*_ebd = 12
		case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
			*_ebd = 13
		case "\u006e\u006f\u006e\u0065":
			*_ebd = 14
		}
	}
	_da, _be = d.Token()
	if _be != nil {
		return _be
	}
	if _cf, _cb := _da.(_cc.EndElement); _cb && _cf.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _da)
}
func (_gdbc ST_ConformanceClass) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_gdbc.String(), start)
}
func (_ff ST_CalendarType) MarshalXML(e *_cc.Encoder, start _cc.StartElement) error {
	return e.EncodeElement(_ff.String(), start)
}
func (_dga ST_CryptProv) MarshalXMLAttr(name _cc.Name) (_cc.Attr, error) {
	_deg := _cc.Attr{}
	_deg.Name = name
	switch _dga {
	case ST_CryptProvUnset:
		_deg.Value = ""
	case ST_CryptProvRsaAES:
		_deg.Value = "\u0072\u0073\u0061\u0041\u0045\u0053"
	case ST_CryptProvRsaFull:
		_deg.Value = "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case ST_CryptProvCustom:
		_deg.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _deg, nil
}
func (_baa ST_CryptProv) ValidateWithPath(path string) error {
	switch _baa {
	case 0, 1, 2, 3:
	default:
		return _d.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_baa))
	}
	return nil
}

var ST_FixedPercentagePatternRe = _g.MustCompile(ST_FixedPercentagePattern)
var ST_PositiveFixedPercentagePatternRe = _g.MustCompile(ST_PositiveFixedPercentagePattern)

type ST_CryptProv byte

func (_agc ST_YAlign) String() string {
	switch _agc {
	case 0:
		return ""
	case 1:
		return "\u0069\u006e\u006c\u0069\u006e\u0065"
	case 2:
		return "\u0074\u006f\u0070"
	case 3:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 4:
		return "\u0062\u006f\u0074\u0074\u006f\u006d"
	case 5:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 6:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}
func (_ggf *ST_ConformanceClass) UnmarshalXML(d *_cc.Decoder, start _cc.StartElement) error {
	_dcd, _fdb := d.Token()
	if _fdb != nil {
		return _fdb
	}
	if _afe, _beb := _dcd.(_cc.EndElement); _beb && _afe.Name == start.Name {
		*_ggf = 1
		return nil
	}
	if _feea, _ggae := _dcd.(_cc.CharData); !_ggae {
		return _d.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dcd)
	} else {
		switch string(_feea) {
		case "":
			*_ggf = 0
		case "\u0073\u0074\u0072\u0069\u0063\u0074":
			*_ggf = 1
		case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
			*_ggf = 2
		}
	}
	_dcd, _fdb = d.Token()
	if _fdb != nil {
		return _fdb
	}
	if _bac, _fgc := _dcd.(_cc.EndElement); _fgc && _bac.Name == start.Name {
		return nil
	}
	return _d.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dcd)
}

type ST_YAlign byte
type ST_AlgClass byte
