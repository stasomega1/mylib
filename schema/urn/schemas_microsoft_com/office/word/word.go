//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package word

import (
	_c "encoding/xml"
	_b "fmt"
	_g "github.com/unidoc/unioffice"
	_d "strconv"
)

func (_bab ST_BorderType) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_bab.String(), start)
}
func (_fb *Bordertop) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_fb.CT_Border = *NewCT_Border()
	for _, _dde := range start.Attr {
		if _dde.Name.Local == "\u0074\u0079\u0070\u0065" {
			_fb.TypeAttr.UnmarshalXMLAttr(_dde)
			continue
		}
		if _dde.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_fbe, _gac := _d.ParseUint(_dde.Value, 10, 32)
			if _gac != nil {
				return _gac
			}
			_fe := uint32(_fbe)
			_fb.WidthAttr = &_fe
			continue
		}
		if _dde.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_fb.ShadowAttr.UnmarshalXMLAttr(_dde)
			continue
		}
	}
	for {
		_fge, _gg := d.Token()
		if _gg != nil {
			return _b.Errorf("p\u0061\u0072\u0073\u0069ng\u0020B\u006f\u0072\u0064\u0065\u0072t\u006f\u0070\u003a\u0020\u0025\u0073", _gg)
		}
		if _eeb, _gda := _fge.(_c.EndElement); _gda && _eeb.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AnchorLock and its children, prefixing error messages with path
func (_abg *CT_AnchorLock) ValidateWithPath(path string) error { return nil }
func (_egg ST_BorderType) String() string {
	switch _egg {
	case 0:
		return ""
	case 1:
		return "\u006e\u006f\u006e\u0065"
	case 2:
		return "\u0073\u0069\u006e\u0067\u006c\u0065"
	case 3:
		return "\u0074\u0068\u0069c\u006b"
	case 4:
		return "\u0064\u006f\u0075\u0062\u006c\u0065"
	case 5:
		return "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case 6:
		return "\u0064\u006f\u0074"
	case 7:
		return "\u0064\u0061\u0073\u0068"
	case 8:
		return "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case 9:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case 10:
		return "\u0074\u0072\u0069\u0070\u006c\u0065"
	case 11:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case 12:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case 13:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case 14:
		return "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case 15:
		return "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case 16:
		return "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case 17:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case 18:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case 19:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case 20:
		return "\u0077\u0061\u0076\u0065"
	case 21:
		return "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case 22:
		return "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case 23:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case 24:
		return "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case 25:
		return "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case 26:
		return "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case 27:
		return "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return ""
}
func (_dcga ST_BorderType) Validate() error { return _dcga.ValidateWithPath("") }
func (_bce *Wrap) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_bce.CT_Wrap = *NewCT_Wrap()
	for _, _bd := range start.Attr {
		if _bd.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bce.TypeAttr.UnmarshalXMLAttr(_bd)
			continue
		}
		if _bd.Name.Local == "\u0073\u0069\u0064\u0065" {
			_bce.SideAttr.UnmarshalXMLAttr(_bd)
			continue
		}
		if _bd.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_bce.AnchorxAttr.UnmarshalXMLAttr(_bd)
			continue
		}
		if _bd.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_bce.AnchoryAttr.UnmarshalXMLAttr(_bd)
			continue
		}
	}
	for {
		_bae, _bag := d.Token()
		if _bag != nil {
			return _b.Errorf("\u0070\u0061r\u0073\u0069\u006eg\u0020\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _bag)
		}
		if _bga, _aae := _bae.(_c.EndElement); _aae && _bga.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the Wrap and its children
func (_ecb *Wrap) Validate() error { return _ecb.ValidateWithPath("\u0057\u0072\u0061\u0070") }
func (_ffd *Borderright) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_ffd.CT_Border = *NewCT_Border()
	for _, _cb := range start.Attr {
		if _cb.Name.Local == "\u0074\u0079\u0070\u0065" {
			_ffd.TypeAttr.UnmarshalXMLAttr(_cb)
			continue
		}
		if _cb.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_cg, _ee := _d.ParseUint(_cb.Value, 10, 32)
			if _ee != nil {
				return _ee
			}
			_dcb := uint32(_cg)
			_ffd.WidthAttr = &_dcb
			continue
		}
		if _cb.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_ffd.ShadowAttr.UnmarshalXMLAttr(_cb)
			continue
		}
	}
	for {
		_cd, _aa := d.Token()
		if _aa != nil {
			return _b.Errorf("\u0070\u0061\u0072si\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074\u003a\u0020\u0025\u0073", _aa)
		}
		if _acb, _gdc := _cd.(_c.EndElement); _gdc && _acb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewBordertop() *Bordertop { _fdb := &Bordertop{}; _fdb.CT_Border = *NewCT_Border(); return _fdb }
func (_bbe ST_BorderShadow) ValidateWithPath(path string) error {
	switch _bbe {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bbe))
	}
	return nil
}
func (_ab *Borderbottom) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d"
	return _ab.CT_Border.MarshalXML(e, start)
}

type Bordertop struct{ CT_Border }

// Validate validates the CT_Border and its children
func (_gad *CT_Border) Validate() error {
	return _gad.ValidateWithPath("\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r")
}

type Borderright struct{ CT_Border }
type CT_Border struct {
	TypeAttr   ST_BorderType
	WidthAttr  *uint32
	ShadowAttr ST_BorderShadow
}

func (_agb *Wrap) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0077\u0072\u0061\u0070"
	return _agb.CT_Wrap.MarshalXML(e, start)
}
func (_gba ST_VerticalAnchor) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_gdef := _c.Attr{}
	_gdef.Name = name
	switch _gba {
	case ST_VerticalAnchorUnset:
		_gdef.Value = ""
	case ST_VerticalAnchorMargin:
		_gdef.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_VerticalAnchorPage:
		_gdef.Value = "\u0070\u0061\u0067\u0065"
	case ST_VerticalAnchorText:
		_gdef.Value = "\u0074\u0065\u0078\u0074"
	case ST_VerticalAnchorLine:
		_gdef.Value = "\u006c\u0069\u006e\u0065"
	}
	return _gdef, nil
}

// ValidateWithPath validates the Wrap and its children, prefixing error messages with path
func (_eff *Wrap) ValidateWithPath(path string) error {
	if _ffe := _eff.CT_Wrap.ValidateWithPath(path); _ffe != nil {
		return _ffe
	}
	return nil
}

// Validate validates the CT_AnchorLock and its children
func (_fbea *CT_AnchorLock) Validate() error {
	return _fbea.ValidateWithPath("\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b")
}
func (_ef *Anchorlock) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b"
	return _ef.CT_AnchorLock.MarshalXML(e, start)
}

type ST_HorizontalAnchor byte

func (_afc ST_WrapSide) String() string {
	switch _afc {
	case 0:
		return ""
	case 1:
		return "\u0062\u006f\u0074\u0068"
	case 2:
		return "\u006c\u0065\u0066\u0074"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return ""
}
func (_ecf ST_BorderShadow) String() string {
	switch _ecf {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0074\u0072\u0075\u0065"
	case 3:
		return "\u0066"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}
func NewBorderright() *Borderright {
	_ce := &Borderright{}
	_ce.CT_Border = *NewCT_Border()
	return _ce
}

// ValidateWithPath validates the CT_Border and its children, prefixing error messages with path
func (_fbd *CT_Border) ValidateWithPath(path string) error {
	if _acd := _fbd.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _acd != nil {
		return _acd
	}
	if _be := _fbd.ShadowAttr.ValidateWithPath(path + "/\u0053\u0068\u0061\u0064\u006f\u0077\u0041\u0074\u0074\u0072"); _be != nil {
		return _be
	}
	return nil
}
func (_bbad ST_HorizontalAnchor) String() string {
	switch _bbad {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u0063\u0068\u0061\u0072"
	}
	return ""
}
func (_fde *Bordertop) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp"
	return _fde.CT_Border.MarshalXML(e, start)
}

// Validate validates the Borderbottom and its children
func (_ec *Borderbottom) Validate() error {
	return _ec.ValidateWithPath("\u0042\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d")
}

type ST_VerticalAnchor byte

func (_cbc ST_VerticalAnchor) ValidateWithPath(path string) error {
	switch _cbc {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_cbc))
	}
	return nil
}
func (_bed *ST_BorderShadow) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_gfa, _bfa := d.Token()
	if _bfa != nil {
		return _bfa
	}
	if _fdd, _egdd := _gfa.(_c.EndElement); _egdd && _fdd.Name == start.Name {
		*_bed = 1
		return nil
	}
	if _acg, _cgg := _gfa.(_c.CharData); !_cgg {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gfa)
	} else {
		switch string(_acg) {
		case "":
			*_bed = 0
		case "\u0074":
			*_bed = 1
		case "\u0074\u0072\u0075\u0065":
			*_bed = 2
		case "\u0066":
			*_bed = 3
		case "\u0066\u0061\u006cs\u0065":
			*_bed = 4
		}
	}
	_gfa, _bfa = d.Token()
	if _bfa != nil {
		return _bfa
	}
	if _aaa, _fbf := _gfa.(_c.EndElement); _fbf && _aaa.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gfa)
}
func (_ed *Borderleft) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_ed.CT_Border = *NewCT_Border()
	for _, _fg := range start.Attr {
		if _fg.Name.Local == "\u0074\u0079\u0070\u0065" {
			_ed.TypeAttr.UnmarshalXMLAttr(_fg)
			continue
		}
		if _fg.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_ff, _gfg := _d.ParseUint(_fg.Value, 10, 32)
			if _gfg != nil {
				return _gfg
			}
			_cc := uint32(_ff)
			_ed.WidthAttr = &_cc
			continue
		}
		if _fg.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_ed.ShadowAttr.UnmarshalXMLAttr(_fg)
			continue
		}
	}
	for {
		_ded, _eaf := d.Token()
		if _eaf != nil {
			return _b.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074\u003a\u0020%\u0073", _eaf)
		}
		if _ecc, _dg := _ded.(_c.EndElement); _dg && _ecc.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Wrap and its children, prefixing error messages with path
func (_bcd *CT_Wrap) ValidateWithPath(path string) error {
	if _gab := _bcd.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _gab != nil {
		return _gab
	}
	if _ddf := _bcd.SideAttr.ValidateWithPath(path + "\u002fS\u0069\u0064\u0065\u0041\u0074\u0074r"); _ddf != nil {
		return _ddf
	}
	if _dgg := _bcd.AnchorxAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0078\u0041\u0074\u0074\u0072"); _dgg != nil {
		return _dgg
	}
	if _fc := _bcd.AnchoryAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0079\u0041\u0074\u0074\u0072"); _fc != nil {
		return _fc
	}
	return nil
}

type Wrap struct{ CT_Wrap }

func (_fgf ST_HorizontalAnchor) ValidateWithPath(path string) error {
	switch _fgf {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_fgf))
	}
	return nil
}

const (
	ST_VerticalAnchorUnset  ST_VerticalAnchor = 0
	ST_VerticalAnchorMargin ST_VerticalAnchor = 1
	ST_VerticalAnchorPage   ST_VerticalAnchor = 2
	ST_VerticalAnchorText   ST_VerticalAnchor = 3
	ST_VerticalAnchorLine   ST_VerticalAnchor = 4
)

type Borderbottom struct{ CT_Border }

func (_bc *CT_AnchorLock) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for {
		_dea, _fba := d.Token()
		if _fba != nil {
			return _b.Errorf("\u0070a\u0072\u0073\u0069\u006eg\u0020\u0043\u0054\u005f\u0041n\u0063h\u006fr\u004c\u006f\u0063\u006b\u003a\u0020\u0025s", _fba)
		}
		if _abf, _edg := _dea.(_c.EndElement); _edg && _abf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fae *ST_WrapSide) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_gfd, _gcc := d.Token()
	if _gcc != nil {
		return _gcc
	}
	if _ffaf, _ddg := _gfd.(_c.EndElement); _ddg && _ffaf.Name == start.Name {
		*_fae = 1
		return nil
	}
	if _fgeg, _cff := _gfd.(_c.CharData); !_cff {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gfd)
	} else {
		switch string(_fgeg) {
		case "":
			*_fae = 0
		case "\u0062\u006f\u0074\u0068":
			*_fae = 1
		case "\u006c\u0065\u0066\u0074":
			*_fae = 2
		case "\u0072\u0069\u0067h\u0074":
			*_fae = 3
		case "\u006ca\u0072\u0067\u0065\u0073\u0074":
			*_fae = 4
		}
	}
	_gfd, _gcc = d.Token()
	if _gcc != nil {
		return _gcc
	}
	if _ffab, _dcf := _gfd.(_c.EndElement); _dcf && _ffab.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gfd)
}
func NewCT_AnchorLock() *CT_AnchorLock { _bba := &CT_AnchorLock{}; return _bba }

const (
	ST_BorderShadowUnset ST_BorderShadow = 0
	ST_BorderShadowT     ST_BorderShadow = 1
	ST_BorderShadowTrue  ST_BorderShadow = 2
	ST_BorderShadowF     ST_BorderShadow = 3
	ST_BorderShadowFalse ST_BorderShadow = 4
)

func (_ffbb ST_WrapSide) ValidateWithPath(path string) error {
	switch _ffbb {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ffbb))
	}
	return nil
}
func (_gfc ST_BorderType) ValidateWithPath(path string) error {
	switch _gfc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gfc))
	}
	return nil
}
func (_aeb ST_WrapSide) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_gbd := _c.Attr{}
	_gbd.Name = name
	switch _aeb {
	case ST_WrapSideUnset:
		_gbd.Value = ""
	case ST_WrapSideBoth:
		_gbd.Value = "\u0062\u006f\u0074\u0068"
	case ST_WrapSideLeft:
		_gbd.Value = "\u006c\u0065\u0066\u0074"
	case ST_WrapSideRight:
		_gbd.Value = "\u0072\u0069\u0067h\u0074"
	case ST_WrapSideLargest:
		_gbd.Value = "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return _gbd, nil
}
func (_deg *CT_Border) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	if _deg.TypeAttr != ST_BorderTypeUnset {
		_ccd, _aab := _deg.TypeAttr.MarshalXMLAttr(_c.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _aab != nil {
			return _aab
		}
		start.Attr = append(start.Attr, _ccd)
	}
	if _deg.WidthAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0077\u0069\u0064t\u0068"}, Value: _b.Sprintf("\u0025\u0076", *_deg.WidthAttr)})
	}
	if _deg.ShadowAttr != ST_BorderShadowUnset {
		_dgf, _ge := _deg.ShadowAttr.MarshalXMLAttr(_c.Name{Local: "\u0073\u0068\u0061\u0064\u006f\u0077"})
		if _ge != nil {
			return _ge
		}
		start.Attr = append(start.Attr, _dgf)
	}
	e.EncodeToken(start)
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}

// Validate validates the Borderright and its children
func (_cee *Borderright) Validate() error {
	return _cee.ValidateWithPath("B\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074")
}
func (_baa ST_HorizontalAnchor) Validate() error { return _baa.ValidateWithPath("") }
func (_efa ST_BorderShadow) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_cega := _c.Attr{}
	_cega.Name = name
	switch _efa {
	case ST_BorderShadowUnset:
		_cega.Value = ""
	case ST_BorderShadowT:
		_cega.Value = "\u0074"
	case ST_BorderShadowTrue:
		_cega.Value = "\u0074\u0072\u0075\u0065"
	case ST_BorderShadowF:
		_cega.Value = "\u0066"
	case ST_BorderShadowFalse:
		_cega.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _cega, nil
}
func (_gbg ST_WrapSide) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_gbg.String(), start)
}
func (_eeg *ST_WrapType) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_ffb, _fdef := d.Token()
	if _fdef != nil {
		return _fdef
	}
	if _bbc, _dcad := _ffb.(_c.EndElement); _dcad && _bbc.Name == start.Name {
		*_eeg = 1
		return nil
	}
	if _cab, _cba := _ffb.(_c.CharData); !_cba {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _ffb)
	} else {
		switch string(_cab) {
		case "":
			*_eeg = 0
		case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
			*_eeg = 1
		case "\u0073\u0071\u0075\u0061\u0072\u0065":
			*_eeg = 2
		case "\u006e\u006f\u006e\u0065":
			*_eeg = 3
		case "\u0074\u0069\u0067h\u0074":
			*_eeg = 4
		case "\u0074h\u0072\u006f\u0075\u0067\u0068":
			*_eeg = 5
		}
	}
	_ffb, _fdef = d.Token()
	if _fdef != nil {
		return _fdef
	}
	if _cac, _cdd := _ffb.(_c.EndElement); _cdd && _cac.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _ffb)
}
func (_gcec *CT_Wrap) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	if _gcec.TypeAttr != ST_WrapTypeUnset {
		_fbc, _dbe := _gcec.TypeAttr.MarshalXMLAttr(_c.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _dbe != nil {
			return _dbe
		}
		start.Attr = append(start.Attr, _fbc)
	}
	if _gcec.SideAttr != ST_WrapSideUnset {
		_ffa, _efb := _gcec.SideAttr.MarshalXMLAttr(_c.Name{Local: "\u0073\u0069\u0064\u0065"})
		if _efb != nil {
			return _efb
		}
		start.Attr = append(start.Attr, _ffa)
	}
	if _gcec.AnchorxAttr != ST_HorizontalAnchorUnset {
		_afe, _aec := _gcec.AnchorxAttr.MarshalXMLAttr(_c.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0078"})
		if _aec != nil {
			return _aec
		}
		start.Attr = append(start.Attr, _afe)
	}
	if _gcec.AnchoryAttr != ST_VerticalAnchorUnset {
		_cdb, _gb := _gcec.AnchoryAttr.MarshalXMLAttr(_c.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0079"})
		if _gb != nil {
			return _gb
		}
		start.Attr = append(start.Attr, _cdb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}
func (_fdfe ST_WrapType) Validate() error { return _fdfe.ValidateWithPath("") }

const (
	ST_WrapTypeUnset        ST_WrapType = 0
	ST_WrapTypeTopAndBottom ST_WrapType = 1
	ST_WrapTypeSquare       ST_WrapType = 2
	ST_WrapTypeNone         ST_WrapType = 3
	ST_WrapTypeTight        ST_WrapType = 4
	ST_WrapTypeThrough      ST_WrapType = 5
)

func NewBorderbottom() *Borderbottom {
	_dbb := &Borderbottom{}
	_dbb.CT_Border = *NewCT_Border()
	return _dbb
}
func (_dgfe *ST_WrapSide) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_dgfe = 0
	case "\u0062\u006f\u0074\u0068":
		*_dgfe = 1
	case "\u006c\u0065\u0066\u0074":
		*_dgfe = 2
	case "\u0072\u0069\u0067h\u0074":
		*_dgfe = 3
	case "\u006ca\u0072\u0067\u0065\u0073\u0074":
		*_dgfe = 4
	}
	return nil
}
func (_ddb ST_WrapSide) Validate() error { return _ddb.ValidateWithPath("") }

// ValidateWithPath validates the Bordertop and its children, prefixing error messages with path
func (_fef *Bordertop) ValidateWithPath(path string) error {
	if _dag := _fef.CT_Border.ValidateWithPath(path); _dag != nil {
		return _dag
	}
	return nil
}
func (_afg *ST_BorderType) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_afg = 0
	case "\u006e\u006f\u006e\u0065":
		*_afg = 1
	case "\u0073\u0069\u006e\u0067\u006c\u0065":
		*_afg = 2
	case "\u0074\u0068\u0069c\u006b":
		*_afg = 3
	case "\u0064\u006f\u0075\u0062\u006c\u0065":
		*_afg = 4
	case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
		*_afg = 5
	case "\u0064\u006f\u0074":
		*_afg = 6
	case "\u0064\u0061\u0073\u0068":
		*_afg = 7
	case "\u0064o\u0074\u0044\u0061\u0073\u0068":
		*_afg = 8
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
		*_afg = 9
	case "\u0074\u0072\u0069\u0070\u006c\u0065":
		*_afg = 10
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
		*_afg = 11
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
		*_afg = 12
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
		*_afg = 13
	case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
		*_afg = 14
	case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
		*_afg = 15
	case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
		*_afg = 16
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
		*_afg = 17
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
		*_afg = 18
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
		*_afg = 19
	case "\u0077\u0061\u0076\u0065":
		*_afg = 20
	case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
		*_afg = 21
	case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
		*_afg = 22
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
		*_afg = 23
	case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
		*_afg = 24
	case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
		*_afg = 25
	case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
		*_afg = 26
	case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
		*_afg = 27
	}
	return nil
}

type ST_WrapSide byte

func (_a *Anchorlock) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_a.CT_AnchorLock = *NewCT_AnchorLock()
	for {
		_ag, _gc := d.Token()
		if _gc != nil {
			return _b.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b\u003a\u0020%\u0073", _gc)
		}
		if _ac, _gd := _ag.(_c.EndElement); _gd && _ac.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gege ST_VerticalAnchor) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_gege.String(), start)
}
func NewCT_Border() *CT_Border { _dca := &CT_Border{}; return _dca }

type CT_AnchorLock struct{}

func (_gde *ST_BorderType) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_bgd, _eea := d.Token()
	if _eea != nil {
		return _eea
	}
	if _fbde, _ca := _bgd.(_c.EndElement); _ca && _fbde.Name == start.Name {
		*_gde = 1
		return nil
	}
	if _afgb, _dfa := _bgd.(_c.CharData); !_dfa {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bgd)
	} else {
		switch string(_afgb) {
		case "":
			*_gde = 0
		case "\u006e\u006f\u006e\u0065":
			*_gde = 1
		case "\u0073\u0069\u006e\u0067\u006c\u0065":
			*_gde = 2
		case "\u0074\u0068\u0069c\u006b":
			*_gde = 3
		case "\u0064\u006f\u0075\u0062\u006c\u0065":
			*_gde = 4
		case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
			*_gde = 5
		case "\u0064\u006f\u0074":
			*_gde = 6
		case "\u0064\u0061\u0073\u0068":
			*_gde = 7
		case "\u0064o\u0074\u0044\u0061\u0073\u0068":
			*_gde = 8
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
			*_gde = 9
		case "\u0074\u0072\u0069\u0070\u006c\u0065":
			*_gde = 10
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
			*_gde = 11
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
			*_gde = 12
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
			*_gde = 13
		case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
			*_gde = 14
		case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
			*_gde = 15
		case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
			*_gde = 16
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
			*_gde = 17
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
			*_gde = 18
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
			*_gde = 19
		case "\u0077\u0061\u0076\u0065":
			*_gde = 20
		case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
			*_gde = 21
		case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
			*_gde = 22
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
			*_gde = 23
		case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
			*_gde = 24
		case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
			*_gde = 25
		case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
			*_gde = 26
		case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
			*_gde = 27
		}
	}
	_bgd, _eea = d.Token()
	if _eea != nil {
		return _eea
	}
	if _aeg, _degb := _bgd.(_c.EndElement); _degb && _aeg.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bgd)
}
func (_gcb *ST_HorizontalAnchor) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_gcb = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_gcb = 1
	case "\u0070\u0061\u0067\u0065":
		*_gcb = 2
	case "\u0074\u0065\u0078\u0074":
		*_gcb = 3
	case "\u0063\u0068\u0061\u0072":
		*_gcb = 4
	}
	return nil
}
func (_ad ST_HorizontalAnchor) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_ad.String(), start)
}

// ValidateWithPath validates the Anchorlock and its children, prefixing error messages with path
func (_ba *Anchorlock) ValidateWithPath(path string) error {
	if _eg := _ba.CT_AnchorLock.ValidateWithPath(path); _eg != nil {
		return _eg
	}
	return nil
}
func NewAnchorlock() *Anchorlock {
	_db := &Anchorlock{}
	_db.CT_AnchorLock = *NewCT_AnchorLock()
	return _db
}
func NewCT_Wrap() *CT_Wrap { _aea := &CT_Wrap{}; return _aea }
func (_dfd ST_VerticalAnchor) String() string {
	switch _dfd {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u006c\u0069\u006e\u0065"
	}
	return ""
}
func (_fdc *Borderleft) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074"
	return _fdc.CT_Border.MarshalXML(e, start)
}

// ValidateWithPath validates the Borderright and its children, prefixing error messages with path
func (_age *Borderright) ValidateWithPath(path string) error {
	if _egd := _age.CT_Border.ValidateWithPath(path); _egd != nil {
		return _egd
	}
	return nil
}
func (_cbb *ST_VerticalAnchor) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_cfda, _aca := d.Token()
	if _aca != nil {
		return _aca
	}
	if _cfdd, _abc := _cfda.(_c.EndElement); _abc && _cfdd.Name == start.Name {
		*_cbb = 1
		return nil
	}
	if _eec, _eebe := _cfda.(_c.CharData); !_eebe {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cfda)
	} else {
		switch string(_eec) {
		case "":
			*_cbb = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_cbb = 1
		case "\u0070\u0061\u0067\u0065":
			*_cbb = 2
		case "\u0074\u0065\u0078\u0074":
			*_cbb = 3
		case "\u006c\u0069\u006e\u0065":
			*_cbb = 4
		}
	}
	_cfda, _aca = d.Token()
	if _aca != nil {
		return _aca
	}
	if _aef, _babe := _cfda.(_c.EndElement); _babe && _aef.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cfda)
}
func (_ceg *Borderright) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074"
	return _ceg.CT_Border.MarshalXML(e, start)
}
func (_fgff *ST_VerticalAnchor) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_fgff = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_fgff = 1
	case "\u0070\u0061\u0067\u0065":
		*_fgff = 2
	case "\u0074\u0065\u0078\u0074":
		*_fgff = 3
	case "\u006c\u0069\u006e\u0065":
		*_fgff = 4
	}
	return nil
}

// Validate validates the Bordertop and its children
func (_dcbe *Bordertop) Validate() error {
	return _dcbe.ValidateWithPath("\u0042o\u0072\u0064\u0065\u0072\u0074\u006fp")
}
func (_ccf ST_BorderType) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_dfb := _c.Attr{}
	_dfb.Name = name
	switch _ccf {
	case ST_BorderTypeUnset:
		_dfb.Value = ""
	case ST_BorderTypeNone:
		_dfb.Value = "\u006e\u006f\u006e\u0065"
	case ST_BorderTypeSingle:
		_dfb.Value = "\u0073\u0069\u006e\u0067\u006c\u0065"
	case ST_BorderTypeThick:
		_dfb.Value = "\u0074\u0068\u0069c\u006b"
	case ST_BorderTypeDouble:
		_dfb.Value = "\u0064\u006f\u0075\u0062\u006c\u0065"
	case ST_BorderTypeHairline:
		_dfb.Value = "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case ST_BorderTypeDot:
		_dfb.Value = "\u0064\u006f\u0074"
	case ST_BorderTypeDash:
		_dfb.Value = "\u0064\u0061\u0073\u0068"
	case ST_BorderTypeDotDash:
		_dfb.Value = "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case ST_BorderTypeDashDotDot:
		_dfb.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case ST_BorderTypeTriple:
		_dfb.Value = "\u0074\u0072\u0069\u0070\u006c\u0065"
	case ST_BorderTypeThinThickSmall:
		_dfb.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickThinSmall:
		_dfb.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickBetweenThinSmall:
		_dfb.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThinThick:
		_dfb.Value = "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case ST_BorderTypeThickThin:
		_dfb.Value = "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case ST_BorderTypeThickBetweenThin:
		_dfb.Value = "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case ST_BorderTypeThinThickLarge:
		_dfb.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickThinLarge:
		_dfb.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickBetweenThinLarge:
		_dfb.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case ST_BorderTypeWave:
		_dfb.Value = "\u0077\u0061\u0076\u0065"
	case ST_BorderTypeDoubleWave:
		_dfb.Value = "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case ST_BorderTypeDashedSmall:
		_dfb.Value = "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeDashDotStroked:
		_dfb.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case ST_BorderTypeThreeDEmboss:
		_dfb.Value = "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case ST_BorderTypeThreeDEngrave:
		_dfb.Value = "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case ST_BorderTypeHTMLOutset:
		_dfb.Value = "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case ST_BorderTypeHTMLInset:
		_dfb.Value = "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return _dfb, nil
}

const (
	ST_HorizontalAnchorUnset  ST_HorizontalAnchor = 0
	ST_HorizontalAnchorMargin ST_HorizontalAnchor = 1
	ST_HorizontalAnchorPage   ST_HorizontalAnchor = 2
	ST_HorizontalAnchorText   ST_HorizontalAnchor = 3
	ST_HorizontalAnchorChar   ST_HorizontalAnchor = 4
)

func (_ccg ST_VerticalAnchor) Validate() error { return _ccg.ValidateWithPath("") }

const (
	ST_WrapSideUnset   ST_WrapSide = 0
	ST_WrapSideBoth    ST_WrapSide = 1
	ST_WrapSideLeft    ST_WrapSide = 2
	ST_WrapSideRight   ST_WrapSide = 3
	ST_WrapSideLargest ST_WrapSide = 4
)

func (_cfc ST_WrapType) ValidateWithPath(path string) error {
	switch _cfc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_cfc))
	}
	return nil
}

// Validate validates the Borderleft and its children
func (_dcg *Borderleft) Validate() error {
	return _dcg.ValidateWithPath("\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074")
}
func (_bbf ST_HorizontalAnchor) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_gbf := _c.Attr{}
	_gbf.Name = name
	switch _bbf {
	case ST_HorizontalAnchorUnset:
		_gbf.Value = ""
	case ST_HorizontalAnchorMargin:
		_gbf.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_HorizontalAnchorPage:
		_gbf.Value = "\u0070\u0061\u0067\u0065"
	case ST_HorizontalAnchorText:
		_gbf.Value = "\u0074\u0065\u0078\u0074"
	case ST_HorizontalAnchorChar:
		_gbf.Value = "\u0063\u0068\u0061\u0072"
	}
	return _gbf, nil
}

type Anchorlock struct{ CT_AnchorLock }

func (_eb *Borderbottom) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_eb.CT_Border = *NewCT_Border()
	for _, _ea := range start.Attr {
		if _ea.Name.Local == "\u0074\u0079\u0070\u0065" {
			_eb.TypeAttr.UnmarshalXMLAttr(_ea)
			continue
		}
		if _ea.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_ga, _fd := _d.ParseUint(_ea.Value, 10, 32)
			if _fd != nil {
				return _fd
			}
			_ae := uint32(_ga)
			_eb.WidthAttr = &_ae
			continue
		}
		if _ea.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_eb.ShadowAttr.UnmarshalXMLAttr(_ea)
			continue
		}
	}
	for {
		_egf, _dd := d.Token()
		if _dd != nil {
			return _b.Errorf("\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065r\u0062\u006f\u0074\u0074\u006f\u006d\u003a\u0020\u0025\u0073", _dd)
		}
		if _gae, _bg := _egf.(_c.EndElement); _bg && _gae.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gea ST_WrapType) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_gea.String(), start)
}
func (_ecaf ST_WrapType) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_gdd := _c.Attr{}
	_gdd.Name = name
	switch _ecaf {
	case ST_WrapTypeUnset:
		_gdd.Value = ""
	case ST_WrapTypeTopAndBottom:
		_gdd.Value = "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case ST_WrapTypeSquare:
		_gdd.Value = "\u0073\u0071\u0075\u0061\u0072\u0065"
	case ST_WrapTypeNone:
		_gdd.Value = "\u006e\u006f\u006e\u0065"
	case ST_WrapTypeTight:
		_gdd.Value = "\u0074\u0069\u0067h\u0074"
	case ST_WrapTypeThrough:
		_gdd.Value = "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return _gdd, nil
}

// Validate validates the CT_Wrap and its children
func (_agef *CT_Wrap) Validate() error {
	return _agef.ValidateWithPath("\u0043T\u005f\u0057\u0072\u0061\u0070")
}
func (_fff *CT_Wrap) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for _, _dede := range start.Attr {
		if _dede.Name.Local == "\u0074\u0079\u0070\u0065" {
			_fff.TypeAttr.UnmarshalXMLAttr(_dede)
			continue
		}
		if _dede.Name.Local == "\u0073\u0069\u0064\u0065" {
			_fff.SideAttr.UnmarshalXMLAttr(_dede)
			continue
		}
		if _dede.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_fff.AnchorxAttr.UnmarshalXMLAttr(_dede)
			continue
		}
		if _dede.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_fff.AnchoryAttr.UnmarshalXMLAttr(_dede)
			continue
		}
	}
	for {
		_gdb, _dgc := d.Token()
		if _dgc != nil {
			return _b.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0043\u0054\u005f\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _dgc)
		}
		if _df, _deb := _gdb.(_c.EndElement); _deb && _df.Name == start.Name {
			break
		}
	}
	return nil
}

type Borderleft struct{ CT_Border }

func (_ged ST_WrapType) String() string {
	switch _ged {
	case 0:
		return ""
	case 1:
		return "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case 2:
		return "\u0073\u0071\u0075\u0061\u0072\u0065"
	case 3:
		return "\u006e\u006f\u006e\u0065"
	case 4:
		return "\u0074\u0069\u0067h\u0074"
	case 5:
		return "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return ""
}

type ST_BorderType byte

func (_ede ST_BorderShadow) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_ede.String(), start)
}

const (
	ST_BorderTypeUnset                 ST_BorderType = 0
	ST_BorderTypeNone                  ST_BorderType = 1
	ST_BorderTypeSingle                ST_BorderType = 2
	ST_BorderTypeThick                 ST_BorderType = 3
	ST_BorderTypeDouble                ST_BorderType = 4
	ST_BorderTypeHairline              ST_BorderType = 5
	ST_BorderTypeDot                   ST_BorderType = 6
	ST_BorderTypeDash                  ST_BorderType = 7
	ST_BorderTypeDotDash               ST_BorderType = 8
	ST_BorderTypeDashDotDot            ST_BorderType = 9
	ST_BorderTypeTriple                ST_BorderType = 10
	ST_BorderTypeThinThickSmall        ST_BorderType = 11
	ST_BorderTypeThickThinSmall        ST_BorderType = 12
	ST_BorderTypeThickBetweenThinSmall ST_BorderType = 13
	ST_BorderTypeThinThick             ST_BorderType = 14
	ST_BorderTypeThickThin             ST_BorderType = 15
	ST_BorderTypeThickBetweenThin      ST_BorderType = 16
	ST_BorderTypeThinThickLarge        ST_BorderType = 17
	ST_BorderTypeThickThinLarge        ST_BorderType = 18
	ST_BorderTypeThickBetweenThinLarge ST_BorderType = 19
	ST_BorderTypeWave                  ST_BorderType = 20
	ST_BorderTypeDoubleWave            ST_BorderType = 21
	ST_BorderTypeDashedSmall           ST_BorderType = 22
	ST_BorderTypeDashDotStroked        ST_BorderType = 23
	ST_BorderTypeThreeDEmboss          ST_BorderType = 24
	ST_BorderTypeThreeDEngrave         ST_BorderType = 25
	ST_BorderTypeHTMLOutset            ST_BorderType = 26
	ST_BorderTypeHTMLInset             ST_BorderType = 27
)

func NewBorderleft() *Borderleft { _bf := &Borderleft{}; _bf.CT_Border = *NewCT_Border(); return _bf }

// ValidateWithPath validates the Borderleft and its children, prefixing error messages with path
func (_bb *Borderleft) ValidateWithPath(path string) error {
	if _da := _bb.CT_Border.ValidateWithPath(path); _da != nil {
		return _da
	}
	return nil
}

// ValidateWithPath validates the Borderbottom and its children, prefixing error messages with path
func (_fa *Borderbottom) ValidateWithPath(path string) error {
	if _dc := _fa.CT_Border.ValidateWithPath(path); _dc != nil {
		return _dc
	}
	return nil
}
func (_feb *ST_BorderShadow) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_feb = 0
	case "\u0074":
		*_feb = 1
	case "\u0074\u0072\u0075\u0065":
		*_feb = 2
	case "\u0066":
		*_feb = 3
	case "\u0066\u0061\u006cs\u0065":
		*_feb = 4
	}
	return nil
}
func (_fbcg ST_BorderShadow) Validate() error { return _fbcg.ValidateWithPath("") }
func (_fda *CT_AnchorLock) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}
func (_ead *ST_HorizontalAnchor) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_dac, _gec := d.Token()
	if _gec != nil {
		return _gec
	}
	if _gbfe, _bfg := _dac.(_c.EndElement); _bfg && _gbfe.Name == start.Name {
		*_ead = 1
		return nil
	}
	if _gge, _bgad := _dac.(_c.CharData); !_bgad {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dac)
	} else {
		switch string(_gge) {
		case "":
			*_ead = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_ead = 1
		case "\u0070\u0061\u0067\u0065":
			*_ead = 2
		case "\u0074\u0065\u0078\u0074":
			*_ead = 3
		case "\u0063\u0068\u0061\u0072":
			*_ead = 4
		}
	}
	_dac, _gec = d.Token()
	if _gec != nil {
		return _gec
	}
	if _ffg, _geg := _dac.(_c.EndElement); _geg && _ffg.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dac)
}

type CT_Wrap struct {
	TypeAttr    ST_WrapType
	SideAttr    ST_WrapSide
	AnchorxAttr ST_HorizontalAnchor
	AnchoryAttr ST_VerticalAnchor
}
type ST_BorderShadow byte

// Validate validates the Anchorlock and its children
func (_f *Anchorlock) Validate() error {
	return _f.ValidateWithPath("\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b")
}
func NewWrap() *Wrap { _eca := &Wrap{}; _eca.CT_Wrap = *NewCT_Wrap(); return _eca }

type ST_WrapType byte

func (_bcf *ST_WrapType) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_bcf = 0
	case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
		*_bcf = 1
	case "\u0073\u0071\u0075\u0061\u0072\u0065":
		*_bcf = 2
	case "\u006e\u006f\u006e\u0065":
		*_bcf = 3
	case "\u0074\u0069\u0067h\u0074":
		*_bcf = 4
	case "\u0074h\u0072\u006f\u0075\u0067\u0068":
		*_bcf = 5
	}
	return nil
}
func (_dga *CT_Border) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for _, _eab := range start.Attr {
		if _eab.Name.Local == "\u0074\u0079\u0070\u0065" {
			_dga.TypeAttr.UnmarshalXMLAttr(_eab)
			continue
		}
		if _eab.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_gce, _faa := _d.ParseUint(_eab.Value, 10, 32)
			if _faa != nil {
				return _faa
			}
			_cf := uint32(_gce)
			_dga.WidthAttr = &_cf
			continue
		}
		if _eab.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_dga.ShadowAttr.UnmarshalXMLAttr(_eab)
			continue
		}
	}
	for {
		_fgca, _fbag := d.Token()
		if _fbag != nil {
			return _b.Errorf("p\u0061\u0072\u0073\u0069ng\u0020C\u0054\u005f\u0042\u006f\u0072d\u0065\u0072\u003a\u0020\u0025\u0073", _fbag)
		}
		if _cfd, _aac := _fgca.(_c.EndElement); _aac && _cfd.Name == start.Name {
			break
		}
	}
	return nil
}
func init() {
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r", NewCT_Border)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0057\u0072\u0061\u0070", NewCT_Wrap)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b", NewCT_AnchorLock)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp", NewBordertop)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074", NewBorderleft)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074", NewBorderright)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d", NewBorderbottom)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0077\u0072\u0061\u0070", NewWrap)
	_g.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b", NewAnchorlock)
}
